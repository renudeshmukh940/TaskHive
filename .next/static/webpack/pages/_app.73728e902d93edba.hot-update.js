"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./lib/firebase.js":
/*!*************************!*\
  !*** ./lib/firebase.js ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addTask: () => (/* binding */ addTask),\n/* harmony export */   addTeamClient: () => (/* binding */ addTeamClient),\n/* harmony export */   addTeamEmployee: () => (/* binding */ addTeamEmployee),\n/* harmony export */   addTeamProject: () => (/* binding */ addTeamProject),\n/* harmony export */   applyTaskFilters: () => (/* binding */ applyTaskFilters),\n/* harmony export */   canUserAccessEmployee: () => (/* binding */ canUserAccessEmployee),\n/* harmony export */   canUserAccessTeam: () => (/* binding */ canUserAccessTeam),\n/* harmony export */   deleteTask: () => (/* binding */ deleteTask),\n/* harmony export */   getAccessibleTeams: () => (/* binding */ getAccessibleTeams),\n/* harmony export */   getFilterOptions: () => (/* binding */ getFilterOptions),\n/* harmony export */   getFilteredTasks: () => (/* binding */ getFilteredTasks),\n/* harmony export */   getPredefinedValues: () => (/* binding */ getPredefinedValues),\n/* harmony export */   getTasks: () => (/* binding */ getTasks),\n/* harmony export */   getTeamClients: () => (/* binding */ getTeamClients),\n/* harmony export */   getTeamDropdownData: () => (/* binding */ getTeamDropdownData),\n/* harmony export */   getTeamEmployees: () => (/* binding */ getTeamEmployees),\n/* harmony export */   getTeamProjects: () => (/* binding */ getTeamProjects),\n/* harmony export */   getTeams: () => (/* binding */ getTeams),\n/* harmony export */   getUserProfile: () => (/* binding */ getUserProfile),\n/* harmony export */   getWeeklyTasks: () => (/* binding */ getWeeklyTasks),\n/* harmony export */   initializeTeamDefaults: () => (/* binding */ initializeTeamDefaults),\n/* harmony export */   isPredefinedField: () => (/* binding */ isPredefinedField),\n/* harmony export */   saveTeamDropdownData: () => (/* binding */ saveTeamDropdownData),\n/* harmony export */   teamExists: () => (/* binding */ teamExists),\n/* harmony export */   updateTask: () => (/* binding */ updateTask),\n/* harmony export */   updateUserProfile: () => (/* binding */ updateUserProfile)\n/* harmony export */ });\n/* harmony import */ var _firebaseConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./firebaseConfig */ \"(pages-dir-browser)/./lib/firebaseConfig.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(pages-dir-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n// lib/firebase.js - Updated with user context filtering\n\n\n// -------------------- PREDEFINED VALUES --------------------\nconst PREDEFINED_VALUES = {\n    percentageCompletion: [\n        '5',\n        '10',\n        '25',\n        '40',\n        '50',\n        '65',\n        '75',\n        '85',\n        '90',\n        '100'\n    ],\n    status: [\n        'Completed',\n        'In Progress',\n        'On Hold'\n    ],\n    workType: [\n        'Full-day',\n        'Half-day',\n        'Relaxation'\n    ]\n};\n// -------------------- USER MANAGEMENT --------------------\n// Get user profile\nconst getUserProfile = async (userId)=>{\n    try {\n        const userDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users', userId));\n        if (userDoc.exists()) {\n            return userDoc.data();\n        }\n        return null;\n    } catch (error) {\n        console.error('Error getting user profile:', error);\n        return null;\n    }\n};\n// Update user profile\nconst updateUserProfile = async (userId, profileData)=>{\n    try {\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users', userId), profileData, {\n            merge: true\n        });\n    } catch (error) {\n        console.error('Error updating user profile:', error);\n        throw error;\n    }\n};\n// -------------------- TASKS WITH USER CONTEXT --------------------\n// lib/firebase.js - Keep addTask for new tasks only\nconst addTask = async (task, userProfile)=>{\n    try {\n        if (userProfile.role === 'tech-lead') {\n            task.teamName = 'techLeads';\n        }\n        // Validate user can add task to this team/employee\n        if (!canUserAccessEmployee(userProfile, task.teamName, task.empId)) {\n            throw new Error('You do not have permission to add tasks for this employee');\n        }\n        // Create the default team name...\n        await initializeTeamDefaults(task.teamName);\n        // Ensure date document exists\n        const dateRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', task.teamName, 'dates', task.date);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(dateRef, {\n            createdAt: new Date().toISOString()\n        }, {\n            merge: true\n        });\n        // Ensure employee document exists with name\n        const empRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', task.teamName, 'dates', task.date, 'employees', task.empId);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(empRef, {\n            name: task.empName\n        }, {\n            merge: true\n        });\n        // Auto-save new employee to team employees if not exists\n        if (task.empId && task.empName) {\n            await addTeamEmployee(task.teamName, task.empId, task.empName);\n        }\n        // Auto-save new client to team clients if not exists\n        if (task.clientId && task.clientName) {\n            await addTeamClient(task.teamName, task.clientId, task.clientName);\n        }\n        // Auto-save new project to team projects if not exists\n        if (task.projectId && task.projectName) {\n            await addTeamProject(task.teamName, task.projectId, task.projectName);\n        }\n        const taskData = {\n            ...task,\n            createdAt: new Date().toISOString(),\n            createdBy: userProfile.empId\n        };\n        const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', task.teamName, 'dates', task.date, 'employees', task.empId, 'tasks'), taskData);\n        // Return full task object with ID for consistency\n        return {\n            ...task,\n            id: docRef.id,\n            createdAt: new Date().toISOString(),\n            createdBy: userProfile.empId\n        };\n    } catch (error) {\n        console.error('Error adding task:', error);\n        throw error;\n    }\n};\n// Update the existing updateTask function to handle auto-save logic\nconst updateTask = async (teamName, date, empId, taskId, taskData, userProfile)=>{\n    try {\n        // Check if user can update this task\n        if (!canUserAccessEmployee(userProfile, teamName, empId)) {\n            throw new Error('You do not have permission to update this task');\n        }\n        // Auto-save new employee to team employees if not exists\n        if (taskData.empId && taskData.empName) {\n            await addTeamEmployee(teamName, taskData.empId, taskData.empName);\n        }\n        // Auto-save new client to team clients if not exists\n        if (taskData.clientId && taskData.clientName) {\n            await addTeamClient(teamName, taskData.clientId, taskData.clientName);\n        }\n        // Auto-save new project to team projects if not exists\n        if (taskData.projectId && taskData.projectName) {\n            await addTeamProject(teamName, taskData.projectId, taskData.projectName);\n        }\n        const taskRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', date, 'employees', empId, 'tasks', taskId);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(taskRef, {\n            ...taskData,\n            updatedAt: new Date().toISOString(),\n            updatedBy: userProfile.empId\n        });\n        // Return the updated task data for consistency\n        return {\n            ...taskData,\n            id: taskId,\n            teamName,\n            date,\n            empId,\n            updatedAt: new Date().toISOString(),\n            updatedBy: userProfile.empId\n        };\n    } catch (error) {\n        console.error('Error updating task:', error);\n        throw error;\n    }\n};\nconst getTasks = async function(userProfile) {\n    let teamFilter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n    try {\n        if (!userProfile) {\n            throw new Error('User profile is required');\n        }\n        let allTasks = [];\n        const today = format(new Date(), 'yyyy-MM-dd');\n        // Determine which teams user can access\n        let accessibleTeams;\n        switch(userProfile.role){\n            case 'tech-lead':\n                accessibleTeams = [\n                    ...userProfile.managedTeams || [],\n                    'techLeads'\n                ];\n                break;\n            case 'team-leader':\n            case 'track-lead':\n            case 'employee':\n                accessibleTeams = [\n                    userProfile.teamName\n                ];\n                break;\n            default:\n                return [];\n        }\n        // Apply team filter if provided\n        if (teamFilter && teamFilter !== 'all') {\n            accessibleTeams = accessibleTeams.filter((team)=>team === teamFilter);\n        }\n        console.log(\"Fetching today's tasks for \".concat(userProfile.role, \" (\").concat(userProfile.empId, \") from teams:\"), accessibleTeams);\n        // Fetch tasks from accessible teams for TODAY only\n        for (const teamName of accessibleTeams){\n            try {\n                const employeesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', today, 'employees'));\n                for (const empDoc of employeesSnapshot.docs){\n                    const empId = empDoc.id;\n                    // Check access\n                    const canAccess = await canUserAccessEmployee(userProfile, teamName, empId);\n                    if (!canAccess) {\n                        console.log(\"Access denied for \".concat(userProfile.role, \" (\").concat(userProfile.empId, \") to employee \").concat(empId, \" in team \").concat(teamName));\n                        continue;\n                    }\n                    console.log(\"Access granted for \".concat(userProfile.role, \" (\").concat(userProfile.empId, \") to employee \").concat(empId, \" in team \").concat(teamName));\n                    const tasksSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', today, 'employees', empId, 'tasks'));\n                    const empTasks = tasksSnapshot.docs.map((taskDoc)=>({\n                            teamName,\n                            date: today,\n                            empId,\n                            ...taskDoc.data(),\n                            id: taskDoc.id\n                        }));\n                    allTasks = [\n                        ...allTasks,\n                        ...empTasks\n                    ];\n                    console.log(\"Found \".concat(empTasks.length, \" tasks for employee \").concat(empId, \" on \").concat(today));\n                }\n            } catch (teamError) {\n                console.error(\"Error fetching tasks for team \".concat(teamName, \":\"), teamError);\n            }\n        }\n        console.log(\"Total today's tasks fetched for \".concat(userProfile.role, \": \").concat(allTasks.length));\n        return allTasks.sort((a, b)=>new Date(b.date) - new Date(a.date));\n    } catch (error) {\n        console.error('Error getting tasks:', error);\n        throw error;\n    }\n};\n// // Update a task (with user permission check)\n// export const updateTask = async (teamName, date, empId, taskId, taskData, userProfile) => {\n//     try {\n//         // Check if user can update this task\n//         if (!canUserAccessEmployee(userProfile, teamName, empId)) {\n//             throw new Error('You do not have permission to update this task');\n//         }\n//         const taskRef = doc(db, 'teams', teamName, 'dates', date, 'employees', empId, 'tasks', taskId);\n//         await updateDoc(taskRef, {\n//             ...taskData,\n//             updatedAt: new Date().toISOString(),\n//             updatedBy: userProfile.empId\n//         });\n//     } catch (error) {\n//         console.error('Error updating task:', error);\n//         throw error;\n//     }\n// };\n// Delete a task (with user permission check)\nconst deleteTask = async (teamName, date, empId, taskId, userProfile)=>{\n    try {\n        // Check if user can delete this task\n        if (!canUserAccessEmployee(userProfile, teamName, empId)) {\n            throw new Error('You do not have permission to delete this task');\n        }\n        const taskRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', date, 'employees', empId, 'tasks', taskId);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.deleteDoc)(taskRef);\n    } catch (error) {\n        console.error('Error deleting task:', error);\n        throw error;\n    }\n};\n// -------------------- PERMISSION HELPERS --------------------\n// Check if user can access specific team\nconst canUserAccessTeam = (userProfile, teamName)=>{\n    if (!userProfile) {\n        console.log('No user profile provided');\n        return false;\n    }\n    console.log(\"Checking access for user \".concat(userProfile.empId, \" (\").concat(userProfile.role, \") to team \").concat(teamName));\n    switch(userProfile.role){\n        case 'tech-lead':\n            var _userProfile_managedTeams;\n            // Tech leads can access:\n            // 1. Teams they manage (from managedTeams array)\n            // 2. The special 'techLeads' team for their personal tasks\n            const canAccessManagedTeam = (_userProfile_managedTeams = userProfile.managedTeams) === null || _userProfile_managedTeams === void 0 ? void 0 : _userProfile_managedTeams.includes(teamName);\n            const canAccessTechLeadsTeam = teamName === 'techLeads';\n            const techLeadAccess = canAccessManagedTeam || canAccessTechLeadsTeam;\n            console.log('Tech lead access check:', {\n                managedTeams: userProfile.managedTeams,\n                requestedTeam: teamName,\n                canAccessManagedTeam,\n                canAccessTechLeadsTeam,\n                finalAccess: techLeadAccess\n            });\n            return techLeadAccess;\n        case 'team-leader':\n        case 'track-lead':\n        case 'employee':\n            const regularAccess = userProfile.teamName === teamName;\n            console.log('Regular user access:', {\n                userTeam: userProfile.teamName,\n                requestedTeam: teamName,\n                access: regularAccess\n            });\n            return regularAccess;\n        default:\n            console.log('Unknown role:', userProfile.role);\n            return false;\n    }\n};\nconst canUserAccessEmployee = async (userProfile, teamName, targetEmpId)=>{\n    if (!userProfile) return false;\n    if (userProfile.teamName !== teamName && userProfile.role !== 'tech-lead') {\n        return false;\n    }\n    switch(userProfile.role){\n        case 'tech-lead':\n            var _userProfile_managedTeams;\n            return (_userProfile_managedTeams = userProfile.managedTeams) === null || _userProfile_managedTeams === void 0 ? void 0 : _userProfile_managedTeams.includes(teamName);\n        case 'team-leader':\n            if (userProfile.teamName !== teamName) return false;\n            return true;\n        case 'track-lead':\n            if (userProfile.teamName !== teamName) return false;\n            try {\n                const usersQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('empId', '==', targetEmpId));\n                const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(usersQuery);\n                if (snapshot.empty) return false;\n                const targetUser = snapshot.docs[0].data();\n                const canAccess = targetUser.empId === userProfile.empId || targetUser.role === 'employee' && targetUser.reportsTo === userProfile.empId;\n                return canAccess;\n            } catch (error) {\n                console.error('Error checking employee access:', error);\n                return false;\n            }\n        case 'employee':\n            return userProfile.teamName === teamName && userProfile.empId === targetEmpId;\n        default:\n            return false;\n    }\n};\n// Get accessible teams for current user\nconst getAccessibleTeams = (userProfile)=>{\n    if (!userProfile) return [];\n    switch(userProfile.role){\n        case 'tech-lead':\n            return userProfile.managedTeams || [];\n        case 'team-leader':\n        case 'track-lead':\n        case 'employee':\n            return [\n                userProfile.teamName\n            ];\n        default:\n            return [];\n    }\n};\n// -------------------- FILTER BASED ON ROLES --------------------\nconst getFilterOptions = async (userProfile)=>{\n    try {\n        const options = {\n            techLeads: [],\n            teamLeaders: [],\n            trackLeads: [],\n            employees: [],\n            teams: []\n        };\n        if (!userProfile) return options;\n        if (userProfile.role === 'tech-lead') {\n            // Tech leads can filter by everything in their managed teams\n            options.teams = userProfile.managedTeams || [];\n            // Use Set for deduplication like old logic\n            const techLeadsSet = new Set();\n            const teamLeadersSet = new Set();\n            const trackLeadsSet = new Set();\n            const employeesSet = new Set();\n            for (const teamName of userProfile.managedTeams){\n                try {\n                    // Get all users in this team (more efficient than separate queries)\n                    const usersQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('teamName', '==', teamName));\n                    const usersSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(usersQuery);\n                    usersSnapshot.forEach((doc)=>{\n                        const data = doc.data();\n                        const userData = {\n                            empId: data.empId,\n                            empName: data.empName,\n                            teamName: data.teamName\n                        };\n                        // Create unique key for deduplication\n                        const key = \"\".concat(data.role, \"-\").concat(data.empId);\n                        switch(data.role){\n                            case 'tech-lead':\n                                if (!techLeadsSet.has(key)) {\n                                    techLeadsSet.add(JSON.stringify(userData));\n                                }\n                                break;\n                            case 'team-leader':\n                                if (!teamLeadersSet.has(key)) {\n                                    teamLeadersSet.add(JSON.stringify(userData));\n                                }\n                                break;\n                            case 'track-lead':\n                                if (!trackLeadsSet.has(key)) {\n                                    trackLeadsSet.add(JSON.stringify(userData));\n                                }\n                                break;\n                            case 'employee':\n                                if (!employeesSet.has(key)) {\n                                    employeesSet.add(JSON.stringify(userData));\n                                }\n                                break;\n                        }\n                    });\n                } catch (error) {\n                    console.error(\"Error fetching data for team \".concat(teamName, \":\"), error);\n                }\n            }\n            // Convert sets back to arrays with consistent structure\n            options.techLeads = Array.from(techLeadsSet).map(JSON.parse);\n            options.teamLeaders = Array.from(teamLeadersSet).map(JSON.parse);\n            options.trackLeads = Array.from(trackLeadsSet).map(JSON.parse);\n            options.employees = Array.from(employeesSet).map(JSON.parse);\n        } else if (userProfile.role === 'team-leader') {\n            // Team leaders can filter by track-leads and employees in their team\n            options.teams = [\n                userProfile.teamName\n            ];\n            try {\n                // Get track-leads - Use Set for consistency\n                const trackLeadsSet = new Set();\n                const trackLeadsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('role', '==', 'track-lead'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('teamName', '==', userProfile.teamName));\n                const trackLeadsSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(trackLeadsQuery);\n                trackLeadsSnapshot.forEach((doc)=>{\n                    const data = doc.data();\n                    const userData = {\n                        empId: data.empId,\n                        empName: data.empName,\n                        teamName: data.teamName\n                    };\n                    const key = \"\".concat(data.role, \"-\").concat(data.empId);\n                    if (!trackLeadsSet.has(key)) {\n                        trackLeadsSet.add(JSON.stringify(userData));\n                    }\n                });\n                options.trackLeads = Array.from(trackLeadsSet).map(JSON.parse);\n                // Get employees - Use Set for consistency\n                const employeesSet = new Set();\n                const employeesQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('role', '==', 'employee'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('teamName', '==', userProfile.teamName));\n                const employeesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(employeesQuery);\n                employeesSnapshot.forEach((doc)=>{\n                    const data = doc.data();\n                    const userData = {\n                        empId: data.empId,\n                        empName: data.empName,\n                        teamName: data.teamName\n                    };\n                    const key = \"\".concat(data.role, \"-\").concat(data.empId);\n                    if (!employeesSet.has(key)) {\n                        employeesSet.add(JSON.stringify(userData));\n                    }\n                });\n                options.employees = Array.from(employeesSet).map(JSON.parse);\n            } catch (error) {\n                console.error('Error fetching team-leader filter options:', error);\n                options.trackLeads = [];\n                options.employees = [];\n            }\n        } else if (userProfile.role === 'track-lead') {\n            // Track leads can filter by their direct reports (employees)\n            options.teams = [\n                userProfile.teamName\n            ];\n            try {\n                // Get employees who report to this track-lead - hierarchy-aware\n                const employeesSet = new Set();\n                const employeesQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('role', '==', 'employee'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('teamName', '==', userProfile.teamName), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('reportsTo', '==', userProfile.empId));\n                const employeesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(employeesQuery);\n                employeesSnapshot.forEach((doc)=>{\n                    const data = doc.data();\n                    const userData = {\n                        empId: data.empId,\n                        empName: data.empName,\n                        teamName: data.teamName\n                    };\n                    const key = \"\".concat(data.role, \"-\").concat(data.empId);\n                    if (!employeesSet.has(key)) {\n                        employeesSet.add(JSON.stringify(userData));\n                    }\n                });\n                options.employees = Array.from(employeesSet).map(JSON.parse);\n            } catch (error) {\n                console.error('Error fetching track-lead filter options:', error);\n                options.employees = [];\n            }\n        } else if (userProfile.role === 'employee') {\n            // Employees can only filter by themselves\n            options.teams = [\n                userProfile.teamName\n            ];\n            options.employees = [\n                {\n                    empId: userProfile.empId,\n                    empName: userProfile.empName,\n                    teamName: userProfile.teamName\n                }\n            ];\n        }\n        return options;\n    } catch (error) {\n        console.error('Error getting filter options:', error);\n        return {\n            techLeads: [],\n            teamLeaders: [],\n            trackLeads: [],\n            employees: [],\n            teams: []\n        };\n    }\n};\n// -------------------- Get Weekly Task For Current User Only!!! --------------------\nconst getWeeklyTasks = async (userProfile, startDate, endDate)=>{\n    try {\n        if (!userProfile) {\n            throw new Error('User profile is required');\n        }\n        let allTasks = [];\n        // Determine which teams user can access (same as getTasks)\n        let accessibleTeams;\n        switch(userProfile.role){\n            case 'tech-lead':\n                accessibleTeams = [\n                    ...userProfile.managedTeams || [],\n                    'techLeads'\n                ];\n                break;\n            case 'team-leader':\n            case 'employee':\n                accessibleTeams = [\n                    userProfile.teamName\n                ];\n                break;\n            default:\n                return [];\n        }\n        // For weekly report, we assume it's for the current user only (employee view)\n        // If tech-lead or team-leader, they can choose, but for simplicity, filter to own tasks\n        const targetEmpId = userProfile.empId; // Own tasks only for report\n        // Fetch tasks from accessible teams within date range\n        for (const teamName of accessibleTeams){\n            // Query dates between start and end\n            const datesQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('__name__', '>=', startDate), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('__name__', '<=', endDate));\n            const datesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(datesQuery);\n            for (const dateDoc of datesSnapshot.docs){\n                const date = dateDoc.id;\n                const employeesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', date, 'employees'));\n                for (const empDoc of employeesSnapshot.docs){\n                    const empId = empDoc.id;\n                    // Only fetch own tasks for report\n                    if (empId !== targetEmpId) {\n                        continue;\n                    }\n                    const tasksSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', date, 'employees', empId, 'tasks'));\n                    const empTasks = tasksSnapshot.docs.map((taskDoc)=>({\n                            teamName,\n                            date,\n                            empId,\n                            ...taskDoc.data(),\n                            id: taskDoc.id\n                        })).filter((task)=>{\n                        // Filter by time if start/end have time, but since dates are YYYY-MM-DD, it's fine\n                        return task.date >= startDate && task.date <= endDate;\n                    });\n                    allTasks = [\n                        ...allTasks,\n                        ...empTasks\n                    ];\n                }\n            }\n        }\n        return allTasks.sort((a, b)=>new Date(a.date) - new Date(b.date));\n    } catch (error) {\n        console.error('Error getting weekly tasks:', error);\n        throw error;\n    }\n};\nconst applyTaskFilters = (tasks, filters, userProfile)=>{\n    if (!tasks || tasks.length === 0) return tasks;\n    let filteredTasks = [\n        ...tasks\n    ];\n    // Status filter\n    if (filters.status) {\n        filteredTasks = filteredTasks.filter((task)=>task.status === filters.status);\n    }\n    // Work type filter\n    if (filters.workType) {\n        filteredTasks = filteredTasks.filter((task)=>task.workType === filters.workType);\n    }\n    // Progress filter\n    if (filters.percentageCompletion) {\n        const [min, max] = filters.percentageCompletion.split('-').map(Number);\n        filteredTasks = filteredTasks.filter((task)=>{\n            const progress = parseInt(task.percentageCompletion) || 0;\n            return progress >= min && progress <= max;\n        });\n    }\n    // Team filter (only for tech leads)\n    if (filters.team && userProfile.role === 'tech-lead') {\n        filteredTasks = filteredTasks.filter((task)=>task.teamName === filters.team);\n    }\n    return filteredTasks;\n};\n// Helper function to get team leader for a team\nconst getTeamLeaderForTeam = async (teamName)=>{\n    try {\n        const teamDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName));\n        if (teamDoc.exists() && teamDoc.data().teamLeaderId) {\n            return teamDoc.data().teamLeaderId;\n        }\n        return null;\n    } catch (error) {\n        console.error('Error getting team leader for team:', teamName, error);\n        return null;\n    }\n};\n// Get filtered tasks with all applied filters\nconst getFilteredTasks = async function(userProfile) {\n    let filters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    try {\n        // First get all accessible tasks\n        const allTasks = await getTasks(userProfile);\n        // Then apply filters\n        const filteredTasks = applyTaskFilters(allTasks, filters, userProfile);\n        return filteredTasks;\n    } catch (error) {\n        console.error('Error getting filtered tasks:', error);\n        throw error;\n    }\n};\n// -------------------- DROPDOWNS WITH USER CONTEXT --------------------\n// Get dropdown data for a team (with user permission check)\nconst getTeamDropdownData = async (teamName, field, userProfile)=>{\n    try {\n        // Check if user can access this team\n        if (!canUserAccessTeam(userProfile, teamName)) {\n            throw new Error('You do not have permission to access this team data');\n        }\n        // Return predefined values for specific fields - same for all users\n        if (PREDEFINED_VALUES[field]) {\n            return PREDEFINED_VALUES[field];\n        }\n        // For custom dropdown data, fetch from Firestore\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dropdownData', field);\n        const docSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(docRef);\n        if (docSnap.exists()) {\n            return docSnap.data().values || [];\n        }\n        return [];\n    } catch (error) {\n        console.error('Error getting team dropdown data:', error);\n        // Always return predefined values as fallback\n        return PREDEFINED_VALUES[field] || [];\n    }\n};\n// Save dropdown data for a team (with user permission check)\nconst saveTeamDropdownData = async (teamName, field, values, userProfile)=>{\n    try {\n        // Check if user can modify this team data (only team leaders and tech leads)\n        if (!canUserAccessTeam(userProfile, teamName) || userProfile.role === 'employee') {\n            throw new Error('You do not have permission to modify team data');\n        }\n        // Don't save predefined values to database\n        if (PREDEFINED_VALUES[field]) {\n            console.warn(\"Cannot save predefined values for field: \".concat(field));\n            return;\n        }\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dropdownData', field);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(docRef, {\n            values\n        }, {\n            merge: true\n        });\n    } catch (error) {\n        console.error('Error saving team dropdown data:', error);\n        throw error;\n    }\n};\n// -------------------- TEAMS WITH USER CONTEXT --------------------\n// Get teams accessible to user\nconst getTeams = async (userProfile)=>{\n    try {\n        if (!userProfile) return [];\n        return getAccessibleTeams(userProfile);\n    } catch (error) {\n        console.error('Error getting teams:', error);\n        return [];\n    }\n};\n// -------------------- PROJECTS WITH USER CONTEXT --------------------\n// Get team-specific projects (with user permission check)\nconst getTeamProjects = async (teamName, userProfile)=>{\n    try {\n        if (!canUserAccessTeam(userProfile, teamName)) {\n            return [];\n        }\n        return await getTeamDropdownData(teamName, 'projects', userProfile);\n    } catch (error) {\n        console.error('Error getting team projects:', error);\n        return [];\n    }\n};\n// Add new project to team (with user permission check)\nconst addTeamProject = async (teamName, projectId, projectName, userProfile)=>{\n    try {\n        if (!projectId || !projectName) return;\n        if (!canUserAccessTeam(userProfile, teamName) || userProfile.role === 'employee') {\n            return; // Silently fail for employees\n        }\n        const projects = await getTeamProjects(teamName, userProfile);\n        const exists = projects.find((p)=>p.id === projectId);\n        if (!exists) {\n            const newProjects = [\n                ...projects,\n                {\n                    id: projectId,\n                    name: projectName\n                }\n            ];\n            await saveTeamDropdownData(teamName, 'projects', newProjects, userProfile);\n        }\n    } catch (error) {\n        console.error('Error adding team project:', error);\n    // Don't throw error to prevent task creation failure\n    }\n};\n// -------------------- EMPLOYEES WITH USER CONTEXT --------------------\n// Get team-specific employees (with user permission check)\nconst getTeamEmployees = async (teamName, userProfile)=>{\n    try {\n        if (!canUserAccessTeam(userProfile, teamName)) {\n            return [];\n        }\n        return await getTeamDropdownData(teamName, 'employees', userProfile);\n    } catch (error) {\n        console.error('Error getting team employees:', error);\n        return [];\n    }\n};\n// Add new employee to team (with user permission check)\nconst addTeamEmployee = async (teamName, empId, empName, userProfile)=>{\n    try {\n        if (!empId || !empName) return;\n        if (!canUserAccessTeam(userProfile, teamName) || userProfile.role === 'employee') {\n            return; // Silently fail for employees\n        }\n        const employees = await getTeamEmployees(teamName, userProfile);\n        const exists = employees.find((e)=>e.id === empId);\n        if (!exists) {\n            const newEmployees = [\n                ...employees,\n                {\n                    id: empId,\n                    name: empName\n                }\n            ];\n            await saveTeamDropdownData(teamName, 'employees', newEmployees, userProfile);\n        }\n    } catch (error) {\n        console.error('Error adding team employee:', error);\n    // Don't throw error to prevent task creation failure\n    }\n};\n// -------------------- CLIENTS WITH USER CONTEXT --------------------\n// Get team-specific clients (with user permission check)\nconst getTeamClients = async (teamName, userProfile)=>{\n    try {\n        if (!canUserAccessTeam(userProfile, teamName)) {\n            return [];\n        }\n        return await getTeamDropdownData(teamName, 'clients', userProfile);\n    } catch (error) {\n        console.error('Error getting team clients:', error);\n        return [];\n    }\n};\n// Add new client to team (with user permission check)\nconst addTeamClient = async (teamName, clientId, clientName, userProfile)=>{\n    try {\n        if (!clientId || !clientName) return;\n        if (!canUserAccessTeam(userProfile, teamName) || userProfile.role === 'employee') {\n            return; // Silently fail for employees\n        }\n        const clients = await getTeamClients(teamName, userProfile);\n        const exists = clients.find((c)=>c.id === clientId);\n        if (!exists) {\n            const newClients = [\n                ...clients,\n                {\n                    id: clientId,\n                    name: clientName\n                }\n            ];\n            await saveTeamDropdownData(teamName, 'clients', newClients, userProfile);\n        }\n    } catch (error) {\n        console.error('Error adding team client:', error);\n    // Don't throw error to prevent task creation failure\n    }\n};\n// -------------------- UTILITY FUNCTIONS --------------------\n// Get predefined values for a specific field\nconst getPredefinedValues = (field)=>{\n    return PREDEFINED_VALUES[field] || [];\n};\n// Check if field has predefined values\nconst isPredefinedField = (field)=>{\n    return !!PREDEFINED_VALUES[field];\n};\n// Check if team document exists\nconst teamExists = async (teamName)=>{\n    try {\n        const teamDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName));\n        return teamDoc.exists();\n    } catch (error) {\n        return false;\n    }\n};\n// Initialize default dropdown values for a team (only if team doesn't exist yet)\nconst initializeTeamDefaults = async (teamName)=>{\n    try {\n        const exists = await teamExists(teamName);\n        if (!exists) {\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName), {\n                createdAt: new Date().toISOString()\n            });\n        }\n    } catch (error) {\n        console.error('Error initializing team defaults:', error);\n        throw error;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFHO1FBQ25GO0lBQ0osRUFBRSxPQUFPbEIsT0FBTztRQUNaQyxRQUFRRCxLQUFLLENBQUMscUNBQXFDQTtRQUNuRCxNQUFNQTtJQUNWO0FBQ0osRUFBRSIsInNvdXJjZXMiOlsiQzpcXHNhdXJhYmhcXFByb2plY3RzXFxBZHZhbmNlZF9HZW5BSVxcVGFza0hpdmVcXGxpYlxcZmlyZWJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbGliL2ZpcmViYXNlLmpzIC0gVXBkYXRlZCB3aXRoIHVzZXIgY29udGV4dCBmaWx0ZXJpbmdcclxuaW1wb3J0IHsgZGIgfSBmcm9tICcuL2ZpcmViYXNlQ29uZmlnJztcclxuaW1wb3J0IHtcclxuICAgIGNvbGxlY3Rpb24sIGFkZERvYywgZ2V0RG9jcywgZG9jLCB1cGRhdGVEb2MsIGRlbGV0ZURvYywgZ2V0RG9jLCBzZXREb2MsIHF1ZXJ5LCB3aGVyZVxyXG59IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSBQUkVERUZJTkVEIFZBTFVFUyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5jb25zdCBQUkVERUZJTkVEX1ZBTFVFUyA9IHtcclxuICAgIHBlcmNlbnRhZ2VDb21wbGV0aW9uOiBbJzUnLCAnMTAnLCAnMjUnLCAnNDAnLCAnNTAnLCAnNjUnLCAnNzUnLCAnODUnLCAnOTAnLCAnMTAwJ10sXHJcbiAgICBzdGF0dXM6IFsnQ29tcGxldGVkJywgJ0luIFByb2dyZXNzJywgJ09uIEhvbGQnXSxcclxuICAgIHdvcmtUeXBlOiBbJ0Z1bGwtZGF5JywgJ0hhbGYtZGF5JywgJ1JlbGF4YXRpb24nXVxyXG59O1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0gVVNFUiBNQU5BR0VNRU5UIC0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vLyBHZXQgdXNlciBwcm9maWxlXHJcbmV4cG9ydCBjb25zdCBnZXRVc2VyUHJvZmlsZSA9IGFzeW5jICh1c2VySWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgdXNlckRvYyA9IGF3YWl0IGdldERvYyhkb2MoZGIsICd1c2VycycsIHVzZXJJZCkpO1xyXG4gICAgICAgIGlmICh1c2VyRG9jLmV4aXN0cygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VyRG9jLmRhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdXNlciBwcm9maWxlOicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIFVwZGF0ZSB1c2VyIHByb2ZpbGVcclxuZXhwb3J0IGNvbnN0IHVwZGF0ZVVzZXJQcm9maWxlID0gYXN5bmMgKHVzZXJJZCwgcHJvZmlsZURhdGEpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgc2V0RG9jKGRvYyhkYiwgJ3VzZXJzJywgdXNlcklkKSwgcHJvZmlsZURhdGEsIHsgbWVyZ2U6IHRydWUgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHVzZXIgcHJvZmlsZTonLCBlcnJvcik7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSBUQVNLUyBXSVRIIFVTRVIgQ09OVEVYVCAtLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLy8gbGliL2ZpcmViYXNlLmpzIC0gS2VlcCBhZGRUYXNrIGZvciBuZXcgdGFza3Mgb25seVxyXG5leHBvcnQgY29uc3QgYWRkVGFzayA9IGFzeW5jICh0YXNrLCB1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAodXNlclByb2ZpbGUucm9sZSA9PT0gJ3RlY2gtbGVhZCcpIHtcclxuICAgICAgICAgICAgdGFzay50ZWFtTmFtZSA9ICd0ZWNoTGVhZHMnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVmFsaWRhdGUgdXNlciBjYW4gYWRkIHRhc2sgdG8gdGhpcyB0ZWFtL2VtcGxveWVlXHJcbiAgICAgICAgaWYgKCFjYW5Vc2VyQWNjZXNzRW1wbG95ZWUodXNlclByb2ZpbGUsIHRhc2sudGVhbU5hbWUsIHRhc2suZW1wSWQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGRvIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gYWRkIHRhc2tzIGZvciB0aGlzIGVtcGxveWVlJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIGRlZmF1bHQgdGVhbSBuYW1lLi4uXHJcbiAgICAgICAgYXdhaXQgaW5pdGlhbGl6ZVRlYW1EZWZhdWx0cyh0YXNrLnRlYW1OYW1lKTtcclxuXHJcbiAgICAgICAgLy8gRW5zdXJlIGRhdGUgZG9jdW1lbnQgZXhpc3RzXHJcbiAgICAgICAgY29uc3QgZGF0ZVJlZiA9IGRvYyhkYiwgJ3RlYW1zJywgdGFzay50ZWFtTmFtZSwgJ2RhdGVzJywgdGFzay5kYXRlKTtcclxuICAgICAgICBhd2FpdCBzZXREb2MoZGF0ZVJlZiwgeyBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9LCB7IG1lcmdlOiB0cnVlIH0pO1xyXG5cclxuICAgICAgICAvLyBFbnN1cmUgZW1wbG95ZWUgZG9jdW1lbnQgZXhpc3RzIHdpdGggbmFtZVxyXG4gICAgICAgIGNvbnN0IGVtcFJlZiA9IGRvYyhkYiwgJ3RlYW1zJywgdGFzay50ZWFtTmFtZSwgJ2RhdGVzJywgdGFzay5kYXRlLCAnZW1wbG95ZWVzJywgdGFzay5lbXBJZCk7XHJcbiAgICAgICAgYXdhaXQgc2V0RG9jKGVtcFJlZiwgeyBuYW1lOiB0YXNrLmVtcE5hbWUgfSwgeyBtZXJnZTogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgLy8gQXV0by1zYXZlIG5ldyBlbXBsb3llZSB0byB0ZWFtIGVtcGxveWVlcyBpZiBub3QgZXhpc3RzXHJcbiAgICAgICAgaWYgKHRhc2suZW1wSWQgJiYgdGFzay5lbXBOYW1lKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGFkZFRlYW1FbXBsb3llZSh0YXNrLnRlYW1OYW1lLCB0YXNrLmVtcElkLCB0YXNrLmVtcE5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXV0by1zYXZlIG5ldyBjbGllbnQgdG8gdGVhbSBjbGllbnRzIGlmIG5vdCBleGlzdHNcclxuICAgICAgICBpZiAodGFzay5jbGllbnRJZCAmJiB0YXNrLmNsaWVudE5hbWUpIHtcclxuICAgICAgICAgICAgYXdhaXQgYWRkVGVhbUNsaWVudCh0YXNrLnRlYW1OYW1lLCB0YXNrLmNsaWVudElkLCB0YXNrLmNsaWVudE5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXV0by1zYXZlIG5ldyBwcm9qZWN0IHRvIHRlYW0gcHJvamVjdHMgaWYgbm90IGV4aXN0c1xyXG4gICAgICAgIGlmICh0YXNrLnByb2plY3RJZCAmJiB0YXNrLnByb2plY3ROYW1lKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGFkZFRlYW1Qcm9qZWN0KHRhc2sudGVhbU5hbWUsIHRhc2sucHJvamVjdElkLCB0YXNrLnByb2plY3ROYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRhc2tEYXRhID0ge1xyXG4gICAgICAgICAgICAuLi50YXNrLFxyXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgICAgY3JlYXRlZEJ5OiB1c2VyUHJvZmlsZS5lbXBJZFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IGRvY1JlZiA9IGF3YWl0IGFkZERvYyhcclxuICAgICAgICAgICAgY29sbGVjdGlvbihkYiwgJ3RlYW1zJywgdGFzay50ZWFtTmFtZSwgJ2RhdGVzJywgdGFzay5kYXRlLCAnZW1wbG95ZWVzJywgdGFzay5lbXBJZCwgJ3Rhc2tzJyksXHJcbiAgICAgICAgICAgIHRhc2tEYXRhXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIGZ1bGwgdGFzayBvYmplY3Qgd2l0aCBJRCBmb3IgY29uc2lzdGVuY3lcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi50YXNrLFxyXG4gICAgICAgICAgICBpZDogZG9jUmVmLmlkLFxyXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgICAgY3JlYXRlZEJ5OiB1c2VyUHJvZmlsZS5lbXBJZFxyXG4gICAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyB0YXNrOicsIGVycm9yKTtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgdXBkYXRlVGFzayBmdW5jdGlvbiB0byBoYW5kbGUgYXV0by1zYXZlIGxvZ2ljXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVUYXNrID0gYXN5bmMgKHRlYW1OYW1lLCBkYXRlLCBlbXBJZCwgdGFza0lkLCB0YXNrRGF0YSwgdXNlclByb2ZpbGUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdXNlciBjYW4gdXBkYXRlIHRoaXMgdGFza1xyXG4gICAgICAgIGlmICghY2FuVXNlckFjY2Vzc0VtcGxveWVlKHVzZXJQcm9maWxlLCB0ZWFtTmFtZSwgZW1wSWQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGRvIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gdXBkYXRlIHRoaXMgdGFzaycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXV0by1zYXZlIG5ldyBlbXBsb3llZSB0byB0ZWFtIGVtcGxveWVlcyBpZiBub3QgZXhpc3RzXHJcbiAgICAgICAgaWYgKHRhc2tEYXRhLmVtcElkICYmIHRhc2tEYXRhLmVtcE5hbWUpIHtcclxuICAgICAgICAgICAgYXdhaXQgYWRkVGVhbUVtcGxveWVlKHRlYW1OYW1lLCB0YXNrRGF0YS5lbXBJZCwgdGFza0RhdGEuZW1wTmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBdXRvLXNhdmUgbmV3IGNsaWVudCB0byB0ZWFtIGNsaWVudHMgaWYgbm90IGV4aXN0c1xyXG4gICAgICAgIGlmICh0YXNrRGF0YS5jbGllbnRJZCAmJiB0YXNrRGF0YS5jbGllbnROYW1lKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGFkZFRlYW1DbGllbnQodGVhbU5hbWUsIHRhc2tEYXRhLmNsaWVudElkLCB0YXNrRGF0YS5jbGllbnROYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEF1dG8tc2F2ZSBuZXcgcHJvamVjdCB0byB0ZWFtIHByb2plY3RzIGlmIG5vdCBleGlzdHNcclxuICAgICAgICBpZiAodGFza0RhdGEucHJvamVjdElkICYmIHRhc2tEYXRhLnByb2plY3ROYW1lKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGFkZFRlYW1Qcm9qZWN0KHRlYW1OYW1lLCB0YXNrRGF0YS5wcm9qZWN0SWQsIHRhc2tEYXRhLnByb2plY3ROYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRhc2tSZWYgPSBkb2MoZGIsICd0ZWFtcycsIHRlYW1OYW1lLCAnZGF0ZXMnLCBkYXRlLCAnZW1wbG95ZWVzJywgZW1wSWQsICd0YXNrcycsIHRhc2tJZCk7XHJcbiAgICAgICAgYXdhaXQgdXBkYXRlRG9jKHRhc2tSZWYsIHtcclxuICAgICAgICAgICAgLi4udGFza0RhdGEsXHJcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgICB1cGRhdGVkQnk6IHVzZXJQcm9maWxlLmVtcElkXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiB0aGUgdXBkYXRlZCB0YXNrIGRhdGEgZm9yIGNvbnNpc3RlbmN5XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4udGFza0RhdGEsXHJcbiAgICAgICAgICAgIGlkOiB0YXNrSWQsXHJcbiAgICAgICAgICAgIHRlYW1OYW1lLFxyXG4gICAgICAgICAgICBkYXRlLFxyXG4gICAgICAgICAgICBlbXBJZCxcclxuICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICAgIHVwZGF0ZWRCeTogdXNlclByb2ZpbGUuZW1wSWRcclxuICAgICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyB0YXNrOicsIGVycm9yKTtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRUYXNrcyA9IGFzeW5jICh1c2VyUHJvZmlsZSwgdGVhbUZpbHRlciA9IG51bGwpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCF1c2VyUHJvZmlsZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgcHJvZmlsZSBpcyByZXF1aXJlZCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGFsbFRhc2tzID0gW107XHJcbiAgICAgICAgY29uc3QgdG9kYXkgPSBmb3JtYXQobmV3IERhdGUoKSwgJ3l5eXktTU0tZGQnKTtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHRlYW1zIHVzZXIgY2FuIGFjY2Vzc1xyXG4gICAgICAgIGxldCBhY2Nlc3NpYmxlVGVhbXM7XHJcbiAgICAgICAgc3dpdGNoICh1c2VyUHJvZmlsZS5yb2xlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RlY2gtbGVhZCc6XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NpYmxlVGVhbXMgPSBbLi4uKHVzZXJQcm9maWxlLm1hbmFnZWRUZWFtcyB8fCBbXSksICd0ZWNoTGVhZHMnXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd0ZWFtLWxlYWRlcic6XHJcbiAgICAgICAgICAgIGNhc2UgJ3RyYWNrLWxlYWQnOlxyXG4gICAgICAgICAgICBjYXNlICdlbXBsb3llZSc6XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NpYmxlVGVhbXMgPSBbdXNlclByb2ZpbGUudGVhbU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcHBseSB0ZWFtIGZpbHRlciBpZiBwcm92aWRlZFxyXG4gICAgICAgIGlmICh0ZWFtRmlsdGVyICYmIHRlYW1GaWx0ZXIgIT09ICdhbGwnKSB7XHJcbiAgICAgICAgICAgIGFjY2Vzc2libGVUZWFtcyA9IGFjY2Vzc2libGVUZWFtcy5maWx0ZXIodGVhbSA9PiB0ZWFtID09PSB0ZWFtRmlsdGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyB0b2RheSdzIHRhc2tzIGZvciAke3VzZXJQcm9maWxlLnJvbGV9ICgke3VzZXJQcm9maWxlLmVtcElkfSkgZnJvbSB0ZWFtczpgLCBhY2Nlc3NpYmxlVGVhbXMpO1xyXG5cclxuICAgICAgICAvLyBGZXRjaCB0YXNrcyBmcm9tIGFjY2Vzc2libGUgdGVhbXMgZm9yIFRPREFZIG9ubHlcclxuICAgICAgICBmb3IgKGNvbnN0IHRlYW1OYW1lIG9mIGFjY2Vzc2libGVUZWFtcykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW1wbG95ZWVzU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24oZGIsICd0ZWFtcycsIHRlYW1OYW1lLCAnZGF0ZXMnLCB0b2RheSwgJ2VtcGxveWVlcycpXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW1wRG9jIG9mIGVtcGxveWVlc1NuYXBzaG90LmRvY3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbXBJZCA9IGVtcERvYy5pZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWNjZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FuQWNjZXNzID0gYXdhaXQgY2FuVXNlckFjY2Vzc0VtcGxveWVlKHVzZXJQcm9maWxlLCB0ZWFtTmFtZSwgZW1wSWQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbkFjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQWNjZXNzIGRlbmllZCBmb3IgJHt1c2VyUHJvZmlsZS5yb2xlfSAoJHt1c2VyUHJvZmlsZS5lbXBJZH0pIHRvIGVtcGxveWVlICR7ZW1wSWR9IGluIHRlYW0gJHt0ZWFtTmFtZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQWNjZXNzIGdyYW50ZWQgZm9yICR7dXNlclByb2ZpbGUucm9sZX0gKCR7dXNlclByb2ZpbGUuZW1wSWR9KSB0byBlbXBsb3llZSAke2VtcElkfSBpbiB0ZWFtICR7dGVhbU5hbWV9YCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhc2tzU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uKGRiLCAndGVhbXMnLCB0ZWFtTmFtZSwgJ2RhdGVzJywgdG9kYXksICdlbXBsb3llZXMnLCBlbXBJZCwgJ3Rhc2tzJylcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbXBUYXNrcyA9IHRhc2tzU25hcHNob3QuZG9jcy5tYXAodGFza0RvYyA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZWFtTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogdG9kYXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50YXNrRG9jLmRhdGEoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRhc2tEb2MuaWRcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFsbFRhc2tzID0gWy4uLmFsbFRhc2tzLCAuLi5lbXBUYXNrc107XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7ZW1wVGFza3MubGVuZ3RofSB0YXNrcyBmb3IgZW1wbG95ZWUgJHtlbXBJZH0gb24gJHt0b2RheX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCAodGVhbUVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyB0YXNrcyBmb3IgdGVhbSAke3RlYW1OYW1lfTpgLCB0ZWFtRXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhgVG90YWwgdG9kYXkncyB0YXNrcyBmZXRjaGVkIGZvciAke3VzZXJQcm9maWxlLnJvbGV9OiAke2FsbFRhc2tzLmxlbmd0aH1gKTtcclxuICAgICAgICByZXR1cm4gYWxsVGFza3Muc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYi5kYXRlKSAtIG5ldyBEYXRlKGEuZGF0ZSkpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHRhc2tzOicsIGVycm9yKTtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIC8vIFVwZGF0ZSBhIHRhc2sgKHdpdGggdXNlciBwZXJtaXNzaW9uIGNoZWNrKVxyXG4vLyBleHBvcnQgY29uc3QgdXBkYXRlVGFzayA9IGFzeW5jICh0ZWFtTmFtZSwgZGF0ZSwgZW1wSWQsIHRhc2tJZCwgdGFza0RhdGEsIHVzZXJQcm9maWxlKSA9PiB7XHJcbi8vICAgICB0cnkge1xyXG4vLyAgICAgICAgIC8vIENoZWNrIGlmIHVzZXIgY2FuIHVwZGF0ZSB0aGlzIHRhc2tcclxuLy8gICAgICAgICBpZiAoIWNhblVzZXJBY2Nlc3NFbXBsb3llZSh1c2VyUHJvZmlsZSwgdGVhbU5hbWUsIGVtcElkKSkge1xyXG4vLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIHVwZGF0ZSB0aGlzIHRhc2snKTtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIGNvbnN0IHRhc2tSZWYgPSBkb2MoZGIsICd0ZWFtcycsIHRlYW1OYW1lLCAnZGF0ZXMnLCBkYXRlLCAnZW1wbG95ZWVzJywgZW1wSWQsICd0YXNrcycsIHRhc2tJZCk7XHJcbi8vICAgICAgICAgYXdhaXQgdXBkYXRlRG9jKHRhc2tSZWYsIHtcclxuLy8gICAgICAgICAgICAgLi4udGFza0RhdGEsXHJcbi8vICAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4vLyAgICAgICAgICAgICB1cGRhdGVkQnk6IHVzZXJQcm9maWxlLmVtcElkXHJcbi8vICAgICAgICAgfSk7XHJcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHRhc2s6JywgZXJyb3IpO1xyXG4vLyAgICAgICAgIHRocm93IGVycm9yO1xyXG4vLyAgICAgfVxyXG4vLyB9O1xyXG5cclxuLy8gRGVsZXRlIGEgdGFzayAod2l0aCB1c2VyIHBlcm1pc3Npb24gY2hlY2spXHJcbmV4cG9ydCBjb25zdCBkZWxldGVUYXNrID0gYXN5bmMgKHRlYW1OYW1lLCBkYXRlLCBlbXBJZCwgdGFza0lkLCB1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBDaGVjayBpZiB1c2VyIGNhbiBkZWxldGUgdGhpcyB0YXNrXHJcbiAgICAgICAgaWYgKCFjYW5Vc2VyQWNjZXNzRW1wbG95ZWUodXNlclByb2ZpbGUsIHRlYW1OYW1lLCBlbXBJZCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBkZWxldGUgdGhpcyB0YXNrJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0YXNrUmVmID0gZG9jKGRiLCAndGVhbXMnLCB0ZWFtTmFtZSwgJ2RhdGVzJywgZGF0ZSwgJ2VtcGxveWVlcycsIGVtcElkLCAndGFza3MnLCB0YXNrSWQpO1xyXG4gICAgICAgIGF3YWl0IGRlbGV0ZURvYyh0YXNrUmVmKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgdGFzazonLCBlcnJvcik7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSBQRVJNSVNTSU9OIEhFTFBFUlMgLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8vIENoZWNrIGlmIHVzZXIgY2FuIGFjY2VzcyBzcGVjaWZpYyB0ZWFtXHJcbmV4cG9ydCBjb25zdCBjYW5Vc2VyQWNjZXNzVGVhbSA9ICh1c2VyUHJvZmlsZSwgdGVhbU5hbWUpID0+IHtcclxuICAgIGlmICghdXNlclByb2ZpbGUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnTm8gdXNlciBwcm9maWxlIHByb3ZpZGVkJyk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGBDaGVja2luZyBhY2Nlc3MgZm9yIHVzZXIgJHt1c2VyUHJvZmlsZS5lbXBJZH0gKCR7dXNlclByb2ZpbGUucm9sZX0pIHRvIHRlYW0gJHt0ZWFtTmFtZX1gKTtcclxuXHJcbiAgICBzd2l0Y2ggKHVzZXJQcm9maWxlLnJvbGUpIHtcclxuICAgICAgICBjYXNlICd0ZWNoLWxlYWQnOlxyXG4gICAgICAgICAgICAvLyBUZWNoIGxlYWRzIGNhbiBhY2Nlc3M6XHJcbiAgICAgICAgICAgIC8vIDEuIFRlYW1zIHRoZXkgbWFuYWdlIChmcm9tIG1hbmFnZWRUZWFtcyBhcnJheSlcclxuICAgICAgICAgICAgLy8gMi4gVGhlIHNwZWNpYWwgJ3RlY2hMZWFkcycgdGVhbSBmb3IgdGhlaXIgcGVyc29uYWwgdGFza3NcclxuICAgICAgICAgICAgY29uc3QgY2FuQWNjZXNzTWFuYWdlZFRlYW0gPSB1c2VyUHJvZmlsZS5tYW5hZ2VkVGVhbXM/LmluY2x1ZGVzKHRlYW1OYW1lKTtcclxuICAgICAgICAgICAgY29uc3QgY2FuQWNjZXNzVGVjaExlYWRzVGVhbSA9IHRlYW1OYW1lID09PSAndGVjaExlYWRzJztcclxuICAgICAgICAgICAgY29uc3QgdGVjaExlYWRBY2Nlc3MgPSBjYW5BY2Nlc3NNYW5hZ2VkVGVhbSB8fCBjYW5BY2Nlc3NUZWNoTGVhZHNUZWFtO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1RlY2ggbGVhZCBhY2Nlc3MgY2hlY2s6Jywge1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlZFRlYW1zOiB1c2VyUHJvZmlsZS5tYW5hZ2VkVGVhbXMsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZWRUZWFtOiB0ZWFtTmFtZSxcclxuICAgICAgICAgICAgICAgIGNhbkFjY2Vzc01hbmFnZWRUZWFtLFxyXG4gICAgICAgICAgICAgICAgY2FuQWNjZXNzVGVjaExlYWRzVGVhbSxcclxuICAgICAgICAgICAgICAgIGZpbmFsQWNjZXNzOiB0ZWNoTGVhZEFjY2Vzc1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0ZWNoTGVhZEFjY2VzcztcclxuXHJcbiAgICAgICAgY2FzZSAndGVhbS1sZWFkZXInOlxyXG4gICAgICAgIGNhc2UgJ3RyYWNrLWxlYWQnOiAvLyDihpAgVHJhY2stTGVhZCBjYW4gYWNjZXNzIHRoZWlyIG93biB0ZWFtXHJcbiAgICAgICAgY2FzZSAnZW1wbG95ZWUnOlxyXG4gICAgICAgICAgICBjb25zdCByZWd1bGFyQWNjZXNzID0gdXNlclByb2ZpbGUudGVhbU5hbWUgPT09IHRlYW1OYW1lO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUmVndWxhciB1c2VyIGFjY2VzczonLCB7XHJcbiAgICAgICAgICAgICAgICB1c2VyVGVhbTogdXNlclByb2ZpbGUudGVhbU5hbWUsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZWRUZWFtOiB0ZWFtTmFtZSxcclxuICAgICAgICAgICAgICAgIGFjY2VzczogcmVndWxhckFjY2Vzc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZ3VsYXJBY2Nlc3M7XHJcblxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVbmtub3duIHJvbGU6JywgdXNlclByb2ZpbGUucm9sZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufTtcclxuZXhwb3J0IGNvbnN0IGNhblVzZXJBY2Nlc3NFbXBsb3llZSA9IGFzeW5jICh1c2VyUHJvZmlsZSwgdGVhbU5hbWUsIHRhcmdldEVtcElkKSA9PiB7XHJcbiAgICBpZiAoIXVzZXJQcm9maWxlKSByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAodXNlclByb2ZpbGUudGVhbU5hbWUgIT09IHRlYW1OYW1lICYmIHVzZXJQcm9maWxlLnJvbGUgIT09ICd0ZWNoLWxlYWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHN3aXRjaCAodXNlclByb2ZpbGUucm9sZSkge1xyXG4gICAgICAgIGNhc2UgJ3RlY2gtbGVhZCc6XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VyUHJvZmlsZS5tYW5hZ2VkVGVhbXM/LmluY2x1ZGVzKHRlYW1OYW1lKTtcclxuICAgICAgICBjYXNlICd0ZWFtLWxlYWRlcic6XHJcbiAgICAgICAgICAgIGlmICh1c2VyUHJvZmlsZS50ZWFtTmFtZSAhPT0gdGVhbU5hbWUpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIGNhc2UgJ3RyYWNrLWxlYWQnOlxyXG4gICAgICAgICAgICBpZiAodXNlclByb2ZpbGUudGVhbU5hbWUgIT09IHRlYW1OYW1lKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB1c2Vyc1F1ZXJ5ID0gcXVlcnkoXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbihkYiwgJ3VzZXJzJyksXHJcbiAgICAgICAgICAgICAgICAgICAgd2hlcmUoJ2VtcElkJywgJz09JywgdGFyZ2V0RW1wSWQpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHVzZXJzUXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNuYXBzaG90LmVtcHR5KSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRVc2VyID0gc25hcHNob3QuZG9jc1swXS5kYXRhKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5BY2Nlc3MgPSB0YXJnZXRVc2VyLmVtcElkID09PSB1c2VyUHJvZmlsZS5lbXBJZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICh0YXJnZXRVc2VyLnJvbGUgPT09ICdlbXBsb3llZScgJiYgdGFyZ2V0VXNlci5yZXBvcnRzVG8gPT09IHVzZXJQcm9maWxlLmVtcElkKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuQWNjZXNzO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgZW1wbG95ZWUgYWNjZXNzOicsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICBjYXNlICdlbXBsb3llZSc6XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VyUHJvZmlsZS50ZWFtTmFtZSA9PT0gdGVhbU5hbWUgJiYgdXNlclByb2ZpbGUuZW1wSWQgPT09IHRhcmdldEVtcElkO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vLyBHZXQgYWNjZXNzaWJsZSB0ZWFtcyBmb3IgY3VycmVudCB1c2VyXHJcbmV4cG9ydCBjb25zdCBnZXRBY2Nlc3NpYmxlVGVhbXMgPSAodXNlclByb2ZpbGUpID0+IHtcclxuICAgIGlmICghdXNlclByb2ZpbGUpIHJldHVybiBbXTtcclxuXHJcbiAgICBzd2l0Y2ggKHVzZXJQcm9maWxlLnJvbGUpIHtcclxuICAgICAgICBjYXNlICd0ZWNoLWxlYWQnOlxyXG4gICAgICAgICAgICByZXR1cm4gdXNlclByb2ZpbGUubWFuYWdlZFRlYW1zIHx8IFtdO1xyXG4gICAgICAgIGNhc2UgJ3RlYW0tbGVhZGVyJzpcclxuICAgICAgICBjYXNlICd0cmFjay1sZWFkJzpcclxuICAgICAgICBjYXNlICdlbXBsb3llZSc6XHJcbiAgICAgICAgICAgIHJldHVybiBbdXNlclByb2ZpbGUudGVhbU5hbWVdO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0gRklMVEVSIEJBU0VEIE9OIFJPTEVTIC0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IGdldEZpbHRlck9wdGlvbnMgPSBhc3luYyAodXNlclByb2ZpbGUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgdGVjaExlYWRzOiBbXSxcclxuICAgICAgICAgICAgdGVhbUxlYWRlcnM6IFtdLFxyXG4gICAgICAgICAgICB0cmFja0xlYWRzOiBbXSxcclxuICAgICAgICAgICAgZW1wbG95ZWVzOiBbXSxcclxuICAgICAgICAgICAgdGVhbXM6IFtdXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKCF1c2VyUHJvZmlsZSkgcmV0dXJuIG9wdGlvbnM7XHJcblxyXG4gICAgICAgIGlmICh1c2VyUHJvZmlsZS5yb2xlID09PSAndGVjaC1sZWFkJykge1xyXG4gICAgICAgICAgICAvLyBUZWNoIGxlYWRzIGNhbiBmaWx0ZXIgYnkgZXZlcnl0aGluZyBpbiB0aGVpciBtYW5hZ2VkIHRlYW1zXHJcbiAgICAgICAgICAgIG9wdGlvbnMudGVhbXMgPSB1c2VyUHJvZmlsZS5tYW5hZ2VkVGVhbXMgfHwgW107XHJcblxyXG4gICAgICAgICAgICAvLyBVc2UgU2V0IGZvciBkZWR1cGxpY2F0aW9uIGxpa2Ugb2xkIGxvZ2ljXHJcbiAgICAgICAgICAgIGNvbnN0IHRlY2hMZWFkc1NldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgY29uc3QgdGVhbUxlYWRlcnNTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrTGVhZHNTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVtcGxveWVlc1NldCA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGVhbU5hbWUgb2YgdXNlclByb2ZpbGUubWFuYWdlZFRlYW1zKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBhbGwgdXNlcnMgaW4gdGhpcyB0ZWFtIChtb3JlIGVmZmljaWVudCB0aGFuIHNlcGFyYXRlIHF1ZXJpZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlcnNRdWVyeSA9IHF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uKGRiLCAndXNlcnMnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmUoJ3RlYW1OYW1lJywgJz09JywgdGVhbU5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2Vyc1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyh1c2Vyc1F1ZXJ5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdXNlcnNTbmFwc2hvdC5mb3JFYWNoKGRvYyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBkb2MuZGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtcElkOiBkYXRhLmVtcElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1wTmFtZTogZGF0YS5lbXBOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVhbU5hbWU6IGRhdGEudGVhbU5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB1bmlxdWUga2V5IGZvciBkZWR1cGxpY2F0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke2RhdGEucm9sZX0tJHtkYXRhLmVtcElkfWA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGRhdGEucm9sZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndGVjaC1sZWFkJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRlY2hMZWFkc1NldC5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZWNoTGVhZHNTZXQuYWRkKEpTT04uc3RyaW5naWZ5KHVzZXJEYXRhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndGVhbS1sZWFkZXInOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVhbUxlYWRlcnNTZXQuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVhbUxlYWRlcnNTZXQuYWRkKEpTT04uc3RyaW5naWZ5KHVzZXJEYXRhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndHJhY2stbGVhZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFja0xlYWRzU2V0LmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrTGVhZHNTZXQuYWRkKEpTT04uc3RyaW5naWZ5KHVzZXJEYXRhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW1wbG95ZWUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZW1wbG95ZWVzU2V0LmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtcGxveWVlc1NldC5hZGQoSlNPTi5zdHJpbmdpZnkodXNlckRhdGEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgZGF0YSBmb3IgdGVhbSAke3RlYW1OYW1lfTpgLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgc2V0cyBiYWNrIHRvIGFycmF5cyB3aXRoIGNvbnNpc3RlbnQgc3RydWN0dXJlXHJcbiAgICAgICAgICAgIG9wdGlvbnMudGVjaExlYWRzID0gQXJyYXkuZnJvbSh0ZWNoTGVhZHNTZXQpLm1hcChKU09OLnBhcnNlKTtcclxuICAgICAgICAgICAgb3B0aW9ucy50ZWFtTGVhZGVycyA9IEFycmF5LmZyb20odGVhbUxlYWRlcnNTZXQpLm1hcChKU09OLnBhcnNlKTtcclxuICAgICAgICAgICAgb3B0aW9ucy50cmFja0xlYWRzID0gQXJyYXkuZnJvbSh0cmFja0xlYWRzU2V0KS5tYXAoSlNPTi5wYXJzZSk7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZW1wbG95ZWVzID0gQXJyYXkuZnJvbShlbXBsb3llZXNTZXQpLm1hcChKU09OLnBhcnNlKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICh1c2VyUHJvZmlsZS5yb2xlID09PSAndGVhbS1sZWFkZXInKSB7XHJcbiAgICAgICAgICAgIC8vIFRlYW0gbGVhZGVycyBjYW4gZmlsdGVyIGJ5IHRyYWNrLWxlYWRzIGFuZCBlbXBsb3llZXMgaW4gdGhlaXIgdGVhbVxyXG4gICAgICAgICAgICBvcHRpb25zLnRlYW1zID0gW3VzZXJQcm9maWxlLnRlYW1OYW1lXTtcclxuXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgdHJhY2stbGVhZHMgLSBVc2UgU2V0IGZvciBjb25zaXN0ZW5jeVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tMZWFkc1NldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrTGVhZHNRdWVyeSA9IHF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24oZGIsICd1c2VycycpLFxyXG4gICAgICAgICAgICAgICAgICAgIHdoZXJlKCdyb2xlJywgJz09JywgJ3RyYWNrLWxlYWQnKSxcclxuICAgICAgICAgICAgICAgICAgICB3aGVyZSgndGVhbU5hbWUnLCAnPT0nLCB1c2VyUHJvZmlsZS50ZWFtTmFtZSlcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja0xlYWRzU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHRyYWNrTGVhZHNRdWVyeSk7XHJcbiAgICAgICAgICAgICAgICB0cmFja0xlYWRzU25hcHNob3QuZm9yRWFjaChkb2MgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBkb2MuZGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbXBJZDogZGF0YS5lbXBJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1wTmFtZTogZGF0YS5lbXBOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZWFtTmFtZTogZGF0YS50ZWFtTmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7ZGF0YS5yb2xlfS0ke2RhdGEuZW1wSWR9YDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYWNrTGVhZHNTZXQuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tMZWFkc1NldC5hZGQoSlNPTi5zdHJpbmdpZnkodXNlckRhdGEpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMudHJhY2tMZWFkcyA9IEFycmF5LmZyb20odHJhY2tMZWFkc1NldCkubWFwKEpTT04ucGFyc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdldCBlbXBsb3llZXMgLSBVc2UgU2V0IGZvciBjb25zaXN0ZW5jeVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZW1wbG95ZWVzU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW1wbG95ZWVzUXVlcnkgPSBxdWVyeShcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uKGRiLCAndXNlcnMnKSxcclxuICAgICAgICAgICAgICAgICAgICB3aGVyZSgncm9sZScsICc9PScsICdlbXBsb3llZScpLFxyXG4gICAgICAgICAgICAgICAgICAgIHdoZXJlKCd0ZWFtTmFtZScsICc9PScsIHVzZXJQcm9maWxlLnRlYW1OYW1lKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVtcGxveWVlc1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhlbXBsb3llZXNRdWVyeSk7XHJcbiAgICAgICAgICAgICAgICBlbXBsb3llZXNTbmFwc2hvdC5mb3JFYWNoKGRvYyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGRvYy5kYXRhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlckRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcElkOiBkYXRhLmVtcElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbXBOYW1lOiBkYXRhLmVtcE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlYW1OYW1lOiBkYXRhLnRlYW1OYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtkYXRhLnJvbGV9LSR7ZGF0YS5lbXBJZH1gO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZW1wbG95ZWVzU2V0LmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcGxveWVlc1NldC5hZGQoSlNPTi5zdHJpbmdpZnkodXNlckRhdGEpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZW1wbG95ZWVzID0gQXJyYXkuZnJvbShlbXBsb3llZXNTZXQpLm1hcChKU09OLnBhcnNlKTtcclxuXHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB0ZWFtLWxlYWRlciBmaWx0ZXIgb3B0aW9uczonLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRyYWNrTGVhZHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZW1wbG95ZWVzID0gW107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICh1c2VyUHJvZmlsZS5yb2xlID09PSAndHJhY2stbGVhZCcpIHtcclxuICAgICAgICAgICAgLy8gVHJhY2sgbGVhZHMgY2FuIGZpbHRlciBieSB0aGVpciBkaXJlY3QgcmVwb3J0cyAoZW1wbG95ZWVzKVxyXG4gICAgICAgICAgICBvcHRpb25zLnRlYW1zID0gW3VzZXJQcm9maWxlLnRlYW1OYW1lXTtcclxuXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgZW1wbG95ZWVzIHdobyByZXBvcnQgdG8gdGhpcyB0cmFjay1sZWFkIC0gaGllcmFyY2h5LWF3YXJlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbXBsb3llZXNTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbXBsb3llZXNRdWVyeSA9IHF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24oZGIsICd1c2VycycpLFxyXG4gICAgICAgICAgICAgICAgICAgIHdoZXJlKCdyb2xlJywgJz09JywgJ2VtcGxveWVlJyksXHJcbiAgICAgICAgICAgICAgICAgICAgd2hlcmUoJ3RlYW1OYW1lJywgJz09JywgdXNlclByb2ZpbGUudGVhbU5hbWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHdoZXJlKCdyZXBvcnRzVG8nLCAnPT0nLCB1c2VyUHJvZmlsZS5lbXBJZClcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbXBsb3llZXNTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MoZW1wbG95ZWVzUXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgZW1wbG95ZWVzU25hcHNob3QuZm9yRWFjaChkb2MgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBkb2MuZGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbXBJZDogZGF0YS5lbXBJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1wTmFtZTogZGF0YS5lbXBOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZWFtTmFtZTogZGF0YS50ZWFtTmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7ZGF0YS5yb2xlfS0ke2RhdGEuZW1wSWR9YDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVtcGxveWVlc1NldC5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbXBsb3llZXNTZXQuYWRkKEpTT04uc3RyaW5naWZ5KHVzZXJEYXRhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmVtcGxveWVlcyA9IEFycmF5LmZyb20oZW1wbG95ZWVzU2V0KS5tYXAoSlNPTi5wYXJzZSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB0cmFjay1sZWFkIGZpbHRlciBvcHRpb25zOicsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZW1wbG95ZWVzID0gW107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICh1c2VyUHJvZmlsZS5yb2xlID09PSAnZW1wbG95ZWUnKSB7XHJcbiAgICAgICAgICAgIC8vIEVtcGxveWVlcyBjYW4gb25seSBmaWx0ZXIgYnkgdGhlbXNlbHZlc1xyXG4gICAgICAgICAgICBvcHRpb25zLnRlYW1zID0gW3VzZXJQcm9maWxlLnRlYW1OYW1lXTtcclxuICAgICAgICAgICAgb3B0aW9ucy5lbXBsb3llZXMgPSBbe1xyXG4gICAgICAgICAgICAgICAgZW1wSWQ6IHVzZXJQcm9maWxlLmVtcElkLFxyXG4gICAgICAgICAgICAgICAgZW1wTmFtZTogdXNlclByb2ZpbGUuZW1wTmFtZSxcclxuICAgICAgICAgICAgICAgIHRlYW1OYW1lOiB1c2VyUHJvZmlsZS50ZWFtTmFtZVxyXG4gICAgICAgICAgICB9XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGZpbHRlciBvcHRpb25zOicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0ZWNoTGVhZHM6IFtdLFxyXG4gICAgICAgICAgICB0ZWFtTGVhZGVyczogW10sXHJcbiAgICAgICAgICAgIHRyYWNrTGVhZHM6IFtdLFxyXG4gICAgICAgICAgICBlbXBsb3llZXM6IFtdLFxyXG4gICAgICAgICAgICB0ZWFtczogW11cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIEdldCBXZWVrbHkgVGFzayBGb3IgQ3VycmVudCBVc2VyIE9ubHkhISEgLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbmV4cG9ydCBjb25zdCBnZXRXZWVrbHlUYXNrcyA9IGFzeW5jICh1c2VyUHJvZmlsZSwgc3RhcnREYXRlLCBlbmREYXRlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICghdXNlclByb2ZpbGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2VyIHByb2ZpbGUgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBhbGxUYXNrcyA9IFtdO1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggdGVhbXMgdXNlciBjYW4gYWNjZXNzIChzYW1lIGFzIGdldFRhc2tzKVxyXG4gICAgICAgIGxldCBhY2Nlc3NpYmxlVGVhbXM7XHJcbiAgICAgICAgc3dpdGNoICh1c2VyUHJvZmlsZS5yb2xlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RlY2gtbGVhZCc6XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NpYmxlVGVhbXMgPSBbLi4uKHVzZXJQcm9maWxlLm1hbmFnZWRUZWFtcyB8fCBbXSksICd0ZWNoTGVhZHMnXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd0ZWFtLWxlYWRlcic6XHJcbiAgICAgICAgICAgIGNhc2UgJ2VtcGxveWVlJzpcclxuICAgICAgICAgICAgICAgIGFjY2Vzc2libGVUZWFtcyA9IFt1c2VyUHJvZmlsZS50ZWFtTmFtZV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZvciB3ZWVrbHkgcmVwb3J0LCB3ZSBhc3N1bWUgaXQncyBmb3IgdGhlIGN1cnJlbnQgdXNlciBvbmx5IChlbXBsb3llZSB2aWV3KVxyXG4gICAgICAgIC8vIElmIHRlY2gtbGVhZCBvciB0ZWFtLWxlYWRlciwgdGhleSBjYW4gY2hvb3NlLCBidXQgZm9yIHNpbXBsaWNpdHksIGZpbHRlciB0byBvd24gdGFza3NcclxuICAgICAgICBjb25zdCB0YXJnZXRFbXBJZCA9IHVzZXJQcm9maWxlLmVtcElkOyAvLyBPd24gdGFza3Mgb25seSBmb3IgcmVwb3J0XHJcblxyXG4gICAgICAgIC8vIEZldGNoIHRhc2tzIGZyb20gYWNjZXNzaWJsZSB0ZWFtcyB3aXRoaW4gZGF0ZSByYW5nZVxyXG4gICAgICAgIGZvciAoY29uc3QgdGVhbU5hbWUgb2YgYWNjZXNzaWJsZVRlYW1zKSB7XHJcbiAgICAgICAgICAgIC8vIFF1ZXJ5IGRhdGVzIGJldHdlZW4gc3RhcnQgYW5kIGVuZFxyXG4gICAgICAgICAgICBjb25zdCBkYXRlc1F1ZXJ5ID0gcXVlcnkoXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uKGRiLCAndGVhbXMnLCB0ZWFtTmFtZSwgJ2RhdGVzJyksXHJcbiAgICAgICAgICAgICAgICB3aGVyZSgnX19uYW1lX18nLCAnPj0nLCBzdGFydERhdGUpLFxyXG4gICAgICAgICAgICAgICAgd2hlcmUoJ19fbmFtZV9fJywgJzw9JywgZW5kRGF0ZSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgY29uc3QgZGF0ZXNTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MoZGF0ZXNRdWVyeSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRhdGVEb2Mgb2YgZGF0ZXNTbmFwc2hvdC5kb2NzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRlID0gZGF0ZURvYy5pZDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVtcGxveWVlc1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uKGRiLCAndGVhbXMnLCB0ZWFtTmFtZSwgJ2RhdGVzJywgZGF0ZSwgJ2VtcGxveWVlcycpXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW1wRG9jIG9mIGVtcGxveWVlc1NuYXBzaG90LmRvY3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbXBJZCA9IGVtcERvYy5pZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBmZXRjaCBvd24gdGFza3MgZm9yIHJlcG9ydFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbXBJZCAhPT0gdGFyZ2V0RW1wSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXNrc1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbihkYiwgJ3RlYW1zJywgdGVhbU5hbWUsICdkYXRlcycsIGRhdGUsICdlbXBsb3llZXMnLCBlbXBJZCwgJ3Rhc2tzJylcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbXBUYXNrcyA9IHRhc2tzU25hcHNob3QuZG9jcy5tYXAodGFza0RvYyA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZWFtTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1wSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhc2tEb2MuZGF0YSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdGFza0RvYy5pZFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKS5maWx0ZXIodGFzayA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlciBieSB0aW1lIGlmIHN0YXJ0L2VuZCBoYXZlIHRpbWUsIGJ1dCBzaW5jZSBkYXRlcyBhcmUgWVlZWS1NTS1ERCwgaXQncyBmaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLmRhdGUgPj0gc3RhcnREYXRlICYmIHRhc2suZGF0ZSA8PSBlbmREYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhbGxUYXNrcyA9IFsuLi5hbGxUYXNrcywgLi4uZW1wVGFza3NdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYWxsVGFza3Muc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYS5kYXRlKSAtIG5ldyBEYXRlKGIuZGF0ZSkpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHdlZWtseSB0YXNrczonLCBlcnJvcik7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgYXBwbHlUYXNrRmlsdGVycyA9ICh0YXNrcywgZmlsdGVycywgdXNlclByb2ZpbGUpID0+IHtcclxuICAgIGlmICghdGFza3MgfHwgdGFza3MubGVuZ3RoID09PSAwKSByZXR1cm4gdGFza3M7XHJcblxyXG4gICAgbGV0IGZpbHRlcmVkVGFza3MgPSBbLi4udGFza3NdO1xyXG5cclxuICAgIC8vIFN0YXR1cyBmaWx0ZXJcclxuICAgIGlmIChmaWx0ZXJzLnN0YXR1cykge1xyXG4gICAgICAgIGZpbHRlcmVkVGFza3MgPSBmaWx0ZXJlZFRhc2tzLmZpbHRlcih0YXNrID0+IHRhc2suc3RhdHVzID09PSBmaWx0ZXJzLnN0YXR1cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV29yayB0eXBlIGZpbHRlclxyXG4gICAgaWYgKGZpbHRlcnMud29ya1R5cGUpIHtcclxuICAgICAgICBmaWx0ZXJlZFRhc2tzID0gZmlsdGVyZWRUYXNrcy5maWx0ZXIodGFzayA9PiB0YXNrLndvcmtUeXBlID09PSBmaWx0ZXJzLndvcmtUeXBlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcm9ncmVzcyBmaWx0ZXJcclxuICAgIGlmIChmaWx0ZXJzLnBlcmNlbnRhZ2VDb21wbGV0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgW21pbiwgbWF4XSA9IGZpbHRlcnMucGVyY2VudGFnZUNvbXBsZXRpb24uc3BsaXQoJy0nKS5tYXAoTnVtYmVyKTtcclxuICAgICAgICBmaWx0ZXJlZFRhc2tzID0gZmlsdGVyZWRUYXNrcy5maWx0ZXIodGFzayA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2dyZXNzID0gcGFyc2VJbnQodGFzay5wZXJjZW50YWdlQ29tcGxldGlvbikgfHwgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHByb2dyZXNzID49IG1pbiAmJiBwcm9ncmVzcyA8PSBtYXg7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGVhbSBmaWx0ZXIgKG9ubHkgZm9yIHRlY2ggbGVhZHMpXHJcbiAgICBpZiAoZmlsdGVycy50ZWFtICYmIHVzZXJQcm9maWxlLnJvbGUgPT09ICd0ZWNoLWxlYWQnKSB7XHJcbiAgICAgICAgZmlsdGVyZWRUYXNrcyA9IGZpbHRlcmVkVGFza3MuZmlsdGVyKHRhc2sgPT4gdGFzay50ZWFtTmFtZSA9PT0gZmlsdGVycy50ZWFtKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmlsdGVyZWRUYXNrcztcclxufTtcclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGVhbSBsZWFkZXIgZm9yIGEgdGVhbVxyXG5jb25zdCBnZXRUZWFtTGVhZGVyRm9yVGVhbSA9IGFzeW5jICh0ZWFtTmFtZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB0ZWFtRG9jID0gYXdhaXQgZ2V0RG9jKGRvYyhkYiwgJ3RlYW1zJywgdGVhbU5hbWUpKTtcclxuICAgICAgICBpZiAodGVhbURvYy5leGlzdHMoKSAmJiB0ZWFtRG9jLmRhdGEoKS50ZWFtTGVhZGVySWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRlYW1Eb2MuZGF0YSgpLnRlYW1MZWFkZXJJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdGVhbSBsZWFkZXIgZm9yIHRlYW06JywgdGVhbU5hbWUsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIEdldCBmaWx0ZXJlZCB0YXNrcyB3aXRoIGFsbCBhcHBsaWVkIGZpbHRlcnNcclxuZXhwb3J0IGNvbnN0IGdldEZpbHRlcmVkVGFza3MgPSBhc3luYyAodXNlclByb2ZpbGUsIGZpbHRlcnMgPSB7fSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBGaXJzdCBnZXQgYWxsIGFjY2Vzc2libGUgdGFza3NcclxuICAgICAgICBjb25zdCBhbGxUYXNrcyA9IGF3YWl0IGdldFRhc2tzKHVzZXJQcm9maWxlKTtcclxuXHJcbiAgICAgICAgLy8gVGhlbiBhcHBseSBmaWx0ZXJzXHJcbiAgICAgICAgY29uc3QgZmlsdGVyZWRUYXNrcyA9IGFwcGx5VGFza0ZpbHRlcnMoYWxsVGFza3MsIGZpbHRlcnMsIHVzZXJQcm9maWxlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkVGFza3M7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgZmlsdGVyZWQgdGFza3M6JywgZXJyb3IpO1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSBEUk9QRE9XTlMgV0lUSCBVU0VSIENPTlRFWFQgLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8vIEdldCBkcm9wZG93biBkYXRhIGZvciBhIHRlYW0gKHdpdGggdXNlciBwZXJtaXNzaW9uIGNoZWNrKVxyXG5leHBvcnQgY29uc3QgZ2V0VGVhbURyb3Bkb3duRGF0YSA9IGFzeW5jICh0ZWFtTmFtZSwgZmllbGQsIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHVzZXIgY2FuIGFjY2VzcyB0aGlzIHRlYW1cclxuICAgICAgICBpZiAoIWNhblVzZXJBY2Nlc3NUZWFtKHVzZXJQcm9maWxlLCB0ZWFtTmFtZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBhY2Nlc3MgdGhpcyB0ZWFtIGRhdGEnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBwcmVkZWZpbmVkIHZhbHVlcyBmb3Igc3BlY2lmaWMgZmllbGRzIC0gc2FtZSBmb3IgYWxsIHVzZXJzXHJcbiAgICAgICAgaWYgKFBSRURFRklORURfVkFMVUVTW2ZpZWxkXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUFJFREVGSU5FRF9WQUxVRVNbZmllbGRdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRm9yIGN1c3RvbSBkcm9wZG93biBkYXRhLCBmZXRjaCBmcm9tIEZpcmVzdG9yZVxyXG4gICAgICAgIGNvbnN0IGRvY1JlZiA9IGRvYyhkYiwgJ3RlYW1zJywgdGVhbU5hbWUsICdkcm9wZG93bkRhdGEnLCBmaWVsZCk7XHJcbiAgICAgICAgY29uc3QgZG9jU25hcCA9IGF3YWl0IGdldERvYyhkb2NSZWYpO1xyXG4gICAgICAgIGlmIChkb2NTbmFwLmV4aXN0cygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb2NTbmFwLmRhdGEoKS52YWx1ZXMgfHwgW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB0ZWFtIGRyb3Bkb3duIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgICAgIC8vIEFsd2F5cyByZXR1cm4gcHJlZGVmaW5lZCB2YWx1ZXMgYXMgZmFsbGJhY2tcclxuICAgICAgICByZXR1cm4gUFJFREVGSU5FRF9WQUxVRVNbZmllbGRdIHx8IFtdO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gU2F2ZSBkcm9wZG93biBkYXRhIGZvciBhIHRlYW0gKHdpdGggdXNlciBwZXJtaXNzaW9uIGNoZWNrKVxyXG5leHBvcnQgY29uc3Qgc2F2ZVRlYW1Ecm9wZG93bkRhdGEgPSBhc3luYyAodGVhbU5hbWUsIGZpZWxkLCB2YWx1ZXMsIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHVzZXIgY2FuIG1vZGlmeSB0aGlzIHRlYW0gZGF0YSAob25seSB0ZWFtIGxlYWRlcnMgYW5kIHRlY2ggbGVhZHMpXHJcbiAgICAgICAgaWYgKCFjYW5Vc2VyQWNjZXNzVGVhbSh1c2VyUHJvZmlsZSwgdGVhbU5hbWUpIHx8IHVzZXJQcm9maWxlLnJvbGUgPT09ICdlbXBsb3llZScpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBtb2RpZnkgdGVhbSBkYXRhJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEb24ndCBzYXZlIHByZWRlZmluZWQgdmFsdWVzIHRvIGRhdGFiYXNlXHJcbiAgICAgICAgaWYgKFBSRURFRklORURfVkFMVUVTW2ZpZWxkXSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYENhbm5vdCBzYXZlIHByZWRlZmluZWQgdmFsdWVzIGZvciBmaWVsZDogJHtmaWVsZH1gKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZG9jUmVmID0gZG9jKGRiLCAndGVhbXMnLCB0ZWFtTmFtZSwgJ2Ryb3Bkb3duRGF0YScsIGZpZWxkKTtcclxuICAgICAgICBhd2FpdCBzZXREb2MoZG9jUmVmLCB7IHZhbHVlcyB9LCB7IG1lcmdlOiB0cnVlIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgdGVhbSBkcm9wZG93biBkYXRhOicsIGVycm9yKTtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIFRFQU1TIFdJVEggVVNFUiBDT05URVhUIC0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vLyBHZXQgdGVhbXMgYWNjZXNzaWJsZSB0byB1c2VyXHJcbmV4cG9ydCBjb25zdCBnZXRUZWFtcyA9IGFzeW5jICh1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoIXVzZXJQcm9maWxlKSByZXR1cm4gW107XHJcbiAgICAgICAgcmV0dXJuIGdldEFjY2Vzc2libGVUZWFtcyh1c2VyUHJvZmlsZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdGVhbXM6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIFBST0pFQ1RTIFdJVEggVVNFUiBDT05URVhUIC0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vLyBHZXQgdGVhbS1zcGVjaWZpYyBwcm9qZWN0cyAod2l0aCB1c2VyIHBlcm1pc3Npb24gY2hlY2spXHJcbmV4cG9ydCBjb25zdCBnZXRUZWFtUHJvamVjdHMgPSBhc3luYyAodGVhbU5hbWUsIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICghY2FuVXNlckFjY2Vzc1RlYW0odXNlclByb2ZpbGUsIHRlYW1OYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhd2FpdCBnZXRUZWFtRHJvcGRvd25EYXRhKHRlYW1OYW1lLCAncHJvamVjdHMnLCB1c2VyUHJvZmlsZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdGVhbSBwcm9qZWN0czonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gQWRkIG5ldyBwcm9qZWN0IHRvIHRlYW0gKHdpdGggdXNlciBwZXJtaXNzaW9uIGNoZWNrKVxyXG5leHBvcnQgY29uc3QgYWRkVGVhbVByb2plY3QgPSBhc3luYyAodGVhbU5hbWUsIHByb2plY3RJZCwgcHJvamVjdE5hbWUsIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICghcHJvamVjdElkIHx8ICFwcm9qZWN0TmFtZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAoIWNhblVzZXJBY2Nlc3NUZWFtKHVzZXJQcm9maWxlLCB0ZWFtTmFtZSkgfHwgdXNlclByb2ZpbGUucm9sZSA9PT0gJ2VtcGxveWVlJykge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIFNpbGVudGx5IGZhaWwgZm9yIGVtcGxveWVlc1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdHMgPSBhd2FpdCBnZXRUZWFtUHJvamVjdHModGVhbU5hbWUsIHVzZXJQcm9maWxlKTtcclxuICAgICAgICBjb25zdCBleGlzdHMgPSBwcm9qZWN0cy5maW5kKHAgPT4gcC5pZCA9PT0gcHJvamVjdElkKTtcclxuICAgICAgICBpZiAoIWV4aXN0cykge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdQcm9qZWN0cyA9IFsuLi5wcm9qZWN0cywgeyBpZDogcHJvamVjdElkLCBuYW1lOiBwcm9qZWN0TmFtZSB9XTtcclxuICAgICAgICAgICAgYXdhaXQgc2F2ZVRlYW1Ecm9wZG93bkRhdGEodGVhbU5hbWUsICdwcm9qZWN0cycsIG5ld1Byb2plY3RzLCB1c2VyUHJvZmlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgdGVhbSBwcm9qZWN0OicsIGVycm9yKTtcclxuICAgICAgICAvLyBEb24ndCB0aHJvdyBlcnJvciB0byBwcmV2ZW50IHRhc2sgY3JlYXRpb24gZmFpbHVyZVxyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0gRU1QTE9ZRUVTIFdJVEggVVNFUiBDT05URVhUIC0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vLyBHZXQgdGVhbS1zcGVjaWZpYyBlbXBsb3llZXMgKHdpdGggdXNlciBwZXJtaXNzaW9uIGNoZWNrKVxyXG5leHBvcnQgY29uc3QgZ2V0VGVhbUVtcGxveWVlcyA9IGFzeW5jICh0ZWFtTmFtZSwgdXNlclByb2ZpbGUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCFjYW5Vc2VyQWNjZXNzVGVhbSh1c2VyUHJvZmlsZSwgdGVhbU5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IGdldFRlYW1Ecm9wZG93bkRhdGEodGVhbU5hbWUsICdlbXBsb3llZXMnLCB1c2VyUHJvZmlsZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdGVhbSBlbXBsb3llZXM6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIEFkZCBuZXcgZW1wbG95ZWUgdG8gdGVhbSAod2l0aCB1c2VyIHBlcm1pc3Npb24gY2hlY2spXHJcbmV4cG9ydCBjb25zdCBhZGRUZWFtRW1wbG95ZWUgPSBhc3luYyAodGVhbU5hbWUsIGVtcElkLCBlbXBOYW1lLCB1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoIWVtcElkIHx8ICFlbXBOYW1lKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmICghY2FuVXNlckFjY2Vzc1RlYW0odXNlclByb2ZpbGUsIHRlYW1OYW1lKSB8fCB1c2VyUHJvZmlsZS5yb2xlID09PSAnZW1wbG95ZWUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gU2lsZW50bHkgZmFpbCBmb3IgZW1wbG95ZWVzXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBlbXBsb3llZXMgPSBhd2FpdCBnZXRUZWFtRW1wbG95ZWVzKHRlYW1OYW1lLCB1c2VyUHJvZmlsZSk7XHJcbiAgICAgICAgY29uc3QgZXhpc3RzID0gZW1wbG95ZWVzLmZpbmQoZSA9PiBlLmlkID09PSBlbXBJZCk7XHJcbiAgICAgICAgaWYgKCFleGlzdHMpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3RW1wbG95ZWVzID0gWy4uLmVtcGxveWVlcywgeyBpZDogZW1wSWQsIG5hbWU6IGVtcE5hbWUgfV07XHJcbiAgICAgICAgICAgIGF3YWl0IHNhdmVUZWFtRHJvcGRvd25EYXRhKHRlYW1OYW1lLCAnZW1wbG95ZWVzJywgbmV3RW1wbG95ZWVzLCB1c2VyUHJvZmlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgdGVhbSBlbXBsb3llZTonLCBlcnJvcik7XHJcbiAgICAgICAgLy8gRG9uJ3QgdGhyb3cgZXJyb3IgdG8gcHJldmVudCB0YXNrIGNyZWF0aW9uIGZhaWx1cmVcclxuICAgIH1cclxufTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIENMSUVOVFMgV0lUSCBVU0VSIENPTlRFWFQgLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8vIEdldCB0ZWFtLXNwZWNpZmljIGNsaWVudHMgKHdpdGggdXNlciBwZXJtaXNzaW9uIGNoZWNrKVxyXG5leHBvcnQgY29uc3QgZ2V0VGVhbUNsaWVudHMgPSBhc3luYyAodGVhbU5hbWUsIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICghY2FuVXNlckFjY2Vzc1RlYW0odXNlclByb2ZpbGUsIHRlYW1OYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhd2FpdCBnZXRUZWFtRHJvcGRvd25EYXRhKHRlYW1OYW1lLCAnY2xpZW50cycsIHVzZXJQcm9maWxlKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB0ZWFtIGNsaWVudHM6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIEFkZCBuZXcgY2xpZW50IHRvIHRlYW0gKHdpdGggdXNlciBwZXJtaXNzaW9uIGNoZWNrKVxyXG5leHBvcnQgY29uc3QgYWRkVGVhbUNsaWVudCA9IGFzeW5jICh0ZWFtTmFtZSwgY2xpZW50SWQsIGNsaWVudE5hbWUsIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICghY2xpZW50SWQgfHwgIWNsaWVudE5hbWUpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKCFjYW5Vc2VyQWNjZXNzVGVhbSh1c2VyUHJvZmlsZSwgdGVhbU5hbWUpIHx8IHVzZXJQcm9maWxlLnJvbGUgPT09ICdlbXBsb3llZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyBTaWxlbnRseSBmYWlsIGZvciBlbXBsb3llZXNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGNsaWVudHMgPSBhd2FpdCBnZXRUZWFtQ2xpZW50cyh0ZWFtTmFtZSwgdXNlclByb2ZpbGUpO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IGNsaWVudHMuZmluZChjID0+IGMuaWQgPT09IGNsaWVudElkKTtcclxuICAgICAgICBpZiAoIWV4aXN0cykge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdDbGllbnRzID0gWy4uLmNsaWVudHMsIHsgaWQ6IGNsaWVudElkLCBuYW1lOiBjbGllbnROYW1lIH1dO1xyXG4gICAgICAgICAgICBhd2FpdCBzYXZlVGVhbURyb3Bkb3duRGF0YSh0ZWFtTmFtZSwgJ2NsaWVudHMnLCBuZXdDbGllbnRzLCB1c2VyUHJvZmlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgdGVhbSBjbGllbnQ6JywgZXJyb3IpO1xyXG4gICAgICAgIC8vIERvbid0IHRocm93IGVycm9yIHRvIHByZXZlbnQgdGFzayBjcmVhdGlvbiBmYWlsdXJlXHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSBVVElMSVRZIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLy8gR2V0IHByZWRlZmluZWQgdmFsdWVzIGZvciBhIHNwZWNpZmljIGZpZWxkXHJcbmV4cG9ydCBjb25zdCBnZXRQcmVkZWZpbmVkVmFsdWVzID0gKGZpZWxkKSA9PiB7XHJcbiAgICByZXR1cm4gUFJFREVGSU5FRF9WQUxVRVNbZmllbGRdIHx8IFtdO1xyXG59O1xyXG5cclxuLy8gQ2hlY2sgaWYgZmllbGQgaGFzIHByZWRlZmluZWQgdmFsdWVzXHJcbmV4cG9ydCBjb25zdCBpc1ByZWRlZmluZWRGaWVsZCA9IChmaWVsZCkgPT4ge1xyXG4gICAgcmV0dXJuICEhUFJFREVGSU5FRF9WQUxVRVNbZmllbGRdO1xyXG59O1xyXG5cclxuLy8gQ2hlY2sgaWYgdGVhbSBkb2N1bWVudCBleGlzdHNcclxuZXhwb3J0IGNvbnN0IHRlYW1FeGlzdHMgPSBhc3luYyAodGVhbU5hbWUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgdGVhbURvYyA9IGF3YWl0IGdldERvYyhkb2MoZGIsICd0ZWFtcycsIHRlYW1OYW1lKSk7XHJcbiAgICAgICAgcmV0dXJuIHRlYW1Eb2MuZXhpc3RzKCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIEluaXRpYWxpemUgZGVmYXVsdCBkcm9wZG93biB2YWx1ZXMgZm9yIGEgdGVhbSAob25seSBpZiB0ZWFtIGRvZXNuJ3QgZXhpc3QgeWV0KVxyXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZVRlYW1EZWZhdWx0cyA9IGFzeW5jICh0ZWFtTmFtZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBleGlzdHMgPSBhd2FpdCB0ZWFtRXhpc3RzKHRlYW1OYW1lKTtcclxuICAgICAgICBpZiAoIWV4aXN0cykge1xyXG4gICAgICAgICAgICBhd2FpdCBzZXREb2MoZG9jKGRiLCAndGVhbXMnLCB0ZWFtTmFtZSksIHsgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgdGVhbSBkZWZhdWx0czonLCBlcnJvcik7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbn07Il0sIm5hbWVzIjpbImRiIiwiY29sbGVjdGlvbiIsImFkZERvYyIsImdldERvY3MiLCJkb2MiLCJ1cGRhdGVEb2MiLCJkZWxldGVEb2MiLCJnZXREb2MiLCJzZXREb2MiLCJxdWVyeSIsIndoZXJlIiwiUFJFREVGSU5FRF9WQUxVRVMiLCJwZXJjZW50YWdlQ29tcGxldGlvbiIsInN0YXR1cyIsIndvcmtUeXBlIiwiZ2V0VXNlclByb2ZpbGUiLCJ1c2VySWQiLCJ1c2VyRG9jIiwiZXhpc3RzIiwiZGF0YSIsImVycm9yIiwiY29uc29sZSIsInVwZGF0ZVVzZXJQcm9maWxlIiwicHJvZmlsZURhdGEiLCJtZXJnZSIsImFkZFRhc2siLCJ0YXNrIiwidXNlclByb2ZpbGUiLCJyb2xlIiwidGVhbU5hbWUiLCJjYW5Vc2VyQWNjZXNzRW1wbG95ZWUiLCJlbXBJZCIsIkVycm9yIiwiaW5pdGlhbGl6ZVRlYW1EZWZhdWx0cyIsImRhdGVSZWYiLCJkYXRlIiwiY3JlYXRlZEF0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiZW1wUmVmIiwibmFtZSIsImVtcE5hbWUiLCJhZGRUZWFtRW1wbG95ZWUiLCJjbGllbnRJZCIsImNsaWVudE5hbWUiLCJhZGRUZWFtQ2xpZW50IiwicHJvamVjdElkIiwicHJvamVjdE5hbWUiLCJhZGRUZWFtUHJvamVjdCIsInRhc2tEYXRhIiwiY3JlYXRlZEJ5IiwiZG9jUmVmIiwiaWQiLCJ1cGRhdGVUYXNrIiwidGFza0lkIiwidGFza1JlZiIsInVwZGF0ZWRBdCIsInVwZGF0ZWRCeSIsImdldFRhc2tzIiwidGVhbUZpbHRlciIsImFsbFRhc2tzIiwidG9kYXkiLCJmb3JtYXQiLCJhY2Nlc3NpYmxlVGVhbXMiLCJtYW5hZ2VkVGVhbXMiLCJmaWx0ZXIiLCJ0ZWFtIiwibG9nIiwiZW1wbG95ZWVzU25hcHNob3QiLCJlbXBEb2MiLCJkb2NzIiwiY2FuQWNjZXNzIiwidGFza3NTbmFwc2hvdCIsImVtcFRhc2tzIiwibWFwIiwidGFza0RvYyIsImxlbmd0aCIsInRlYW1FcnJvciIsInNvcnQiLCJhIiwiYiIsImRlbGV0ZVRhc2siLCJjYW5Vc2VyQWNjZXNzVGVhbSIsImNhbkFjY2Vzc01hbmFnZWRUZWFtIiwiaW5jbHVkZXMiLCJjYW5BY2Nlc3NUZWNoTGVhZHNUZWFtIiwidGVjaExlYWRBY2Nlc3MiLCJyZXF1ZXN0ZWRUZWFtIiwiZmluYWxBY2Nlc3MiLCJyZWd1bGFyQWNjZXNzIiwidXNlclRlYW0iLCJhY2Nlc3MiLCJ0YXJnZXRFbXBJZCIsInVzZXJzUXVlcnkiLCJzbmFwc2hvdCIsImVtcHR5IiwidGFyZ2V0VXNlciIsInJlcG9ydHNUbyIsImdldEFjY2Vzc2libGVUZWFtcyIsImdldEZpbHRlck9wdGlvbnMiLCJvcHRpb25zIiwidGVjaExlYWRzIiwidGVhbUxlYWRlcnMiLCJ0cmFja0xlYWRzIiwiZW1wbG95ZWVzIiwidGVhbXMiLCJ0ZWNoTGVhZHNTZXQiLCJTZXQiLCJ0ZWFtTGVhZGVyc1NldCIsInRyYWNrTGVhZHNTZXQiLCJlbXBsb3llZXNTZXQiLCJ1c2Vyc1NuYXBzaG90IiwiZm9yRWFjaCIsInVzZXJEYXRhIiwia2V5IiwiaGFzIiwiYWRkIiwiSlNPTiIsInN0cmluZ2lmeSIsIkFycmF5IiwiZnJvbSIsInBhcnNlIiwidHJhY2tMZWFkc1F1ZXJ5IiwidHJhY2tMZWFkc1NuYXBzaG90IiwiZW1wbG95ZWVzUXVlcnkiLCJnZXRXZWVrbHlUYXNrcyIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJkYXRlc1F1ZXJ5IiwiZGF0ZXNTbmFwc2hvdCIsImRhdGVEb2MiLCJhcHBseVRhc2tGaWx0ZXJzIiwidGFza3MiLCJmaWx0ZXJzIiwiZmlsdGVyZWRUYXNrcyIsIm1pbiIsIm1heCIsInNwbGl0IiwiTnVtYmVyIiwicHJvZ3Jlc3MiLCJwYXJzZUludCIsImdldFRlYW1MZWFkZXJGb3JUZWFtIiwidGVhbURvYyIsInRlYW1MZWFkZXJJZCIsImdldEZpbHRlcmVkVGFza3MiLCJnZXRUZWFtRHJvcGRvd25EYXRhIiwiZmllbGQiLCJkb2NTbmFwIiwidmFsdWVzIiwic2F2ZVRlYW1Ecm9wZG93bkRhdGEiLCJ3YXJuIiwiZ2V0VGVhbXMiLCJnZXRUZWFtUHJvamVjdHMiLCJwcm9qZWN0cyIsImZpbmQiLCJwIiwibmV3UHJvamVjdHMiLCJnZXRUZWFtRW1wbG95ZWVzIiwiZSIsIm5ld0VtcGxveWVlcyIsImdldFRlYW1DbGllbnRzIiwiY2xpZW50cyIsImMiLCJuZXdDbGllbnRzIiwiZ2V0UHJlZGVmaW5lZFZhbHVlcyIsImlzUHJlZGVmaW5lZEZpZWxkIiwidGVhbUV4aXN0cyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./lib/firebase.js\n"));

/***/ })

});