"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./lib/firebase.js":
/*!*************************!*\
  !*** ./lib/firebase.js ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addTask: () => (/* binding */ addTask),\n/* harmony export */   addTeamClient: () => (/* binding */ addTeamClient),\n/* harmony export */   addTeamEmployee: () => (/* binding */ addTeamEmployee),\n/* harmony export */   addTeamProject: () => (/* binding */ addTeamProject),\n/* harmony export */   applyTaskFilters: () => (/* binding */ applyTaskFilters),\n/* harmony export */   canUserAccessEmployee: () => (/* binding */ canUserAccessEmployee),\n/* harmony export */   canUserAccessTeam: () => (/* binding */ canUserAccessTeam),\n/* harmony export */   deleteTask: () => (/* binding */ deleteTask),\n/* harmony export */   getAccessibleTeams: () => (/* binding */ getAccessibleTeams),\n/* harmony export */   getFilterOptions: () => (/* binding */ getFilterOptions),\n/* harmony export */   getFilteredTasks: () => (/* binding */ getFilteredTasks),\n/* harmony export */   getPredefinedValues: () => (/* binding */ getPredefinedValues),\n/* harmony export */   getTasks: () => (/* binding */ getTasks),\n/* harmony export */   getTasksForDateRange: () => (/* binding */ getTasksForDateRange),\n/* harmony export */   getTeamClients: () => (/* binding */ getTeamClients),\n/* harmony export */   getTeamDropdownData: () => (/* binding */ getTeamDropdownData),\n/* harmony export */   getTeamEmployees: () => (/* binding */ getTeamEmployees),\n/* harmony export */   getTeamProjects: () => (/* binding */ getTeamProjects),\n/* harmony export */   getTeams: () => (/* binding */ getTeams),\n/* harmony export */   getUserProfile: () => (/* binding */ getUserProfile),\n/* harmony export */   initializeTeamDefaults: () => (/* binding */ initializeTeamDefaults),\n/* harmony export */   isPredefinedField: () => (/* binding */ isPredefinedField),\n/* harmony export */   saveTeamDropdownData: () => (/* binding */ saveTeamDropdownData),\n/* harmony export */   teamExists: () => (/* binding */ teamExists),\n/* harmony export */   updateTask: () => (/* binding */ updateTask),\n/* harmony export */   updateUserProfile: () => (/* binding */ updateUserProfile)\n/* harmony export */ });\n/* harmony import */ var _firebaseConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./firebaseConfig */ \"(pages-dir-browser)/./lib/firebaseConfig.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(pages-dir-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=format!=!date-fns */ \"(pages-dir-browser)/__barrel_optimize__?names=format!=!./node_modules/date-fns/index.js\");\n// lib/firebase.js - Updated with user context filtering\n\n\n\n// -------------------- PREDEFINED VALUES --------------------\nconst PREDEFINED_VALUES = {\n    percentageCompletion: [\n        '5',\n        '10',\n        '25',\n        '40',\n        '50',\n        '65',\n        '75',\n        '85',\n        '90',\n        '100'\n    ],\n    status: [\n        'Completed',\n        'In Progress',\n        'On Hold'\n    ],\n    workType: [\n        'Full-day',\n        'Half-day',\n        'Relaxation'\n    ]\n};\n// -------------------- USER MANAGEMENT --------------------\n// Get user profile\nconst getUserProfile = async (userId)=>{\n    try {\n        const userDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users', userId));\n        if (userDoc.exists()) {\n            return userDoc.data();\n        }\n        return null;\n    } catch (error) {\n        console.error('Error getting user profile:', error);\n        return null;\n    }\n};\n// Update user profile\nconst updateUserProfile = async (userId, profileData)=>{\n    try {\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users', userId), profileData, {\n            merge: true\n        });\n    } catch (error) {\n        console.error('Error updating user profile:', error);\n        throw error;\n    }\n};\n// -------------------- TASKS WITH USER CONTEXT --------------------\n// lib/firebase.js - Keep addTask for new tasks only\nconst addTask = async (task, userProfile)=>{\n    try {\n        if (userProfile.role === 'tech-lead') {\n            task.teamName = 'techLeads';\n        }\n        // Validate user can add task to this team/employee\n        if (!canUserAccessEmployee(userProfile, task.teamName, task.empId)) {\n            throw new Error('You do not have permission to add tasks for this employee');\n        }\n        // Create the default team name...\n        await initializeTeamDefaults(task.teamName);\n        // Ensure date document exists\n        const dateRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', task.teamName, 'dates', task.date);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(dateRef, {\n            createdAt: new Date().toISOString()\n        }, {\n            merge: true\n        });\n        // Ensure employee document exists with name\n        const empRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', task.teamName, 'dates', task.date, 'employees', task.empId);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(empRef, {\n            name: task.empName\n        }, {\n            merge: true\n        });\n        // Auto-save new employee to team employees if not exists\n        if (task.empId && task.empName) {\n            await addTeamEmployee(task.teamName, task.empId, task.empName);\n        }\n        // Auto-save new client to team clients if not exists\n        if (task.clientId && task.clientName) {\n            await addTeamClient(task.teamName, task.clientId, task.clientName);\n        }\n        // Auto-save new project to team projects if not exists\n        if (task.projectId && task.projectName) {\n            await addTeamProject(task.teamName, task.projectId, task.projectName);\n        }\n        const taskData = {\n            ...task,\n            createdAt: new Date().toISOString(),\n            createdBy: userProfile.empId\n        };\n        const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', task.teamName, 'dates', task.date, 'employees', task.empId, 'tasks'), taskData);\n        // Return full task object with ID for consistency\n        return {\n            ...task,\n            id: docRef.id,\n            createdAt: new Date().toISOString(),\n            createdBy: userProfile.empId\n        };\n    } catch (error) {\n        console.error('Error adding task:', error);\n        throw error;\n    }\n};\n// Update the existing updateTask function to handle auto-save logic\nconst updateTask = async (teamName, date, empId, taskId, taskData, userProfile)=>{\n    try {\n        // Check if user can update this task\n        if (!canUserAccessEmployee(userProfile, teamName, empId)) {\n            throw new Error('You do not have permission to update this task');\n        }\n        // Auto-save new employee to team employees if not exists\n        if (taskData.empId && taskData.empName) {\n            await addTeamEmployee(teamName, taskData.empId, taskData.empName);\n        }\n        // Auto-save new client to team clients if not exists\n        if (taskData.clientId && taskData.clientName) {\n            await addTeamClient(teamName, taskData.clientId, taskData.clientName);\n        }\n        // Auto-save new project to team projects if not exists\n        if (taskData.projectId && taskData.projectName) {\n            await addTeamProject(teamName, taskData.projectId, taskData.projectName);\n        }\n        const taskRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', date, 'employees', empId, 'tasks', taskId);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(taskRef, {\n            ...taskData,\n            updatedAt: new Date().toISOString(),\n            updatedBy: userProfile.empId\n        });\n        // Return the updated task data for consistency\n        return {\n            ...taskData,\n            id: taskId,\n            teamName,\n            date,\n            empId,\n            updatedAt: new Date().toISOString(),\n            updatedBy: userProfile.empId\n        };\n    } catch (error) {\n        console.error('Error updating task:', error);\n        throw error;\n    }\n};\nconst getTasks = async function(userProfile) {\n    let teamFilter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n    try {\n        if (!userProfile) {\n            throw new Error('User profile is required');\n        }\n        let allTasks = [];\n        const today = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(new Date(), 'yyyy-MM-dd');\n        // Determine which teams user can access\n        let accessibleTeams;\n        switch(userProfile.role){\n            case 'tech-lead':\n                accessibleTeams = [\n                    ...userProfile.managedTeams || [],\n                    'techLeads'\n                ];\n                break;\n            case 'team-leader':\n            case 'track-lead':\n            case 'employee':\n                accessibleTeams = [\n                    userProfile.teamName\n                ];\n                break;\n            default:\n                return [];\n        }\n        // Apply team filter if provided\n        if (teamFilter && teamFilter !== 'all') {\n            accessibleTeams = accessibleTeams.filter((team)=>team === teamFilter);\n        }\n        console.log(\"Fetching today's tasks for \".concat(userProfile.role, \" (\").concat(userProfile.empId, \") from teams:\"), accessibleTeams);\n        // Fetch tasks from accessible teams for TODAY only\n        for (const teamName of accessibleTeams){\n            try {\n                const employeesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', today, 'employees'));\n                for (const empDoc of employeesSnapshot.docs){\n                    const empId = empDoc.id;\n                    // Check access\n                    const canAccess = await canUserAccessEmployee(userProfile, teamName, empId);\n                    if (!canAccess) {\n                        console.log(\"Access denied for \".concat(userProfile.role, \" (\").concat(userProfile.empId, \") to employee \").concat(empId, \" in team \").concat(teamName));\n                        continue;\n                    }\n                    console.log(\"Access granted for \".concat(userProfile.role, \" (\").concat(userProfile.empId, \") to employee \").concat(empId, \" in team \").concat(teamName));\n                    const tasksSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', today, 'employees', empId, 'tasks'));\n                    const empTasks = tasksSnapshot.docs.map((taskDoc)=>({\n                            teamName,\n                            date: today,\n                            empId,\n                            ...taskDoc.data(),\n                            id: taskDoc.id\n                        }));\n                    allTasks = [\n                        ...allTasks,\n                        ...empTasks\n                    ];\n                    console.log(\"Found \".concat(empTasks.length, \" tasks for employee \").concat(empId, \" on \").concat(today));\n                }\n            } catch (teamError) {\n                console.error(\"Error fetching tasks for team \".concat(teamName, \":\"), teamError);\n            }\n        }\n        console.log(\"Total today's tasks fetched for \".concat(userProfile.role, \": \").concat(allTasks.length));\n        return allTasks.sort((a, b)=>new Date(b.date) - new Date(a.date));\n    } catch (error) {\n        console.error('Error getting tasks:', error);\n        throw error;\n    }\n};\n// // Update a task (with user permission check)\n// export const updateTask = async (teamName, date, empId, taskId, taskData, userProfile) => {\n//     try {\n//         // Check if user can update this task\n//         if (!canUserAccessEmployee(userProfile, teamName, empId)) {\n//             throw new Error('You do not have permission to update this task');\n//         }\n//         const taskRef = doc(db, 'teams', teamName, 'dates', date, 'employees', empId, 'tasks', taskId);\n//         await updateDoc(taskRef, {\n//             ...taskData,\n//             updatedAt: new Date().toISOString(),\n//             updatedBy: userProfile.empId\n//         });\n//     } catch (error) {\n//         console.error('Error updating task:', error);\n//         throw error;\n//     }\n// };\n// Delete a task (with user permission check)\nconst deleteTask = async (teamName, date, empId, taskId, userProfile)=>{\n    try {\n        // Check if user can delete this task\n        if (!canUserAccessEmployee(userProfile, teamName, empId)) {\n            throw new Error('You do not have permission to delete this task');\n        }\n        const taskRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', date, 'employees', empId, 'tasks', taskId);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.deleteDoc)(taskRef);\n    } catch (error) {\n        console.error('Error deleting task:', error);\n        throw error;\n    }\n};\n// -------------------- PERMISSION HELPERS --------------------\n// Check if user can access specific team\nconst canUserAccessTeam = (userProfile, teamName)=>{\n    if (!userProfile) {\n        console.log('No user profile provided');\n        return false;\n    }\n    console.log(\"Checking access for user \".concat(userProfile.empId, \" (\").concat(userProfile.role, \") to team \").concat(teamName));\n    switch(userProfile.role){\n        case 'tech-lead':\n            var _userProfile_managedTeams;\n            // Tech leads can access:\n            // 1. Teams they manage (from managedTeams array)\n            // 2. The special 'techLeads' team for their personal tasks\n            const canAccessManagedTeam = (_userProfile_managedTeams = userProfile.managedTeams) === null || _userProfile_managedTeams === void 0 ? void 0 : _userProfile_managedTeams.includes(teamName);\n            const canAccessTechLeadsTeam = teamName === 'techLeads';\n            const techLeadAccess = canAccessManagedTeam || canAccessTechLeadsTeam;\n            console.log('Tech lead access check:', {\n                managedTeams: userProfile.managedTeams,\n                requestedTeam: teamName,\n                canAccessManagedTeam,\n                canAccessTechLeadsTeam,\n                finalAccess: techLeadAccess\n            });\n            return techLeadAccess;\n        case 'team-leader':\n        case 'track-lead':\n        case 'employee':\n            const regularAccess = userProfile.teamName === teamName;\n            console.log('Regular user access:', {\n                userTeam: userProfile.teamName,\n                requestedTeam: teamName,\n                access: regularAccess\n            });\n            return regularAccess;\n        default:\n            console.log('Unknown role:', userProfile.role);\n            return false;\n    }\n};\nconst canUserAccessEmployee = async (userProfile, teamName, targetEmpId)=>{\n    if (!userProfile) return false;\n    if (userProfile.teamName !== teamName && userProfile.role !== 'tech-lead') {\n        return false;\n    }\n    switch(userProfile.role){\n        case 'tech-lead':\n            var _userProfile_managedTeams;\n            return (_userProfile_managedTeams = userProfile.managedTeams) === null || _userProfile_managedTeams === void 0 ? void 0 : _userProfile_managedTeams.includes(teamName);\n        case 'team-leader':\n            if (userProfile.teamName !== teamName) return false;\n            return true;\n        case 'track-lead':\n            if (userProfile.teamName !== teamName) return false;\n            try {\n                const usersQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('empId', '==', targetEmpId));\n                const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(usersQuery);\n                if (snapshot.empty) return false;\n                const targetUser = snapshot.docs[0].data();\n                const canAccess = targetUser.empId === userProfile.empId || targetUser.role === 'employee' && targetUser.reportsTo === userProfile.empId;\n                return canAccess;\n            } catch (error) {\n                console.error('Error checking employee access:', error);\n                return false;\n            }\n        case 'employee':\n            return userProfile.teamName === teamName && userProfile.empId === targetEmpId;\n        default:\n            return false;\n    }\n};\n// Get accessible teams for current user\nconst getAccessibleTeams = (userProfile)=>{\n    if (!userProfile) return [];\n    switch(userProfile.role){\n        case 'tech-lead':\n            return userProfile.managedTeams || [];\n        case 'team-leader':\n        case 'track-lead':\n        case 'employee':\n            return [\n                userProfile.teamName\n            ];\n        default:\n            return [];\n    }\n};\n// -------------------- FILTER BASED ON ROLES --------------------\nconst getFilterOptions = async (userProfile)=>{\n    try {\n        const options = {\n            techLeads: [],\n            teamLeaders: [],\n            trackLeads: [],\n            employees: [],\n            teams: []\n        };\n        if (!userProfile) return options;\n        if (userProfile.role === 'tech-lead') {\n            // Tech leads can filter by everything in their managed teams\n            options.teams = userProfile.managedTeams || [];\n            // Use Set for deduplication like old logic\n            const techLeadsSet = new Set();\n            const teamLeadersSet = new Set();\n            const trackLeadsSet = new Set();\n            const employeesSet = new Set();\n            for (const teamName of userProfile.managedTeams){\n                try {\n                    // Get all users in this team (more efficient than separate queries)\n                    const usersQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('teamName', '==', teamName));\n                    const usersSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(usersQuery);\n                    usersSnapshot.forEach((doc)=>{\n                        const data = doc.data();\n                        const userData = {\n                            empId: data.empId,\n                            empName: data.empName,\n                            teamName: data.teamName\n                        };\n                        // Create unique key for deduplication\n                        const key = \"\".concat(data.role, \"-\").concat(data.empId);\n                        switch(data.role){\n                            case 'tech-lead':\n                                if (!techLeadsSet.has(key)) {\n                                    techLeadsSet.add(JSON.stringify(userData));\n                                }\n                                break;\n                            case 'team-leader':\n                                if (!teamLeadersSet.has(key)) {\n                                    teamLeadersSet.add(JSON.stringify(userData));\n                                }\n                                break;\n                            case 'track-lead':\n                                if (!trackLeadsSet.has(key)) {\n                                    trackLeadsSet.add(JSON.stringify(userData));\n                                }\n                                break;\n                            case 'employee':\n                                if (!employeesSet.has(key)) {\n                                    employeesSet.add(JSON.stringify(userData));\n                                }\n                                break;\n                        }\n                    });\n                } catch (error) {\n                    console.error(\"Error fetching data for team \".concat(teamName, \":\"), error);\n                }\n            }\n            // Convert sets back to arrays with consistent structure\n            options.techLeads = Array.from(techLeadsSet).map(JSON.parse);\n            options.teamLeaders = Array.from(teamLeadersSet).map(JSON.parse);\n            options.trackLeads = Array.from(trackLeadsSet).map(JSON.parse);\n            options.employees = Array.from(employeesSet).map(JSON.parse);\n        } else if (userProfile.role === 'team-leader') {\n            // Team leaders can filter by track-leads and employees in their team\n            options.teams = [\n                userProfile.teamName\n            ];\n            try {\n                // Get track-leads - Use Set for consistency\n                const trackLeadsSet = new Set();\n                const trackLeadsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('role', '==', 'track-lead'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('teamName', '==', userProfile.teamName));\n                const trackLeadsSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(trackLeadsQuery);\n                trackLeadsSnapshot.forEach((doc)=>{\n                    const data = doc.data();\n                    const userData = {\n                        empId: data.empId,\n                        empName: data.empName,\n                        teamName: data.teamName\n                    };\n                    const key = \"\".concat(data.role, \"-\").concat(data.empId);\n                    if (!trackLeadsSet.has(key)) {\n                        trackLeadsSet.add(JSON.stringify(userData));\n                    }\n                });\n                options.trackLeads = Array.from(trackLeadsSet).map(JSON.parse);\n                // Get employees - Use Set for consistency\n                const employeesSet = new Set();\n                const employeesQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('role', '==', 'employee'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('teamName', '==', userProfile.teamName));\n                const employeesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(employeesQuery);\n                employeesSnapshot.forEach((doc)=>{\n                    const data = doc.data();\n                    const userData = {\n                        empId: data.empId,\n                        empName: data.empName,\n                        teamName: data.teamName\n                    };\n                    const key = \"\".concat(data.role, \"-\").concat(data.empId);\n                    if (!employeesSet.has(key)) {\n                        employeesSet.add(JSON.stringify(userData));\n                    }\n                });\n                options.employees = Array.from(employeesSet).map(JSON.parse);\n            } catch (error) {\n                console.error('Error fetching team-leader filter options:', error);\n                options.trackLeads = [];\n                options.employees = [];\n            }\n        } else if (userProfile.role === 'track-lead') {\n            // Track leads can filter by their direct reports (employees)\n            options.teams = [\n                userProfile.teamName\n            ];\n            try {\n                // Get employees who report to this track-lead - hierarchy-aware\n                const employeesSet = new Set();\n                const employeesQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('role', '==', 'employee'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('teamName', '==', userProfile.teamName), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('reportsTo', '==', userProfile.empId));\n                const employeesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(employeesQuery);\n                employeesSnapshot.forEach((doc)=>{\n                    const data = doc.data();\n                    const userData = {\n                        empId: data.empId,\n                        empName: data.empName,\n                        teamName: data.teamName\n                    };\n                    const key = \"\".concat(data.role, \"-\").concat(data.empId);\n                    if (!employeesSet.has(key)) {\n                        employeesSet.add(JSON.stringify(userData));\n                    }\n                });\n                options.employees = Array.from(employeesSet).map(JSON.parse);\n            } catch (error) {\n                console.error('Error fetching track-lead filter options:', error);\n                options.employees = [];\n            }\n        } else if (userProfile.role === 'employee') {\n            // Employees can only filter by themselves\n            options.teams = [\n                userProfile.teamName\n            ];\n            options.employees = [\n                {\n                    empId: userProfile.empId,\n                    empName: userProfile.empName,\n                    teamName: userProfile.teamName\n                }\n            ];\n        }\n        return options;\n    } catch (error) {\n        console.error('Error getting filter options:', error);\n        return {\n            techLeads: [],\n            teamLeaders: [],\n            trackLeads: [],\n            employees: [],\n            teams: []\n        };\n    }\n};\n// -------------------- Get Weekly Task For Current User Only!!! --------------------\nconst getTasksForDateRange = async function(userProfile, startDate, endDate) {\n    let teamFilter = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, empIdFilter = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;\n    try {\n        if (!userProfile) {\n            throw new Error('User profile is required');\n        }\n        let allTasks = [];\n        // Determine which teams user can access\n        let accessibleTeams;\n        switch(userProfile.role){\n            case 'tech-lead':\n                accessibleTeams = [\n                    ...userProfile.managedTeams || [],\n                    'techLeads'\n                ];\n                break;\n            case 'team-leader':\n            case 'track-lead':\n            case 'employee':\n                accessibleTeams = [\n                    userProfile.teamName\n                ];\n                break;\n            default:\n                return [];\n        }\n        // Apply team filter if provided and accessible\n        if (teamFilter && accessibleTeams.includes(teamFilter)) {\n            accessibleTeams = [\n                teamFilter\n            ];\n        } else if (teamFilter) {\n            return []; // Invalid team filter\n        }\n        // Generate date range\n        const start = new Date(startDate);\n        const end = new Date(endDate);\n        for(let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)){\n            const date = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(d, 'yyyy-MM-dd');\n            // Fetch tasks from accessible teams for this date\n            for (const teamName of accessibleTeams){\n                try {\n                    const employeesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', date, 'employees'));\n                    for (const empDoc of employeesSnapshot.docs){\n                        const empId = empDoc.id;\n                        // Apply empIdFilter if provided\n                        if (empIdFilter && empId !== empIdFilter) {\n                            continue;\n                        }\n                        // Check access\n                        const canAccess = await canUserAccessEmployee(userProfile, teamName, empId);\n                        if (!canAccess) {\n                            continue;\n                        }\n                        const tasksSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', date, 'employees', empId, 'tasks'));\n                        const empTasks = tasksSnapshot.docs.map((taskDoc)=>({\n                                teamName,\n                                date,\n                                empId,\n                                ...taskDoc.data(),\n                                id: taskDoc.id\n                            }));\n                        allTasks = [\n                            ...allTasks,\n                            ...empTasks\n                        ];\n                    }\n                } catch (teamError) {\n                    console.error(\"Error fetching tasks for team \".concat(teamName, \" on \").concat(date, \":\"), teamError);\n                }\n            }\n        }\n        return allTasks.sort((a, b)=>new Date(a.date) - new Date(b.date));\n    } catch (error) {\n        console.error('Error getting tasks for date range:', error);\n        throw error;\n    }\n};\nconst applyTaskFilters = (tasks, filters, userProfile)=>{\n    if (!tasks || tasks.length === 0) return tasks;\n    let filteredTasks = [\n        ...tasks\n    ];\n    // Status filter\n    if (filters.status) {\n        filteredTasks = filteredTasks.filter((task)=>task.status === filters.status);\n    }\n    // Work type filter\n    if (filters.workType) {\n        filteredTasks = filteredTasks.filter((task)=>task.workType === filters.workType);\n    }\n    // Progress filter\n    if (filters.percentageCompletion) {\n        const [min, max] = filters.percentageCompletion.split('-').map(Number);\n        filteredTasks = filteredTasks.filter((task)=>{\n            const progress = parseInt(task.percentageCompletion) || 0;\n            return progress >= min && progress <= max;\n        });\n    }\n    // Team filter (only for tech leads)\n    if (filters.team && userProfile.role === 'tech-lead') {\n        filteredTasks = filteredTasks.filter((task)=>task.teamName === filters.team);\n    }\n    return filteredTasks;\n};\n// Helper function to get team leader for a team\nconst getTeamLeaderForTeam = async (teamName)=>{\n    try {\n        const teamDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName));\n        if (teamDoc.exists() && teamDoc.data().teamLeaderId) {\n            return teamDoc.data().teamLeaderId;\n        }\n        return null;\n    } catch (error) {\n        console.error('Error getting team leader for team:', teamName, error);\n        return null;\n    }\n};\n// Get filtered tasks with all applied filters\nconst getFilteredTasks = async function(userProfile) {\n    let filters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    try {\n        // First get all accessible tasks\n        const allTasks = await getTasks(userProfile);\n        // Then apply filters\n        const filteredTasks = applyTaskFilters(allTasks, filters, userProfile);\n        return filteredTasks;\n    } catch (error) {\n        console.error('Error getting filtered tasks:', error);\n        throw error;\n    }\n};\n// -------------------- DROPDOWNS WITH USER CONTEXT --------------------\n// Get dropdown data for a team (with user permission check)\nconst getTeamDropdownData = async (teamName, field, userProfile)=>{\n    try {\n        // Check if user can access this team\n        if (!canUserAccessTeam(userProfile, teamName)) {\n            throw new Error('You do not have permission to access this team data');\n        }\n        // Return predefined values for specific fields - same for all users\n        if (PREDEFINED_VALUES[field]) {\n            return PREDEFINED_VALUES[field];\n        }\n        // For custom dropdown data, fetch from Firestore\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dropdownData', field);\n        const docSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(docRef);\n        if (docSnap.exists()) {\n            return docSnap.data().values || [];\n        }\n        return [];\n    } catch (error) {\n        console.error('Error getting team dropdown data:', error);\n        // Always return predefined values as fallback\n        return PREDEFINED_VALUES[field] || [];\n    }\n};\n// Save dropdown data for a team (with user permission check)\nconst saveTeamDropdownData = async (teamName, field, values, userProfile)=>{\n    try {\n        // Check if user can modify this team data (only team leaders and tech leads)\n        if (!canUserAccessTeam(userProfile, teamName) || userProfile.role === 'employee') {\n            throw new Error('You do not have permission to modify team data');\n        }\n        // Don't save predefined values to database\n        if (PREDEFINED_VALUES[field]) {\n            console.warn(\"Cannot save predefined values for field: \".concat(field));\n            return;\n        }\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dropdownData', field);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(docRef, {\n            values\n        }, {\n            merge: true\n        });\n    } catch (error) {\n        console.error('Error saving team dropdown data:', error);\n        throw error;\n    }\n};\n// -------------------- TEAMS WITH USER CONTEXT --------------------\n// Get teams accessible to user\nconst getTeams = async (userProfile)=>{\n    try {\n        if (!userProfile) return [];\n        return getAccessibleTeams(userProfile);\n    } catch (error) {\n        console.error('Error getting teams:', error);\n        return [];\n    }\n};\n// -------------------- PROJECTS WITH USER CONTEXT --------------------\n// Get team-specific projects (with user permission check)\nconst getTeamProjects = async (teamName, userProfile)=>{\n    try {\n        if (!canUserAccessTeam(userProfile, teamName)) {\n            return [];\n        }\n        return await getTeamDropdownData(teamName, 'projects', userProfile);\n    } catch (error) {\n        console.error('Error getting team projects:', error);\n        return [];\n    }\n};\n// Add new project to team (with user permission check)\nconst addTeamProject = async (teamName, projectId, projectName, userProfile)=>{\n    try {\n        if (!projectId || !projectName) return;\n        if (!canUserAccessTeam(userProfile, teamName) || userProfile.role === 'employee') {\n            return; // Silently fail for employees\n        }\n        const projects = await getTeamProjects(teamName, userProfile);\n        const exists = projects.find((p)=>p.id === projectId);\n        if (!exists) {\n            const newProjects = [\n                ...projects,\n                {\n                    id: projectId,\n                    name: projectName\n                }\n            ];\n            await saveTeamDropdownData(teamName, 'projects', newProjects, userProfile);\n        }\n    } catch (error) {\n        console.error('Error adding team project:', error);\n    // Don't throw error to prevent task creation failure\n    }\n};\n// -------------------- EMPLOYEES WITH USER CONTEXT --------------------\n// Get team-specific employees (with user permission check)\nconst getTeamEmployees = async (teamName, userProfile)=>{\n    try {\n        if (!canUserAccessTeam(userProfile, teamName)) {\n            return [];\n        }\n        return await getTeamDropdownData(teamName, 'employees', userProfile);\n    } catch (error) {\n        console.error('Error getting team employees:', error);\n        return [];\n    }\n};\n// Add new employee to team (with user permission check)\nconst addTeamEmployee = async (teamName, empId, empName, userProfile)=>{\n    try {\n        if (!empId || !empName) return;\n        if (!canUserAccessTeam(userProfile, teamName) || userProfile.role === 'employee') {\n            return; // Silently fail for employees\n        }\n        const employees = await getTeamEmployees(teamName, userProfile);\n        const exists = employees.find((e)=>e.id === empId);\n        if (!exists) {\n            const newEmployees = [\n                ...employees,\n                {\n                    id: empId,\n                    name: empName\n                }\n            ];\n            await saveTeamDropdownData(teamName, 'employees', newEmployees, userProfile);\n        }\n    } catch (error) {\n        console.error('Error adding team employee:', error);\n    // Don't throw error to prevent task creation failure\n    }\n};\n// -------------------- CLIENTS WITH USER CONTEXT --------------------\n// Get team-specific clients (with user permission check)\nconst getTeamClients = async (teamName, userProfile)=>{\n    try {\n        if (!canUserAccessTeam(userProfile, teamName)) {\n            return [];\n        }\n        return await getTeamDropdownData(teamName, 'clients', userProfile);\n    } catch (error) {\n        console.error('Error getting team clients:', error);\n        return [];\n    }\n};\n// Add new client to team (with user permission check)\nconst addTeamClient = async (teamName, clientId, clientName, userProfile)=>{\n    try {\n        if (!clientId || !clientName) return;\n        if (!canUserAccessTeam(userProfile, teamName) || userProfile.role === 'employee') {\n            return; // Silently fail for employees\n        }\n        const clients = await getTeamClients(teamName, userProfile);\n        const exists = clients.find((c)=>c.id === clientId);\n        if (!exists) {\n            const newClients = [\n                ...clients,\n                {\n                    id: clientId,\n                    name: clientName\n                }\n            ];\n            await saveTeamDropdownData(teamName, 'clients', newClients, userProfile);\n        }\n    } catch (error) {\n        console.error('Error adding team client:', error);\n    // Don't throw error to prevent task creation failure\n    }\n};\n// -------------------- UTILITY FUNCTIONS --------------------\n// Get predefined values for a specific field\nconst getPredefinedValues = (field)=>{\n    return PREDEFINED_VALUES[field] || [];\n};\n// Check if field has predefined values\nconst isPredefinedField = (field)=>{\n    return !!PREDEFINED_VALUES[field];\n};\n// Check if team document exists\nconst teamExists = async (teamName)=>{\n    try {\n        const teamDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName));\n        return teamDoc.exists();\n    } catch (error) {\n        return false;\n    }\n};\n// Initialize default dropdown values for a team (only if team doesn't exist yet)\nconst initializeTeamDefaults = async (teamName)=>{\n    try {\n        const exists = await teamExists(teamName);\n        if (!exists) {\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName), {\n                createdAt: new Date().toISOString()\n            });\n        }\n    } catch (error) {\n        console.error('Error initializing team defaults:', error);\n        throw error;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RjtBQUMxRSxNQUFNYSx5QkFBeUIsT0FBT0o7SUFDekMsSUFBSTtRQUNBLE1BQU1YLFNBQVMsTUFBTXNKLFdBQVczSTtRQUNoQyxJQUFJLENBQUNYLFFBQVE7WUFDVCxNQUFNWCwwREFBTUEsQ0FBQ0osdURBQUdBLENBQUNKLCtDQUFFQSxFQUFFLFNBQVM4QixXQUFXO2dCQUFFTyxXQUFXLElBQUlDLE9BQU9DLFdBQVc7WUFBRztRQUNuRjtJQUNKLEVBQUUsT0FBT2xCLE9BQU87UUFDWkMsUUFBUUQsS0FBSyxDQUFDLHFDQUFxQ0E7UUFDbkQsTUFBTUE7SUFDVjtBQUNKLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxzYXVyYWJoXFxQcm9qZWN0c1xcQWR2YW5jZWRfR2VuQUlcXFRhc2tIaXZlXFxsaWJcXGZpcmViYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxpYi9maXJlYmFzZS5qcyAtIFVwZGF0ZWQgd2l0aCB1c2VyIGNvbnRleHQgZmlsdGVyaW5nXHJcbmltcG9ydCB7IGRiIH0gZnJvbSAnLi9maXJlYmFzZUNvbmZpZyc7XHJcbmltcG9ydCB7XHJcbiAgICBjb2xsZWN0aW9uLCBhZGREb2MsIGdldERvY3MsIGRvYywgdXBkYXRlRG9jLCBkZWxldGVEb2MsIGdldERvYywgc2V0RG9jLCBxdWVyeSwgd2hlcmVcclxufSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnO1xyXG5pbXBvcnQgeyBmb3JtYXQgfSBmcm9tIFwiZGF0ZS1mbnNcIjtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIFBSRURFRklORUQgVkFMVUVTIC0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbmNvbnN0IFBSRURFRklORURfVkFMVUVTID0ge1xyXG4gICAgcGVyY2VudGFnZUNvbXBsZXRpb246IFsnNScsICcxMCcsICcyNScsICc0MCcsICc1MCcsICc2NScsICc3NScsICc4NScsICc5MCcsICcxMDAnXSxcclxuICAgIHN0YXR1czogWydDb21wbGV0ZWQnLCAnSW4gUHJvZ3Jlc3MnLCAnT24gSG9sZCddLFxyXG4gICAgd29ya1R5cGU6IFsnRnVsbC1kYXknLCAnSGFsZi1kYXknLCAnUmVsYXhhdGlvbiddXHJcbn07XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSBVU0VSIE1BTkFHRU1FTlQgLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8vIEdldCB1c2VyIHByb2ZpbGVcclxuZXhwb3J0IGNvbnN0IGdldFVzZXJQcm9maWxlID0gYXN5bmMgKHVzZXJJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB1c2VyRG9jID0gYXdhaXQgZ2V0RG9jKGRvYyhkYiwgJ3VzZXJzJywgdXNlcklkKSk7XHJcbiAgICAgICAgaWYgKHVzZXJEb2MuZXhpc3RzKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZXJEb2MuZGF0YSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB1c2VyIHByb2ZpbGU6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gVXBkYXRlIHVzZXIgcHJvZmlsZVxyXG5leHBvcnQgY29uc3QgdXBkYXRlVXNlclByb2ZpbGUgPSBhc3luYyAodXNlcklkLCBwcm9maWxlRGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBzZXREb2MoZG9jKGRiLCAndXNlcnMnLCB1c2VySWQpLCBwcm9maWxlRGF0YSwgeyBtZXJnZTogdHJ1ZSB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgdXNlciBwcm9maWxlOicsIGVycm9yKTtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIFRBU0tTIFdJVEggVVNFUiBDT05URVhUIC0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vLyBsaWIvZmlyZWJhc2UuanMgLSBLZWVwIGFkZFRhc2sgZm9yIG5ldyB0YXNrcyBvbmx5XHJcbmV4cG9ydCBjb25zdCBhZGRUYXNrID0gYXN5bmMgKHRhc2ssIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICh1c2VyUHJvZmlsZS5yb2xlID09PSAndGVjaC1sZWFkJykge1xyXG4gICAgICAgICAgICB0YXNrLnRlYW1OYW1lID0gJ3RlY2hMZWFkcyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBWYWxpZGF0ZSB1c2VyIGNhbiBhZGQgdGFzayB0byB0aGlzIHRlYW0vZW1wbG95ZWVcclxuICAgICAgICBpZiAoIWNhblVzZXJBY2Nlc3NFbXBsb3llZSh1c2VyUHJvZmlsZSwgdGFzay50ZWFtTmFtZSwgdGFzay5lbXBJZCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBhZGQgdGFza3MgZm9yIHRoaXMgZW1wbG95ZWUnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgZGVmYXVsdCB0ZWFtIG5hbWUuLi5cclxuICAgICAgICBhd2FpdCBpbml0aWFsaXplVGVhbURlZmF1bHRzKHRhc2sudGVhbU5hbWUpO1xyXG5cclxuICAgICAgICAvLyBFbnN1cmUgZGF0ZSBkb2N1bWVudCBleGlzdHNcclxuICAgICAgICBjb25zdCBkYXRlUmVmID0gZG9jKGRiLCAndGVhbXMnLCB0YXNrLnRlYW1OYW1lLCAnZGF0ZXMnLCB0YXNrLmRhdGUpO1xyXG4gICAgICAgIGF3YWl0IHNldERvYyhkYXRlUmVmLCB7IGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0sIHsgbWVyZ2U6IHRydWUgfSk7XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSBlbXBsb3llZSBkb2N1bWVudCBleGlzdHMgd2l0aCBuYW1lXHJcbiAgICAgICAgY29uc3QgZW1wUmVmID0gZG9jKGRiLCAndGVhbXMnLCB0YXNrLnRlYW1OYW1lLCAnZGF0ZXMnLCB0YXNrLmRhdGUsICdlbXBsb3llZXMnLCB0YXNrLmVtcElkKTtcclxuICAgICAgICBhd2FpdCBzZXREb2MoZW1wUmVmLCB7IG5hbWU6IHRhc2suZW1wTmFtZSB9LCB7IG1lcmdlOiB0cnVlIH0pO1xyXG5cclxuICAgICAgICAvLyBBdXRvLXNhdmUgbmV3IGVtcGxveWVlIHRvIHRlYW0gZW1wbG95ZWVzIGlmIG5vdCBleGlzdHNcclxuICAgICAgICBpZiAodGFzay5lbXBJZCAmJiB0YXNrLmVtcE5hbWUpIHtcclxuICAgICAgICAgICAgYXdhaXQgYWRkVGVhbUVtcGxveWVlKHRhc2sudGVhbU5hbWUsIHRhc2suZW1wSWQsIHRhc2suZW1wTmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBdXRvLXNhdmUgbmV3IGNsaWVudCB0byB0ZWFtIGNsaWVudHMgaWYgbm90IGV4aXN0c1xyXG4gICAgICAgIGlmICh0YXNrLmNsaWVudElkICYmIHRhc2suY2xpZW50TmFtZSkge1xyXG4gICAgICAgICAgICBhd2FpdCBhZGRUZWFtQ2xpZW50KHRhc2sudGVhbU5hbWUsIHRhc2suY2xpZW50SWQsIHRhc2suY2xpZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBdXRvLXNhdmUgbmV3IHByb2plY3QgdG8gdGVhbSBwcm9qZWN0cyBpZiBub3QgZXhpc3RzXHJcbiAgICAgICAgaWYgKHRhc2sucHJvamVjdElkICYmIHRhc2sucHJvamVjdE5hbWUpIHtcclxuICAgICAgICAgICAgYXdhaXQgYWRkVGVhbVByb2plY3QodGFzay50ZWFtTmFtZSwgdGFzay5wcm9qZWN0SWQsIHRhc2sucHJvamVjdE5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdGFza0RhdGEgPSB7XHJcbiAgICAgICAgICAgIC4uLnRhc2ssXHJcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgICBjcmVhdGVkQnk6IHVzZXJQcm9maWxlLmVtcElkXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgZG9jUmVmID0gYXdhaXQgYWRkRG9jKFxyXG4gICAgICAgICAgICBjb2xsZWN0aW9uKGRiLCAndGVhbXMnLCB0YXNrLnRlYW1OYW1lLCAnZGF0ZXMnLCB0YXNrLmRhdGUsICdlbXBsb3llZXMnLCB0YXNrLmVtcElkLCAndGFza3MnKSxcclxuICAgICAgICAgICAgdGFza0RhdGFcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gZnVsbCB0YXNrIG9iamVjdCB3aXRoIElEIGZvciBjb25zaXN0ZW5jeVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC4uLnRhc2ssXHJcbiAgICAgICAgICAgIGlkOiBkb2NSZWYuaWQsXHJcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgICBjcmVhdGVkQnk6IHVzZXJQcm9maWxlLmVtcElkXHJcbiAgICAgICAgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHRhc2s6JywgZXJyb3IpO1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gVXBkYXRlIHRoZSBleGlzdGluZyB1cGRhdGVUYXNrIGZ1bmN0aW9uIHRvIGhhbmRsZSBhdXRvLXNhdmUgbG9naWNcclxuZXhwb3J0IGNvbnN0IHVwZGF0ZVRhc2sgPSBhc3luYyAodGVhbU5hbWUsIGRhdGUsIGVtcElkLCB0YXNrSWQsIHRhc2tEYXRhLCB1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBDaGVjayBpZiB1c2VyIGNhbiB1cGRhdGUgdGhpcyB0YXNrXHJcbiAgICAgICAgaWYgKCFjYW5Vc2VyQWNjZXNzRW1wbG95ZWUodXNlclByb2ZpbGUsIHRlYW1OYW1lLCBlbXBJZCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byB1cGRhdGUgdGhpcyB0YXNrJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBdXRvLXNhdmUgbmV3IGVtcGxveWVlIHRvIHRlYW0gZW1wbG95ZWVzIGlmIG5vdCBleGlzdHNcclxuICAgICAgICBpZiAodGFza0RhdGEuZW1wSWQgJiYgdGFza0RhdGEuZW1wTmFtZSkge1xyXG4gICAgICAgICAgICBhd2FpdCBhZGRUZWFtRW1wbG95ZWUodGVhbU5hbWUsIHRhc2tEYXRhLmVtcElkLCB0YXNrRGF0YS5lbXBOYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEF1dG8tc2F2ZSBuZXcgY2xpZW50IHRvIHRlYW0gY2xpZW50cyBpZiBub3QgZXhpc3RzXHJcbiAgICAgICAgaWYgKHRhc2tEYXRhLmNsaWVudElkICYmIHRhc2tEYXRhLmNsaWVudE5hbWUpIHtcclxuICAgICAgICAgICAgYXdhaXQgYWRkVGVhbUNsaWVudCh0ZWFtTmFtZSwgdGFza0RhdGEuY2xpZW50SWQsIHRhc2tEYXRhLmNsaWVudE5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXV0by1zYXZlIG5ldyBwcm9qZWN0IHRvIHRlYW0gcHJvamVjdHMgaWYgbm90IGV4aXN0c1xyXG4gICAgICAgIGlmICh0YXNrRGF0YS5wcm9qZWN0SWQgJiYgdGFza0RhdGEucHJvamVjdE5hbWUpIHtcclxuICAgICAgICAgICAgYXdhaXQgYWRkVGVhbVByb2plY3QodGVhbU5hbWUsIHRhc2tEYXRhLnByb2plY3RJZCwgdGFza0RhdGEucHJvamVjdE5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdGFza1JlZiA9IGRvYyhkYiwgJ3RlYW1zJywgdGVhbU5hbWUsICdkYXRlcycsIGRhdGUsICdlbXBsb3llZXMnLCBlbXBJZCwgJ3Rhc2tzJywgdGFza0lkKTtcclxuICAgICAgICBhd2FpdCB1cGRhdGVEb2ModGFza1JlZiwge1xyXG4gICAgICAgICAgICAuLi50YXNrRGF0YSxcclxuICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICAgIHVwZGF0ZWRCeTogdXNlclByb2ZpbGUuZW1wSWRcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIHRoZSB1cGRhdGVkIHRhc2sgZGF0YSBmb3IgY29uc2lzdGVuY3lcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi50YXNrRGF0YSxcclxuICAgICAgICAgICAgaWQ6IHRhc2tJZCxcclxuICAgICAgICAgICAgdGVhbU5hbWUsXHJcbiAgICAgICAgICAgIGRhdGUsXHJcbiAgICAgICAgICAgIGVtcElkLFxyXG4gICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgICAgdXBkYXRlZEJ5OiB1c2VyUHJvZmlsZS5lbXBJZFxyXG4gICAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHRhc2s6JywgZXJyb3IpO1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFRhc2tzID0gYXN5bmMgKHVzZXJQcm9maWxlLCB0ZWFtRmlsdGVyID0gbnVsbCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoIXVzZXJQcm9maWxlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlciBwcm9maWxlIGlzIHJlcXVpcmVkJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgYWxsVGFza3MgPSBbXTtcclxuICAgICAgICBjb25zdCB0b2RheSA9IGZvcm1hdChuZXcgRGF0ZSgpLCAneXl5eS1NTS1kZCcpO1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggdGVhbXMgdXNlciBjYW4gYWNjZXNzXHJcbiAgICAgICAgbGV0IGFjY2Vzc2libGVUZWFtcztcclxuICAgICAgICBzd2l0Y2ggKHVzZXJQcm9maWxlLnJvbGUpIHtcclxuICAgICAgICAgICAgY2FzZSAndGVjaC1sZWFkJzpcclxuICAgICAgICAgICAgICAgIGFjY2Vzc2libGVUZWFtcyA9IFsuLi4odXNlclByb2ZpbGUubWFuYWdlZFRlYW1zIHx8IFtdKSwgJ3RlY2hMZWFkcyddO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RlYW0tbGVhZGVyJzpcclxuICAgICAgICAgICAgY2FzZSAndHJhY2stbGVhZCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2VtcGxveWVlJzpcclxuICAgICAgICAgICAgICAgIGFjY2Vzc2libGVUZWFtcyA9IFt1c2VyUHJvZmlsZS50ZWFtTmFtZV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFwcGx5IHRlYW0gZmlsdGVyIGlmIHByb3ZpZGVkXHJcbiAgICAgICAgaWYgKHRlYW1GaWx0ZXIgJiYgdGVhbUZpbHRlciAhPT0gJ2FsbCcpIHtcclxuICAgICAgICAgICAgYWNjZXNzaWJsZVRlYW1zID0gYWNjZXNzaWJsZVRlYW1zLmZpbHRlcih0ZWFtID0+IHRlYW0gPT09IHRlYW1GaWx0ZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYEZldGNoaW5nIHRvZGF5J3MgdGFza3MgZm9yICR7dXNlclByb2ZpbGUucm9sZX0gKCR7dXNlclByb2ZpbGUuZW1wSWR9KSBmcm9tIHRlYW1zOmAsIGFjY2Vzc2libGVUZWFtcyk7XHJcblxyXG4gICAgICAgIC8vIEZldGNoIHRhc2tzIGZyb20gYWNjZXNzaWJsZSB0ZWFtcyBmb3IgVE9EQVkgb25seVxyXG4gICAgICAgIGZvciAoY29uc3QgdGVhbU5hbWUgb2YgYWNjZXNzaWJsZVRlYW1zKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbXBsb3llZXNTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MoXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbihkYiwgJ3RlYW1zJywgdGVhbU5hbWUsICdkYXRlcycsIHRvZGF5LCAnZW1wbG95ZWVzJylcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbXBEb2Mgb2YgZW1wbG95ZWVzU25hcHNob3QuZG9jcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVtcElkID0gZW1wRG9jLmlkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBhY2Nlc3NcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW5BY2Nlc3MgPSBhd2FpdCBjYW5Vc2VyQWNjZXNzRW1wbG95ZWUodXNlclByb2ZpbGUsIHRlYW1OYW1lLCBlbXBJZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuQWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBBY2Nlc3MgZGVuaWVkIGZvciAke3VzZXJQcm9maWxlLnJvbGV9ICgke3VzZXJQcm9maWxlLmVtcElkfSkgdG8gZW1wbG95ZWUgJHtlbXBJZH0gaW4gdGVhbSAke3RlYW1OYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBBY2Nlc3MgZ3JhbnRlZCBmb3IgJHt1c2VyUHJvZmlsZS5yb2xlfSAoJHt1c2VyUHJvZmlsZS5lbXBJZH0pIHRvIGVtcGxveWVlICR7ZW1wSWR9IGluIHRlYW0gJHt0ZWFtTmFtZX1gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFza3NTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24oZGIsICd0ZWFtcycsIHRlYW1OYW1lLCAnZGF0ZXMnLCB0b2RheSwgJ2VtcGxveWVlcycsIGVtcElkLCAndGFza3MnKVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVtcFRhc2tzID0gdGFza3NTbmFwc2hvdC5kb2NzLm1hcCh0YXNrRG9jID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlYW1OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiB0b2RheSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1wSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhc2tEb2MuZGF0YSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdGFza0RvYy5pZFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYWxsVGFza3MgPSBbLi4uYWxsVGFza3MsIC4uLmVtcFRhc2tzXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtlbXBUYXNrcy5sZW5ndGh9IHRhc2tzIGZvciBlbXBsb3llZSAke2VtcElkfSBvbiAke3RvZGF5fWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoICh0ZWFtRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHRhc2tzIGZvciB0ZWFtICR7dGVhbU5hbWV9OmAsIHRlYW1FcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBUb3RhbCB0b2RheSdzIHRhc2tzIGZldGNoZWQgZm9yICR7dXNlclByb2ZpbGUucm9sZX06ICR7YWxsVGFza3MubGVuZ3RofWApO1xyXG4gICAgICAgIHJldHVybiBhbGxUYXNrcy5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShiLmRhdGUpIC0gbmV3IERhdGUoYS5kYXRlKSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdGFza3M6JywgZXJyb3IpO1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gLy8gVXBkYXRlIGEgdGFzayAod2l0aCB1c2VyIHBlcm1pc3Npb24gY2hlY2spXHJcbi8vIGV4cG9ydCBjb25zdCB1cGRhdGVUYXNrID0gYXN5bmMgKHRlYW1OYW1lLCBkYXRlLCBlbXBJZCwgdGFza0lkLCB0YXNrRGF0YSwgdXNlclByb2ZpbGUpID0+IHtcclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgICAgLy8gQ2hlY2sgaWYgdXNlciBjYW4gdXBkYXRlIHRoaXMgdGFza1xyXG4vLyAgICAgICAgIGlmICghY2FuVXNlckFjY2Vzc0VtcGxveWVlKHVzZXJQcm9maWxlLCB0ZWFtTmFtZSwgZW1wSWQpKSB7XHJcbi8vICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGRvIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gdXBkYXRlIHRoaXMgdGFzaycpO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgY29uc3QgdGFza1JlZiA9IGRvYyhkYiwgJ3RlYW1zJywgdGVhbU5hbWUsICdkYXRlcycsIGRhdGUsICdlbXBsb3llZXMnLCBlbXBJZCwgJ3Rhc2tzJywgdGFza0lkKTtcclxuLy8gICAgICAgICBhd2FpdCB1cGRhdGVEb2ModGFza1JlZiwge1xyXG4vLyAgICAgICAgICAgICAuLi50YXNrRGF0YSxcclxuLy8gICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbi8vICAgICAgICAgICAgIHVwZGF0ZWRCeTogdXNlclByb2ZpbGUuZW1wSWRcclxuLy8gICAgICAgICB9KTtcclxuLy8gICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgdGFzazonLCBlcnJvcik7XHJcbi8vICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbi8vICAgICB9XHJcbi8vIH07XHJcblxyXG4vLyBEZWxldGUgYSB0YXNrICh3aXRoIHVzZXIgcGVybWlzc2lvbiBjaGVjaylcclxuZXhwb3J0IGNvbnN0IGRlbGV0ZVRhc2sgPSBhc3luYyAodGVhbU5hbWUsIGRhdGUsIGVtcElkLCB0YXNrSWQsIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHVzZXIgY2FuIGRlbGV0ZSB0aGlzIHRhc2tcclxuICAgICAgICBpZiAoIWNhblVzZXJBY2Nlc3NFbXBsb3llZSh1c2VyUHJvZmlsZSwgdGVhbU5hbWUsIGVtcElkKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGRlbGV0ZSB0aGlzIHRhc2snKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRhc2tSZWYgPSBkb2MoZGIsICd0ZWFtcycsIHRlYW1OYW1lLCAnZGF0ZXMnLCBkYXRlLCAnZW1wbG95ZWVzJywgZW1wSWQsICd0YXNrcycsIHRhc2tJZCk7XHJcbiAgICAgICAgYXdhaXQgZGVsZXRlRG9jKHRhc2tSZWYpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyB0YXNrOicsIGVycm9yKTtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIFBFUk1JU1NJT04gSEVMUEVSUyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLy8gQ2hlY2sgaWYgdXNlciBjYW4gYWNjZXNzIHNwZWNpZmljIHRlYW1cclxuZXhwb3J0IGNvbnN0IGNhblVzZXJBY2Nlc3NUZWFtID0gKHVzZXJQcm9maWxlLCB0ZWFtTmFtZSkgPT4ge1xyXG4gICAgaWYgKCF1c2VyUHJvZmlsZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdObyB1c2VyIHByb2ZpbGUgcHJvdmlkZWQnKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coYENoZWNraW5nIGFjY2VzcyBmb3IgdXNlciAke3VzZXJQcm9maWxlLmVtcElkfSAoJHt1c2VyUHJvZmlsZS5yb2xlfSkgdG8gdGVhbSAke3RlYW1OYW1lfWApO1xyXG5cclxuICAgIHN3aXRjaCAodXNlclByb2ZpbGUucm9sZSkge1xyXG4gICAgICAgIGNhc2UgJ3RlY2gtbGVhZCc6XHJcbiAgICAgICAgICAgIC8vIFRlY2ggbGVhZHMgY2FuIGFjY2VzczpcclxuICAgICAgICAgICAgLy8gMS4gVGVhbXMgdGhleSBtYW5hZ2UgKGZyb20gbWFuYWdlZFRlYW1zIGFycmF5KVxyXG4gICAgICAgICAgICAvLyAyLiBUaGUgc3BlY2lhbCAndGVjaExlYWRzJyB0ZWFtIGZvciB0aGVpciBwZXJzb25hbCB0YXNrc1xyXG4gICAgICAgICAgICBjb25zdCBjYW5BY2Nlc3NNYW5hZ2VkVGVhbSA9IHVzZXJQcm9maWxlLm1hbmFnZWRUZWFtcz8uaW5jbHVkZXModGVhbU5hbWUpO1xyXG4gICAgICAgICAgICBjb25zdCBjYW5BY2Nlc3NUZWNoTGVhZHNUZWFtID0gdGVhbU5hbWUgPT09ICd0ZWNoTGVhZHMnO1xyXG4gICAgICAgICAgICBjb25zdCB0ZWNoTGVhZEFjY2VzcyA9IGNhbkFjY2Vzc01hbmFnZWRUZWFtIHx8IGNhbkFjY2Vzc1RlY2hMZWFkc1RlYW07XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVGVjaCBsZWFkIGFjY2VzcyBjaGVjazonLCB7XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VkVGVhbXM6IHVzZXJQcm9maWxlLm1hbmFnZWRUZWFtcyxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RlZFRlYW06IHRlYW1OYW1lLFxyXG4gICAgICAgICAgICAgICAgY2FuQWNjZXNzTWFuYWdlZFRlYW0sXHJcbiAgICAgICAgICAgICAgICBjYW5BY2Nlc3NUZWNoTGVhZHNUZWFtLFxyXG4gICAgICAgICAgICAgICAgZmluYWxBY2Nlc3M6IHRlY2hMZWFkQWNjZXNzXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRlY2hMZWFkQWNjZXNzO1xyXG5cclxuICAgICAgICBjYXNlICd0ZWFtLWxlYWRlcic6XHJcbiAgICAgICAgY2FzZSAndHJhY2stbGVhZCc6IC8vIOKGkCBUcmFjay1MZWFkIGNhbiBhY2Nlc3MgdGhlaXIgb3duIHRlYW1cclxuICAgICAgICBjYXNlICdlbXBsb3llZSc6XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZ3VsYXJBY2Nlc3MgPSB1c2VyUHJvZmlsZS50ZWFtTmFtZSA9PT0gdGVhbU5hbWU7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWd1bGFyIHVzZXIgYWNjZXNzOicsIHtcclxuICAgICAgICAgICAgICAgIHVzZXJUZWFtOiB1c2VyUHJvZmlsZS50ZWFtTmFtZSxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RlZFRlYW06IHRlYW1OYW1lLFxyXG4gICAgICAgICAgICAgICAgYWNjZXNzOiByZWd1bGFyQWNjZXNzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVndWxhckFjY2VzcztcclxuXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1Vua25vd24gcm9sZTonLCB1c2VyUHJvZmlsZS5yb2xlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59O1xyXG5leHBvcnQgY29uc3QgY2FuVXNlckFjY2Vzc0VtcGxveWVlID0gYXN5bmMgKHVzZXJQcm9maWxlLCB0ZWFtTmFtZSwgdGFyZ2V0RW1wSWQpID0+IHtcclxuICAgIGlmICghdXNlclByb2ZpbGUpIHJldHVybiBmYWxzZTtcclxuICAgIGlmICh1c2VyUHJvZmlsZS50ZWFtTmFtZSAhPT0gdGVhbU5hbWUgJiYgdXNlclByb2ZpbGUucm9sZSAhPT0gJ3RlY2gtbGVhZCcpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoICh1c2VyUHJvZmlsZS5yb2xlKSB7XHJcbiAgICAgICAgY2FzZSAndGVjaC1sZWFkJzpcclxuICAgICAgICAgICAgcmV0dXJuIHVzZXJQcm9maWxlLm1hbmFnZWRUZWFtcz8uaW5jbHVkZXModGVhbU5hbWUpO1xyXG4gICAgICAgIGNhc2UgJ3RlYW0tbGVhZGVyJzpcclxuICAgICAgICAgICAgaWYgKHVzZXJQcm9maWxlLnRlYW1OYW1lICE9PSB0ZWFtTmFtZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgY2FzZSAndHJhY2stbGVhZCc6XHJcbiAgICAgICAgICAgIGlmICh1c2VyUHJvZmlsZS50ZWFtTmFtZSAhPT0gdGVhbU5hbWUpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJzUXVlcnkgPSBxdWVyeShcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uKGRiLCAndXNlcnMnKSxcclxuICAgICAgICAgICAgICAgICAgICB3aGVyZSgnZW1wSWQnLCAnPT0nLCB0YXJnZXRFbXBJZClcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvY3ModXNlcnNRdWVyeSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc25hcHNob3QuZW1wdHkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFVzZXIgPSBzbmFwc2hvdC5kb2NzWzBdLmRhdGEoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbkFjY2VzcyA9IHRhcmdldFVzZXIuZW1wSWQgPT09IHVzZXJQcm9maWxlLmVtcElkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHRhcmdldFVzZXIucm9sZSA9PT0gJ2VtcGxveWVlJyAmJiB0YXJnZXRVc2VyLnJlcG9ydHNUbyA9PT0gdXNlclByb2ZpbGUuZW1wSWQpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBjYW5BY2Nlc3M7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBlbXBsb3llZSBhY2Nlc3M6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIGNhc2UgJ2VtcGxveWVlJzpcclxuICAgICAgICAgICAgcmV0dXJuIHVzZXJQcm9maWxlLnRlYW1OYW1lID09PSB0ZWFtTmFtZSAmJiB1c2VyUHJvZmlsZS5lbXBJZCA9PT0gdGFyZ2V0RW1wSWQ7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbi8vIEdldCBhY2Nlc3NpYmxlIHRlYW1zIGZvciBjdXJyZW50IHVzZXJcclxuZXhwb3J0IGNvbnN0IGdldEFjY2Vzc2libGVUZWFtcyA9ICh1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgaWYgKCF1c2VyUHJvZmlsZSkgcmV0dXJuIFtdO1xyXG5cclxuICAgIHN3aXRjaCAodXNlclByb2ZpbGUucm9sZSkge1xyXG4gICAgICAgIGNhc2UgJ3RlY2gtbGVhZCc6XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VyUHJvZmlsZS5tYW5hZ2VkVGVhbXMgfHwgW107XHJcbiAgICAgICAgY2FzZSAndGVhbS1sZWFkZXInOlxyXG4gICAgICAgIGNhc2UgJ3RyYWNrLWxlYWQnOlxyXG4gICAgICAgIGNhc2UgJ2VtcGxveWVlJzpcclxuICAgICAgICAgICAgcmV0dXJuIFt1c2VyUHJvZmlsZS50ZWFtTmFtZV07XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSBGSUxURVIgQkFTRUQgT04gUk9MRVMgLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG5leHBvcnQgY29uc3QgZ2V0RmlsdGVyT3B0aW9ucyA9IGFzeW5jICh1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICB0ZWNoTGVhZHM6IFtdLFxyXG4gICAgICAgICAgICB0ZWFtTGVhZGVyczogW10sXHJcbiAgICAgICAgICAgIHRyYWNrTGVhZHM6IFtdLFxyXG4gICAgICAgICAgICBlbXBsb3llZXM6IFtdLFxyXG4gICAgICAgICAgICB0ZWFtczogW11cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoIXVzZXJQcm9maWxlKSByZXR1cm4gb3B0aW9ucztcclxuXHJcbiAgICAgICAgaWYgKHVzZXJQcm9maWxlLnJvbGUgPT09ICd0ZWNoLWxlYWQnKSB7XHJcbiAgICAgICAgICAgIC8vIFRlY2ggbGVhZHMgY2FuIGZpbHRlciBieSBldmVyeXRoaW5nIGluIHRoZWlyIG1hbmFnZWQgdGVhbXNcclxuICAgICAgICAgICAgb3B0aW9ucy50ZWFtcyA9IHVzZXJQcm9maWxlLm1hbmFnZWRUZWFtcyB8fCBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVzZSBTZXQgZm9yIGRlZHVwbGljYXRpb24gbGlrZSBvbGQgbG9naWNcclxuICAgICAgICAgICAgY29uc3QgdGVjaExlYWRzU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICBjb25zdCB0ZWFtTGVhZGVyc1NldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgY29uc3QgdHJhY2tMZWFkc1NldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgY29uc3QgZW1wbG95ZWVzU2V0ID0gbmV3IFNldCgpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChjb25zdCB0ZWFtTmFtZSBvZiB1c2VyUHJvZmlsZS5tYW5hZ2VkVGVhbXMpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGFsbCB1c2VycyBpbiB0aGlzIHRlYW0gKG1vcmUgZWZmaWNpZW50IHRoYW4gc2VwYXJhdGUgcXVlcmllcylcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2Vyc1F1ZXJ5ID0gcXVlcnkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24oZGIsICd1c2VycycpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVyZSgndGVhbU5hbWUnLCAnPT0nLCB0ZWFtTmFtZSlcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJzU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHVzZXJzUXVlcnkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB1c2Vyc1NuYXBzaG90LmZvckVhY2goZG9jID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGRvYy5kYXRhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1wSWQ6IGRhdGEuZW1wSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbXBOYW1lOiBkYXRhLmVtcE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZWFtTmFtZTogZGF0YS50ZWFtTmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHVuaXF1ZSBrZXkgZm9yIGRlZHVwbGljYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7ZGF0YS5yb2xlfS0ke2RhdGEuZW1wSWR9YDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZGF0YS5yb2xlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZWNoLWxlYWQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVjaExlYWRzU2V0LmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlY2hMZWFkc1NldC5hZGQoSlNPTi5zdHJpbmdpZnkodXNlckRhdGEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZWFtLWxlYWRlcic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZWFtTGVhZGVyc1NldC5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZWFtTGVhZGVyc1NldC5hZGQoSlNPTi5zdHJpbmdpZnkodXNlckRhdGEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0cmFjay1sZWFkJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYWNrTGVhZHNTZXQuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tMZWFkc1NldC5hZGQoSlNPTi5zdHJpbmdpZnkodXNlckRhdGEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlbXBsb3llZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbXBsb3llZXNTZXQuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1wbG95ZWVzU2V0LmFkZChKU09OLnN0cmluZ2lmeSh1c2VyRGF0YSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBkYXRhIGZvciB0ZWFtICR7dGVhbU5hbWV9OmAsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydCBzZXRzIGJhY2sgdG8gYXJyYXlzIHdpdGggY29uc2lzdGVudCBzdHJ1Y3R1cmVcclxuICAgICAgICAgICAgb3B0aW9ucy50ZWNoTGVhZHMgPSBBcnJheS5mcm9tKHRlY2hMZWFkc1NldCkubWFwKEpTT04ucGFyc2UpO1xyXG4gICAgICAgICAgICBvcHRpb25zLnRlYW1MZWFkZXJzID0gQXJyYXkuZnJvbSh0ZWFtTGVhZGVyc1NldCkubWFwKEpTT04ucGFyc2UpO1xyXG4gICAgICAgICAgICBvcHRpb25zLnRyYWNrTGVhZHMgPSBBcnJheS5mcm9tKHRyYWNrTGVhZHNTZXQpLm1hcChKU09OLnBhcnNlKTtcclxuICAgICAgICAgICAgb3B0aW9ucy5lbXBsb3llZXMgPSBBcnJheS5mcm9tKGVtcGxveWVlc1NldCkubWFwKEpTT04ucGFyc2UpO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKHVzZXJQcm9maWxlLnJvbGUgPT09ICd0ZWFtLWxlYWRlcicpIHtcclxuICAgICAgICAgICAgLy8gVGVhbSBsZWFkZXJzIGNhbiBmaWx0ZXIgYnkgdHJhY2stbGVhZHMgYW5kIGVtcGxveWVlcyBpbiB0aGVpciB0ZWFtXHJcbiAgICAgICAgICAgIG9wdGlvbnMudGVhbXMgPSBbdXNlclByb2ZpbGUudGVhbU5hbWVdO1xyXG5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIEdldCB0cmFjay1sZWFkcyAtIFVzZSBTZXQgZm9yIGNvbnNpc3RlbmN5XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja0xlYWRzU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tMZWFkc1F1ZXJ5ID0gcXVlcnkoXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbihkYiwgJ3VzZXJzJyksXHJcbiAgICAgICAgICAgICAgICAgICAgd2hlcmUoJ3JvbGUnLCAnPT0nLCAndHJhY2stbGVhZCcpLFxyXG4gICAgICAgICAgICAgICAgICAgIHdoZXJlKCd0ZWFtTmFtZScsICc9PScsIHVzZXJQcm9maWxlLnRlYW1OYW1lKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrTGVhZHNTbmFwc2hvdCA9IGF3YWl0IGdldERvY3ModHJhY2tMZWFkc1F1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIHRyYWNrTGVhZHNTbmFwc2hvdC5mb3JFYWNoKGRvYyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGRvYy5kYXRhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlckRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcElkOiBkYXRhLmVtcElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbXBOYW1lOiBkYXRhLmVtcE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlYW1OYW1lOiBkYXRhLnRlYW1OYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtkYXRhLnJvbGV9LSR7ZGF0YS5lbXBJZH1gO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJhY2tMZWFkc1NldC5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja0xlYWRzU2V0LmFkZChKU09OLnN0cmluZ2lmeSh1c2VyRGF0YSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy50cmFja0xlYWRzID0gQXJyYXkuZnJvbSh0cmFja0xlYWRzU2V0KS5tYXAoSlNPTi5wYXJzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gR2V0IGVtcGxveWVlcyAtIFVzZSBTZXQgZm9yIGNvbnNpc3RlbmN5XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbXBsb3llZXNTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbXBsb3llZXNRdWVyeSA9IHF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24oZGIsICd1c2VycycpLFxyXG4gICAgICAgICAgICAgICAgICAgIHdoZXJlKCdyb2xlJywgJz09JywgJ2VtcGxveWVlJyksXHJcbiAgICAgICAgICAgICAgICAgICAgd2hlcmUoJ3RlYW1OYW1lJywgJz09JywgdXNlclByb2ZpbGUudGVhbU5hbWUpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW1wbG95ZWVzU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKGVtcGxveWVlc1F1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIGVtcGxveWVlc1NuYXBzaG90LmZvckVhY2goZG9jID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gZG9jLmRhdGEoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1wSWQ6IGRhdGEuZW1wSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcE5hbWU6IGRhdGEuZW1wTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVhbU5hbWU6IGRhdGEudGVhbU5hbWVcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke2RhdGEucm9sZX0tJHtkYXRhLmVtcElkfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbXBsb3llZXNTZXQuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1wbG95ZWVzU2V0LmFkZChKU09OLnN0cmluZ2lmeSh1c2VyRGF0YSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5lbXBsb3llZXMgPSBBcnJheS5mcm9tKGVtcGxveWVlc1NldCkubWFwKEpTT04ucGFyc2UpO1xyXG5cclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHRlYW0tbGVhZGVyIGZpbHRlciBvcHRpb25zOicsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMudHJhY2tMZWFkcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5lbXBsb3llZXMgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKHVzZXJQcm9maWxlLnJvbGUgPT09ICd0cmFjay1sZWFkJykge1xyXG4gICAgICAgICAgICAvLyBUcmFjayBsZWFkcyBjYW4gZmlsdGVyIGJ5IHRoZWlyIGRpcmVjdCByZXBvcnRzIChlbXBsb3llZXMpXHJcbiAgICAgICAgICAgIG9wdGlvbnMudGVhbXMgPSBbdXNlclByb2ZpbGUudGVhbU5hbWVdO1xyXG5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIEdldCBlbXBsb3llZXMgd2hvIHJlcG9ydCB0byB0aGlzIHRyYWNrLWxlYWQgLSBoaWVyYXJjaHktYXdhcmVcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVtcGxveWVlc1NldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVtcGxveWVlc1F1ZXJ5ID0gcXVlcnkoXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbihkYiwgJ3VzZXJzJyksXHJcbiAgICAgICAgICAgICAgICAgICAgd2hlcmUoJ3JvbGUnLCAnPT0nLCAnZW1wbG95ZWUnKSxcclxuICAgICAgICAgICAgICAgICAgICB3aGVyZSgndGVhbU5hbWUnLCAnPT0nLCB1c2VyUHJvZmlsZS50ZWFtTmFtZSksXHJcbiAgICAgICAgICAgICAgICAgICAgd2hlcmUoJ3JlcG9ydHNUbycsICc9PScsIHVzZXJQcm9maWxlLmVtcElkKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVtcGxveWVlc1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhlbXBsb3llZXNRdWVyeSk7XHJcbiAgICAgICAgICAgICAgICBlbXBsb3llZXNTbmFwc2hvdC5mb3JFYWNoKGRvYyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGRvYy5kYXRhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlckRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcElkOiBkYXRhLmVtcElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbXBOYW1lOiBkYXRhLmVtcE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlYW1OYW1lOiBkYXRhLnRlYW1OYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtkYXRhLnJvbGV9LSR7ZGF0YS5lbXBJZH1gO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZW1wbG95ZWVzU2V0LmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcGxveWVlc1NldC5hZGQoSlNPTi5zdHJpbmdpZnkodXNlckRhdGEpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZW1wbG95ZWVzID0gQXJyYXkuZnJvbShlbXBsb3llZXNTZXQpLm1hcChKU09OLnBhcnNlKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHRyYWNrLWxlYWQgZmlsdGVyIG9wdGlvbnM6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5lbXBsb3llZXMgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKHVzZXJQcm9maWxlLnJvbGUgPT09ICdlbXBsb3llZScpIHtcclxuICAgICAgICAgICAgLy8gRW1wbG95ZWVzIGNhbiBvbmx5IGZpbHRlciBieSB0aGVtc2VsdmVzXHJcbiAgICAgICAgICAgIG9wdGlvbnMudGVhbXMgPSBbdXNlclByb2ZpbGUudGVhbU5hbWVdO1xyXG4gICAgICAgICAgICBvcHRpb25zLmVtcGxveWVlcyA9IFt7XHJcbiAgICAgICAgICAgICAgICBlbXBJZDogdXNlclByb2ZpbGUuZW1wSWQsXHJcbiAgICAgICAgICAgICAgICBlbXBOYW1lOiB1c2VyUHJvZmlsZS5lbXBOYW1lLFxyXG4gICAgICAgICAgICAgICAgdGVhbU5hbWU6IHVzZXJQcm9maWxlLnRlYW1OYW1lXHJcbiAgICAgICAgICAgIH1dO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgZmlsdGVyIG9wdGlvbnM6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRlY2hMZWFkczogW10sXHJcbiAgICAgICAgICAgIHRlYW1MZWFkZXJzOiBbXSxcclxuICAgICAgICAgICAgdHJhY2tMZWFkczogW10sXHJcbiAgICAgICAgICAgIGVtcGxveWVlczogW10sXHJcbiAgICAgICAgICAgIHRlYW1zOiBbXVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0gR2V0IFdlZWtseSBUYXNrIEZvciBDdXJyZW50IFVzZXIgT25seSEhISAtLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuZXhwb3J0IGNvbnN0IGdldFRhc2tzRm9yRGF0ZVJhbmdlID0gYXN5bmMgKHVzZXJQcm9maWxlLCBzdGFydERhdGUsIGVuZERhdGUsIHRlYW1GaWx0ZXIgPSBudWxsLCBlbXBJZEZpbHRlciA9IG51bGwpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCF1c2VyUHJvZmlsZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgcHJvZmlsZSBpcyByZXF1aXJlZCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGFsbFRhc2tzID0gW107XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSB3aGljaCB0ZWFtcyB1c2VyIGNhbiBhY2Nlc3NcclxuICAgICAgICBsZXQgYWNjZXNzaWJsZVRlYW1zO1xyXG4gICAgICAgIHN3aXRjaCAodXNlclByb2ZpbGUucm9sZSkge1xyXG4gICAgICAgICAgICBjYXNlICd0ZWNoLWxlYWQnOlxyXG4gICAgICAgICAgICAgICAgYWNjZXNzaWJsZVRlYW1zID0gWy4uLih1c2VyUHJvZmlsZS5tYW5hZ2VkVGVhbXMgfHwgW10pLCAndGVjaExlYWRzJ107XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAndGVhbS1sZWFkZXInOlxyXG4gICAgICAgICAgICBjYXNlICd0cmFjay1sZWFkJzpcclxuICAgICAgICAgICAgY2FzZSAnZW1wbG95ZWUnOlxyXG4gICAgICAgICAgICAgICAgYWNjZXNzaWJsZVRlYW1zID0gW3VzZXJQcm9maWxlLnRlYW1OYW1lXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXBwbHkgdGVhbSBmaWx0ZXIgaWYgcHJvdmlkZWQgYW5kIGFjY2Vzc2libGVcclxuICAgICAgICBpZiAodGVhbUZpbHRlciAmJiBhY2Nlc3NpYmxlVGVhbXMuaW5jbHVkZXModGVhbUZpbHRlcikpIHtcclxuICAgICAgICAgICAgYWNjZXNzaWJsZVRlYW1zID0gW3RlYW1GaWx0ZXJdO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGVhbUZpbHRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gW107IC8vIEludmFsaWQgdGVhbSBmaWx0ZXJcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEdlbmVyYXRlIGRhdGUgcmFuZ2VcclxuICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKHN0YXJ0RGF0ZSk7XHJcbiAgICAgICAgY29uc3QgZW5kID0gbmV3IERhdGUoZW5kRGF0ZSk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGQgPSBuZXcgRGF0ZShzdGFydCk7IGQgPD0gZW5kOyBkLnNldERhdGUoZC5nZXREYXRlKCkgKyAxKSkge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRlID0gZm9ybWF0KGQsICd5eXl5LU1NLWRkJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBGZXRjaCB0YXNrcyBmcm9tIGFjY2Vzc2libGUgdGVhbXMgZm9yIHRoaXMgZGF0ZVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRlYW1OYW1lIG9mIGFjY2Vzc2libGVUZWFtcykge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbXBsb3llZXNTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24oZGIsICd0ZWFtcycsIHRlYW1OYW1lLCAnZGF0ZXMnLCBkYXRlLCAnZW1wbG95ZWVzJylcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVtcERvYyBvZiBlbXBsb3llZXNTbmFwc2hvdC5kb2NzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVtcElkID0gZW1wRG9jLmlkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgZW1wSWRGaWx0ZXIgaWYgcHJvdmlkZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVtcElkRmlsdGVyICYmIGVtcElkICE9PSBlbXBJZEZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGFjY2Vzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW5BY2Nlc3MgPSBhd2FpdCBjYW5Vc2VyQWNjZXNzRW1wbG95ZWUodXNlclByb2ZpbGUsIHRlYW1OYW1lLCBlbXBJZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbkFjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhc2tzU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbihkYiwgJ3RlYW1zJywgdGVhbU5hbWUsICdkYXRlcycsIGRhdGUsICdlbXBsb3llZXMnLCBlbXBJZCwgJ3Rhc2tzJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVtcFRhc2tzID0gdGFza3NTbmFwc2hvdC5kb2NzLm1hcCh0YXNrRG9jID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZWFtTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbXBJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhc2tEb2MuZGF0YSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRhc2tEb2MuaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsVGFza3MgPSBbLi4uYWxsVGFza3MsIC4uLmVtcFRhc2tzXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh0ZWFtRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyB0YXNrcyBmb3IgdGVhbSAke3RlYW1OYW1lfSBvbiAke2RhdGV9OmAsIHRlYW1FcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhbGxUYXNrcy5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShhLmRhdGUpIC0gbmV3IERhdGUoYi5kYXRlKSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdGFza3MgZm9yIGRhdGUgcmFuZ2U6JywgZXJyb3IpO1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGFwcGx5VGFza0ZpbHRlcnMgPSAodGFza3MsIGZpbHRlcnMsIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICBpZiAoIXRhc2tzIHx8IHRhc2tzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRhc2tzO1xyXG5cclxuICAgIGxldCBmaWx0ZXJlZFRhc2tzID0gWy4uLnRhc2tzXTtcclxuXHJcbiAgICAvLyBTdGF0dXMgZmlsdGVyXHJcbiAgICBpZiAoZmlsdGVycy5zdGF0dXMpIHtcclxuICAgICAgICBmaWx0ZXJlZFRhc2tzID0gZmlsdGVyZWRUYXNrcy5maWx0ZXIodGFzayA9PiB0YXNrLnN0YXR1cyA9PT0gZmlsdGVycy5zdGF0dXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFdvcmsgdHlwZSBmaWx0ZXJcclxuICAgIGlmIChmaWx0ZXJzLndvcmtUeXBlKSB7XHJcbiAgICAgICAgZmlsdGVyZWRUYXNrcyA9IGZpbHRlcmVkVGFza3MuZmlsdGVyKHRhc2sgPT4gdGFzay53b3JrVHlwZSA9PT0gZmlsdGVycy53b3JrVHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJvZ3Jlc3MgZmlsdGVyXHJcbiAgICBpZiAoZmlsdGVycy5wZXJjZW50YWdlQ29tcGxldGlvbikge1xyXG4gICAgICAgIGNvbnN0IFttaW4sIG1heF0gPSBmaWx0ZXJzLnBlcmNlbnRhZ2VDb21wbGV0aW9uLnNwbGl0KCctJykubWFwKE51bWJlcik7XHJcbiAgICAgICAgZmlsdGVyZWRUYXNrcyA9IGZpbHRlcmVkVGFza3MuZmlsdGVyKHRhc2sgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IHBhcnNlSW50KHRhc2sucGVyY2VudGFnZUNvbXBsZXRpb24pIHx8IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9ncmVzcyA+PSBtaW4gJiYgcHJvZ3Jlc3MgPD0gbWF4O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRlYW0gZmlsdGVyIChvbmx5IGZvciB0ZWNoIGxlYWRzKVxyXG4gICAgaWYgKGZpbHRlcnMudGVhbSAmJiB1c2VyUHJvZmlsZS5yb2xlID09PSAndGVjaC1sZWFkJykge1xyXG4gICAgICAgIGZpbHRlcmVkVGFza3MgPSBmaWx0ZXJlZFRhc2tzLmZpbHRlcih0YXNrID0+IHRhc2sudGVhbU5hbWUgPT09IGZpbHRlcnMudGVhbSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZpbHRlcmVkVGFza3M7XHJcbn07XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRlYW0gbGVhZGVyIGZvciBhIHRlYW1cclxuY29uc3QgZ2V0VGVhbUxlYWRlckZvclRlYW0gPSBhc3luYyAodGVhbU5hbWUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgdGVhbURvYyA9IGF3YWl0IGdldERvYyhkb2MoZGIsICd0ZWFtcycsIHRlYW1OYW1lKSk7XHJcbiAgICAgICAgaWYgKHRlYW1Eb2MuZXhpc3RzKCkgJiYgdGVhbURvYy5kYXRhKCkudGVhbUxlYWRlcklkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZWFtRG9jLmRhdGEoKS50ZWFtTGVhZGVySWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHRlYW0gbGVhZGVyIGZvciB0ZWFtOicsIHRlYW1OYW1lLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBHZXQgZmlsdGVyZWQgdGFza3Mgd2l0aCBhbGwgYXBwbGllZCBmaWx0ZXJzXHJcbmV4cG9ydCBjb25zdCBnZXRGaWx0ZXJlZFRhc2tzID0gYXN5bmMgKHVzZXJQcm9maWxlLCBmaWx0ZXJzID0ge30pID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gRmlyc3QgZ2V0IGFsbCBhY2Nlc3NpYmxlIHRhc2tzXHJcbiAgICAgICAgY29uc3QgYWxsVGFza3MgPSBhd2FpdCBnZXRUYXNrcyh1c2VyUHJvZmlsZSk7XHJcblxyXG4gICAgICAgIC8vIFRoZW4gYXBwbHkgZmlsdGVyc1xyXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkVGFza3MgPSBhcHBseVRhc2tGaWx0ZXJzKGFsbFRhc2tzLCBmaWx0ZXJzLCB1c2VyUHJvZmlsZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBmaWx0ZXJlZFRhc2tzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGZpbHRlcmVkIHRhc2tzOicsIGVycm9yKTtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0gRFJPUERPV05TIFdJVEggVVNFUiBDT05URVhUIC0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vLyBHZXQgZHJvcGRvd24gZGF0YSBmb3IgYSB0ZWFtICh3aXRoIHVzZXIgcGVybWlzc2lvbiBjaGVjaylcclxuZXhwb3J0IGNvbnN0IGdldFRlYW1Ecm9wZG93bkRhdGEgPSBhc3luYyAodGVhbU5hbWUsIGZpZWxkLCB1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBDaGVjayBpZiB1c2VyIGNhbiBhY2Nlc3MgdGhpcyB0ZWFtXHJcbiAgICAgICAgaWYgKCFjYW5Vc2VyQWNjZXNzVGVhbSh1c2VyUHJvZmlsZSwgdGVhbU5hbWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGRvIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gYWNjZXNzIHRoaXMgdGVhbSBkYXRhJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXR1cm4gcHJlZGVmaW5lZCB2YWx1ZXMgZm9yIHNwZWNpZmljIGZpZWxkcyAtIHNhbWUgZm9yIGFsbCB1c2Vyc1xyXG4gICAgICAgIGlmIChQUkVERUZJTkVEX1ZBTFVFU1tmaWVsZF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBSRURFRklORURfVkFMVUVTW2ZpZWxkXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZvciBjdXN0b20gZHJvcGRvd24gZGF0YSwgZmV0Y2ggZnJvbSBGaXJlc3RvcmVcclxuICAgICAgICBjb25zdCBkb2NSZWYgPSBkb2MoZGIsICd0ZWFtcycsIHRlYW1OYW1lLCAnZHJvcGRvd25EYXRhJywgZmllbGQpO1xyXG4gICAgICAgIGNvbnN0IGRvY1NuYXAgPSBhd2FpdCBnZXREb2MoZG9jUmVmKTtcclxuICAgICAgICBpZiAoZG9jU25hcC5leGlzdHMoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZG9jU25hcC5kYXRhKCkudmFsdWVzIHx8IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdGVhbSBkcm9wZG93biBkYXRhOicsIGVycm9yKTtcclxuICAgICAgICAvLyBBbHdheXMgcmV0dXJuIHByZWRlZmluZWQgdmFsdWVzIGFzIGZhbGxiYWNrXHJcbiAgICAgICAgcmV0dXJuIFBSRURFRklORURfVkFMVUVTW2ZpZWxkXSB8fCBbXTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIFNhdmUgZHJvcGRvd24gZGF0YSBmb3IgYSB0ZWFtICh3aXRoIHVzZXIgcGVybWlzc2lvbiBjaGVjaylcclxuZXhwb3J0IGNvbnN0IHNhdmVUZWFtRHJvcGRvd25EYXRhID0gYXN5bmMgKHRlYW1OYW1lLCBmaWVsZCwgdmFsdWVzLCB1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBDaGVjayBpZiB1c2VyIGNhbiBtb2RpZnkgdGhpcyB0ZWFtIGRhdGEgKG9ubHkgdGVhbSBsZWFkZXJzIGFuZCB0ZWNoIGxlYWRzKVxyXG4gICAgICAgIGlmICghY2FuVXNlckFjY2Vzc1RlYW0odXNlclByb2ZpbGUsIHRlYW1OYW1lKSB8fCB1c2VyUHJvZmlsZS5yb2xlID09PSAnZW1wbG95ZWUnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGRvIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gbW9kaWZ5IHRlYW0gZGF0YScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRG9uJ3Qgc2F2ZSBwcmVkZWZpbmVkIHZhbHVlcyB0byBkYXRhYmFzZVxyXG4gICAgICAgIGlmIChQUkVERUZJTkVEX1ZBTFVFU1tmaWVsZF0pIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBDYW5ub3Qgc2F2ZSBwcmVkZWZpbmVkIHZhbHVlcyBmb3IgZmllbGQ6ICR7ZmllbGR9YCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGRvY1JlZiA9IGRvYyhkYiwgJ3RlYW1zJywgdGVhbU5hbWUsICdkcm9wZG93bkRhdGEnLCBmaWVsZCk7XHJcbiAgICAgICAgYXdhaXQgc2V0RG9jKGRvY1JlZiwgeyB2YWx1ZXMgfSwgeyBtZXJnZTogdHJ1ZSB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIHRlYW0gZHJvcGRvd24gZGF0YTonLCBlcnJvcik7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSBURUFNUyBXSVRIIFVTRVIgQ09OVEVYVCAtLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLy8gR2V0IHRlYW1zIGFjY2Vzc2libGUgdG8gdXNlclxyXG5leHBvcnQgY29uc3QgZ2V0VGVhbXMgPSBhc3luYyAodXNlclByb2ZpbGUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCF1c2VyUHJvZmlsZSkgcmV0dXJuIFtdO1xyXG4gICAgICAgIHJldHVybiBnZXRBY2Nlc3NpYmxlVGVhbXModXNlclByb2ZpbGUpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHRlYW1zOicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSBQUk9KRUNUUyBXSVRIIFVTRVIgQ09OVEVYVCAtLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLy8gR2V0IHRlYW0tc3BlY2lmaWMgcHJvamVjdHMgKHdpdGggdXNlciBwZXJtaXNzaW9uIGNoZWNrKVxyXG5leHBvcnQgY29uc3QgZ2V0VGVhbVByb2plY3RzID0gYXN5bmMgKHRlYW1OYW1lLCB1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoIWNhblVzZXJBY2Nlc3NUZWFtKHVzZXJQcm9maWxlLCB0ZWFtTmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXdhaXQgZ2V0VGVhbURyb3Bkb3duRGF0YSh0ZWFtTmFtZSwgJ3Byb2plY3RzJywgdXNlclByb2ZpbGUpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHRlYW0gcHJvamVjdHM6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIEFkZCBuZXcgcHJvamVjdCB0byB0ZWFtICh3aXRoIHVzZXIgcGVybWlzc2lvbiBjaGVjaylcclxuZXhwb3J0IGNvbnN0IGFkZFRlYW1Qcm9qZWN0ID0gYXN5bmMgKHRlYW1OYW1lLCBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCB1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoIXByb2plY3RJZCB8fCAhcHJvamVjdE5hbWUpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKCFjYW5Vc2VyQWNjZXNzVGVhbSh1c2VyUHJvZmlsZSwgdGVhbU5hbWUpIHx8IHVzZXJQcm9maWxlLnJvbGUgPT09ICdlbXBsb3llZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyBTaWxlbnRseSBmYWlsIGZvciBlbXBsb3llZXNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHByb2plY3RzID0gYXdhaXQgZ2V0VGVhbVByb2plY3RzKHRlYW1OYW1lLCB1c2VyUHJvZmlsZSk7XHJcbiAgICAgICAgY29uc3QgZXhpc3RzID0gcHJvamVjdHMuZmluZChwID0+IHAuaWQgPT09IHByb2plY3RJZCk7XHJcbiAgICAgICAgaWYgKCFleGlzdHMpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3UHJvamVjdHMgPSBbLi4ucHJvamVjdHMsIHsgaWQ6IHByb2plY3RJZCwgbmFtZTogcHJvamVjdE5hbWUgfV07XHJcbiAgICAgICAgICAgIGF3YWl0IHNhdmVUZWFtRHJvcGRvd25EYXRhKHRlYW1OYW1lLCAncHJvamVjdHMnLCBuZXdQcm9qZWN0cywgdXNlclByb2ZpbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHRlYW0gcHJvamVjdDonLCBlcnJvcik7XHJcbiAgICAgICAgLy8gRG9uJ3QgdGhyb3cgZXJyb3IgdG8gcHJldmVudCB0YXNrIGNyZWF0aW9uIGZhaWx1cmVcclxuICAgIH1cclxufTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIEVNUExPWUVFUyBXSVRIIFVTRVIgQ09OVEVYVCAtLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLy8gR2V0IHRlYW0tc3BlY2lmaWMgZW1wbG95ZWVzICh3aXRoIHVzZXIgcGVybWlzc2lvbiBjaGVjaylcclxuZXhwb3J0IGNvbnN0IGdldFRlYW1FbXBsb3llZXMgPSBhc3luYyAodGVhbU5hbWUsIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICghY2FuVXNlckFjY2Vzc1RlYW0odXNlclByb2ZpbGUsIHRlYW1OYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhd2FpdCBnZXRUZWFtRHJvcGRvd25EYXRhKHRlYW1OYW1lLCAnZW1wbG95ZWVzJywgdXNlclByb2ZpbGUpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHRlYW0gZW1wbG95ZWVzOicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBBZGQgbmV3IGVtcGxveWVlIHRvIHRlYW0gKHdpdGggdXNlciBwZXJtaXNzaW9uIGNoZWNrKVxyXG5leHBvcnQgY29uc3QgYWRkVGVhbUVtcGxveWVlID0gYXN5bmMgKHRlYW1OYW1lLCBlbXBJZCwgZW1wTmFtZSwgdXNlclByb2ZpbGUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCFlbXBJZCB8fCAhZW1wTmFtZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAoIWNhblVzZXJBY2Nlc3NUZWFtKHVzZXJQcm9maWxlLCB0ZWFtTmFtZSkgfHwgdXNlclByb2ZpbGUucm9sZSA9PT0gJ2VtcGxveWVlJykge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIFNpbGVudGx5IGZhaWwgZm9yIGVtcGxveWVlc1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZW1wbG95ZWVzID0gYXdhaXQgZ2V0VGVhbUVtcGxveWVlcyh0ZWFtTmFtZSwgdXNlclByb2ZpbGUpO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IGVtcGxveWVlcy5maW5kKGUgPT4gZS5pZCA9PT0gZW1wSWQpO1xyXG4gICAgICAgIGlmICghZXhpc3RzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0VtcGxveWVlcyA9IFsuLi5lbXBsb3llZXMsIHsgaWQ6IGVtcElkLCBuYW1lOiBlbXBOYW1lIH1dO1xyXG4gICAgICAgICAgICBhd2FpdCBzYXZlVGVhbURyb3Bkb3duRGF0YSh0ZWFtTmFtZSwgJ2VtcGxveWVlcycsIG5ld0VtcGxveWVlcywgdXNlclByb2ZpbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHRlYW0gZW1wbG95ZWU6JywgZXJyb3IpO1xyXG4gICAgICAgIC8vIERvbid0IHRocm93IGVycm9yIHRvIHByZXZlbnQgdGFzayBjcmVhdGlvbiBmYWlsdXJlXHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSBDTElFTlRTIFdJVEggVVNFUiBDT05URVhUIC0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vLyBHZXQgdGVhbS1zcGVjaWZpYyBjbGllbnRzICh3aXRoIHVzZXIgcGVybWlzc2lvbiBjaGVjaylcclxuZXhwb3J0IGNvbnN0IGdldFRlYW1DbGllbnRzID0gYXN5bmMgKHRlYW1OYW1lLCB1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoIWNhblVzZXJBY2Nlc3NUZWFtKHVzZXJQcm9maWxlLCB0ZWFtTmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXdhaXQgZ2V0VGVhbURyb3Bkb3duRGF0YSh0ZWFtTmFtZSwgJ2NsaWVudHMnLCB1c2VyUHJvZmlsZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdGVhbSBjbGllbnRzOicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBBZGQgbmV3IGNsaWVudCB0byB0ZWFtICh3aXRoIHVzZXIgcGVybWlzc2lvbiBjaGVjaylcclxuZXhwb3J0IGNvbnN0IGFkZFRlYW1DbGllbnQgPSBhc3luYyAodGVhbU5hbWUsIGNsaWVudElkLCBjbGllbnROYW1lLCB1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoIWNsaWVudElkIHx8ICFjbGllbnROYW1lKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmICghY2FuVXNlckFjY2Vzc1RlYW0odXNlclByb2ZpbGUsIHRlYW1OYW1lKSB8fCB1c2VyUHJvZmlsZS5yb2xlID09PSAnZW1wbG95ZWUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gU2lsZW50bHkgZmFpbCBmb3IgZW1wbG95ZWVzXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjbGllbnRzID0gYXdhaXQgZ2V0VGVhbUNsaWVudHModGVhbU5hbWUsIHVzZXJQcm9maWxlKTtcclxuICAgICAgICBjb25zdCBleGlzdHMgPSBjbGllbnRzLmZpbmQoYyA9PiBjLmlkID09PSBjbGllbnRJZCk7XHJcbiAgICAgICAgaWYgKCFleGlzdHMpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2xpZW50cyA9IFsuLi5jbGllbnRzLCB7IGlkOiBjbGllbnRJZCwgbmFtZTogY2xpZW50TmFtZSB9XTtcclxuICAgICAgICAgICAgYXdhaXQgc2F2ZVRlYW1Ecm9wZG93bkRhdGEodGVhbU5hbWUsICdjbGllbnRzJywgbmV3Q2xpZW50cywgdXNlclByb2ZpbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHRlYW0gY2xpZW50OicsIGVycm9yKTtcclxuICAgICAgICAvLyBEb24ndCB0aHJvdyBlcnJvciB0byBwcmV2ZW50IHRhc2sgY3JlYXRpb24gZmFpbHVyZVxyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0gVVRJTElUWSBGVU5DVElPTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8vIEdldCBwcmVkZWZpbmVkIHZhbHVlcyBmb3IgYSBzcGVjaWZpYyBmaWVsZFxyXG5leHBvcnQgY29uc3QgZ2V0UHJlZGVmaW5lZFZhbHVlcyA9IChmaWVsZCkgPT4ge1xyXG4gICAgcmV0dXJuIFBSRURFRklORURfVkFMVUVTW2ZpZWxkXSB8fCBbXTtcclxufTtcclxuXHJcbi8vIENoZWNrIGlmIGZpZWxkIGhhcyBwcmVkZWZpbmVkIHZhbHVlc1xyXG5leHBvcnQgY29uc3QgaXNQcmVkZWZpbmVkRmllbGQgPSAoZmllbGQpID0+IHtcclxuICAgIHJldHVybiAhIVBSRURFRklORURfVkFMVUVTW2ZpZWxkXTtcclxufTtcclxuXHJcbi8vIENoZWNrIGlmIHRlYW0gZG9jdW1lbnQgZXhpc3RzXHJcbmV4cG9ydCBjb25zdCB0ZWFtRXhpc3RzID0gYXN5bmMgKHRlYW1OYW1lKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHRlYW1Eb2MgPSBhd2FpdCBnZXREb2MoZG9jKGRiLCAndGVhbXMnLCB0ZWFtTmFtZSkpO1xyXG4gICAgICAgIHJldHVybiB0ZWFtRG9jLmV4aXN0cygpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBJbml0aWFsaXplIGRlZmF1bHQgZHJvcGRvd24gdmFsdWVzIGZvciBhIHRlYW0gKG9ubHkgaWYgdGVhbSBkb2Vzbid0IGV4aXN0IHlldClcclxuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVUZWFtRGVmYXVsdHMgPSBhc3luYyAodGVhbU5hbWUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZXhpc3RzID0gYXdhaXQgdGVhbUV4aXN0cyh0ZWFtTmFtZSk7XHJcbiAgICAgICAgaWYgKCFleGlzdHMpIHtcclxuICAgICAgICAgICAgYXdhaXQgc2V0RG9jKGRvYyhkYiwgJ3RlYW1zJywgdGVhbU5hbWUpLCB7IGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIHRlYW0gZGVmYXVsdHM6JywgZXJyb3IpO1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG59OyJdLCJuYW1lcyI6WyJkYiIsImNvbGxlY3Rpb24iLCJhZGREb2MiLCJnZXREb2NzIiwiZG9jIiwidXBkYXRlRG9jIiwiZGVsZXRlRG9jIiwiZ2V0RG9jIiwic2V0RG9jIiwicXVlcnkiLCJ3aGVyZSIsImZvcm1hdCIsIlBSRURFRklORURfVkFMVUVTIiwicGVyY2VudGFnZUNvbXBsZXRpb24iLCJzdGF0dXMiLCJ3b3JrVHlwZSIsImdldFVzZXJQcm9maWxlIiwidXNlcklkIiwidXNlckRvYyIsImV4aXN0cyIsImRhdGEiLCJlcnJvciIsImNvbnNvbGUiLCJ1cGRhdGVVc2VyUHJvZmlsZSIsInByb2ZpbGVEYXRhIiwibWVyZ2UiLCJhZGRUYXNrIiwidGFzayIsInVzZXJQcm9maWxlIiwicm9sZSIsInRlYW1OYW1lIiwiY2FuVXNlckFjY2Vzc0VtcGxveWVlIiwiZW1wSWQiLCJFcnJvciIsImluaXRpYWxpemVUZWFtRGVmYXVsdHMiLCJkYXRlUmVmIiwiZGF0ZSIsImNyZWF0ZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImVtcFJlZiIsIm5hbWUiLCJlbXBOYW1lIiwiYWRkVGVhbUVtcGxveWVlIiwiY2xpZW50SWQiLCJjbGllbnROYW1lIiwiYWRkVGVhbUNsaWVudCIsInByb2plY3RJZCIsInByb2plY3ROYW1lIiwiYWRkVGVhbVByb2plY3QiLCJ0YXNrRGF0YSIsImNyZWF0ZWRCeSIsImRvY1JlZiIsImlkIiwidXBkYXRlVGFzayIsInRhc2tJZCIsInRhc2tSZWYiLCJ1cGRhdGVkQXQiLCJ1cGRhdGVkQnkiLCJnZXRUYXNrcyIsInRlYW1GaWx0ZXIiLCJhbGxUYXNrcyIsInRvZGF5IiwiYWNjZXNzaWJsZVRlYW1zIiwibWFuYWdlZFRlYW1zIiwiZmlsdGVyIiwidGVhbSIsImxvZyIsImVtcGxveWVlc1NuYXBzaG90IiwiZW1wRG9jIiwiZG9jcyIsImNhbkFjY2VzcyIsInRhc2tzU25hcHNob3QiLCJlbXBUYXNrcyIsIm1hcCIsInRhc2tEb2MiLCJsZW5ndGgiLCJ0ZWFtRXJyb3IiLCJzb3J0IiwiYSIsImIiLCJkZWxldGVUYXNrIiwiY2FuVXNlckFjY2Vzc1RlYW0iLCJjYW5BY2Nlc3NNYW5hZ2VkVGVhbSIsImluY2x1ZGVzIiwiY2FuQWNjZXNzVGVjaExlYWRzVGVhbSIsInRlY2hMZWFkQWNjZXNzIiwicmVxdWVzdGVkVGVhbSIsImZpbmFsQWNjZXNzIiwicmVndWxhckFjY2VzcyIsInVzZXJUZWFtIiwiYWNjZXNzIiwidGFyZ2V0RW1wSWQiLCJ1c2Vyc1F1ZXJ5Iiwic25hcHNob3QiLCJlbXB0eSIsInRhcmdldFVzZXIiLCJyZXBvcnRzVG8iLCJnZXRBY2Nlc3NpYmxlVGVhbXMiLCJnZXRGaWx0ZXJPcHRpb25zIiwib3B0aW9ucyIsInRlY2hMZWFkcyIsInRlYW1MZWFkZXJzIiwidHJhY2tMZWFkcyIsImVtcGxveWVlcyIsInRlYW1zIiwidGVjaExlYWRzU2V0IiwiU2V0IiwidGVhbUxlYWRlcnNTZXQiLCJ0cmFja0xlYWRzU2V0IiwiZW1wbG95ZWVzU2V0IiwidXNlcnNTbmFwc2hvdCIsImZvckVhY2giLCJ1c2VyRGF0YSIsImtleSIsImhhcyIsImFkZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJBcnJheSIsImZyb20iLCJwYXJzZSIsInRyYWNrTGVhZHNRdWVyeSIsInRyYWNrTGVhZHNTbmFwc2hvdCIsImVtcGxveWVlc1F1ZXJ5IiwiZ2V0VGFza3NGb3JEYXRlUmFuZ2UiLCJzdGFydERhdGUiLCJlbmREYXRlIiwiZW1wSWRGaWx0ZXIiLCJzdGFydCIsImVuZCIsImQiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsImFwcGx5VGFza0ZpbHRlcnMiLCJ0YXNrcyIsImZpbHRlcnMiLCJmaWx0ZXJlZFRhc2tzIiwibWluIiwibWF4Iiwic3BsaXQiLCJOdW1iZXIiLCJwcm9ncmVzcyIsInBhcnNlSW50IiwiZ2V0VGVhbUxlYWRlckZvclRlYW0iLCJ0ZWFtRG9jIiwidGVhbUxlYWRlcklkIiwiZ2V0RmlsdGVyZWRUYXNrcyIsImdldFRlYW1Ecm9wZG93bkRhdGEiLCJmaWVsZCIsImRvY1NuYXAiLCJ2YWx1ZXMiLCJzYXZlVGVhbURyb3Bkb3duRGF0YSIsIndhcm4iLCJnZXRUZWFtcyIsImdldFRlYW1Qcm9qZWN0cyIsInByb2plY3RzIiwiZmluZCIsInAiLCJuZXdQcm9qZWN0cyIsImdldFRlYW1FbXBsb3llZXMiLCJlIiwibmV3RW1wbG95ZWVzIiwiZ2V0VGVhbUNsaWVudHMiLCJjbGllbnRzIiwiYyIsIm5ld0NsaWVudHMiLCJnZXRQcmVkZWZpbmVkVmFsdWVzIiwiaXNQcmVkZWZpbmVkRmllbGQiLCJ0ZWFtRXhpc3RzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./lib/firebase.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/__barrel_optimize__?names=format!=!./node_modules/date-fns/index.js":
/*!***************************************************************************!*\
  !*** __barrel_optimize__?names=format!=!./node_modules/date-fns/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   format: () => (/* reexport safe */ C_saurabh_Projects_Advanced_GenAI_TaskHive_node_modules_date_fns_format_js__WEBPACK_IMPORTED_MODULE_0__.format)
/* harmony export */ });
/* harmony import */ var C_saurabh_Projects_Advanced_GenAI_TaskHive_node_modules_date_fns_format_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/date-fns/format.js */ "(pages-dir-browser)/./node_modules/date-fns/format.js");



/***/ })

});