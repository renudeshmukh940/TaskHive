"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./lib/firebase.js":
/*!*************************!*\
  !*** ./lib/firebase.js ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addTask: () => (/* binding */ addTask),\n/* harmony export */   addTeamClient: () => (/* binding */ addTeamClient),\n/* harmony export */   addTeamEmployee: () => (/* binding */ addTeamEmployee),\n/* harmony export */   addTeamProject: () => (/* binding */ addTeamProject),\n/* harmony export */   applyTaskFilters: () => (/* binding */ applyTaskFilters),\n/* harmony export */   canUserAccessEmployee: () => (/* binding */ canUserAccessEmployee),\n/* harmony export */   canUserAccessTeam: () => (/* binding */ canUserAccessTeam),\n/* harmony export */   deleteTask: () => (/* binding */ deleteTask),\n/* harmony export */   getAccessibleTeams: () => (/* binding */ getAccessibleTeams),\n/* harmony export */   getFilterOptions: () => (/* binding */ getFilterOptions),\n/* harmony export */   getFilteredTasks: () => (/* binding */ getFilteredTasks),\n/* harmony export */   getPredefinedValues: () => (/* binding */ getPredefinedValues),\n/* harmony export */   getTasks: () => (/* binding */ getTasks),\n/* harmony export */   getTeamClients: () => (/* binding */ getTeamClients),\n/* harmony export */   getTeamDropdownData: () => (/* binding */ getTeamDropdownData),\n/* harmony export */   getTeamEmployees: () => (/* binding */ getTeamEmployees),\n/* harmony export */   getTeamProjects: () => (/* binding */ getTeamProjects),\n/* harmony export */   getTeams: () => (/* binding */ getTeams),\n/* harmony export */   getUserProfile: () => (/* binding */ getUserProfile),\n/* harmony export */   getWeeklyTasks: () => (/* binding */ getWeeklyTasks),\n/* harmony export */   initializeTeamDefaults: () => (/* binding */ initializeTeamDefaults),\n/* harmony export */   isPredefinedField: () => (/* binding */ isPredefinedField),\n/* harmony export */   saveTeamDropdownData: () => (/* binding */ saveTeamDropdownData),\n/* harmony export */   teamExists: () => (/* binding */ teamExists),\n/* harmony export */   updateTask: () => (/* binding */ updateTask),\n/* harmony export */   updateUserProfile: () => (/* binding */ updateUserProfile)\n/* harmony export */ });\n/* harmony import */ var _firebaseConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./firebaseConfig */ \"(pages-dir-browser)/./lib/firebaseConfig.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(pages-dir-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n// lib/firebase.js - Updated with user context filtering\n\n\n// -------------------- PREDEFINED VALUES --------------------\nconst PREDEFINED_VALUES = {\n    percentageCompletion: [\n        '5',\n        '10',\n        '25',\n        '40',\n        '50',\n        '65',\n        '75',\n        '85',\n        '90',\n        '100'\n    ],\n    status: [\n        'Completed',\n        'In Progress',\n        'On Hold'\n    ],\n    workType: [\n        'Full-day',\n        'Half-day',\n        'Relaxation'\n    ]\n};\n// -------------------- USER MANAGEMENT --------------------\n// Get user profile\nconst getUserProfile = async (userId)=>{\n    try {\n        const userDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users', userId));\n        if (userDoc.exists()) {\n            return userDoc.data();\n        }\n        return null;\n    } catch (error) {\n        console.error('Error getting user profile:', error);\n        return null;\n    }\n};\n// Update user profile\nconst updateUserProfile = async (userId, profileData)=>{\n    try {\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users', userId), profileData, {\n            merge: true\n        });\n    } catch (error) {\n        console.error('Error updating user profile:', error);\n        throw error;\n    }\n};\n// -------------------- TASKS WITH USER CONTEXT --------------------\n// lib/firebase.js - FIXED addTask function to handle updates properly\nconst addTask = async function(task, userProfile) {\n    let isEdit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, taskId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n    try {\n        if (userProfile.role === 'tech-lead') {\n            task.teamName = 'techLeads';\n        }\n        // Validate user can add/update task to this team/employee\n        if (!canUserAccessEmployee(userProfile, task.teamName, task.empId)) {\n            throw new Error('You do not have permission to modify tasks for this employee');\n        }\n        // Create the default team name...\n        await initializeTeamDefaults(task.teamName);\n        // Ensure date document exists\n        const dateRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', task.teamName, 'dates', task.date);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(dateRef, {\n            createdAt: new Date().toISOString()\n        }, {\n            merge: true\n        });\n        // Ensure employee document exists with name\n        const empRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', task.teamName, 'dates', task.date, 'employees', task.empId);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(empRef, {\n            name: task.empName\n        }, {\n            merge: true\n        });\n        // Auto-save new employee to team employees if not exists\n        if (task.empId && task.empName) {\n            await addTeamEmployee(task.teamName, task.empId, task.empName);\n        }\n        // Auto-save new client to team clients if not exists\n        if (task.clientId && task.clientName) {\n            await addTeamClient(task.teamName, task.clientId, task.clientName);\n        }\n        // Auto-save new project to team projects if not exists\n        if (task.projectId && task.projectName) {\n            await addTeamProject(task.teamName, task.projectId, task.projectName);\n        }\n        let docRef;\n        const taskData = {\n            ...task,\n            updatedAt: new Date().toISOString(),\n            updatedBy: userProfile.empId\n        };\n        if (isEdit && taskId) {\n            // UPDATE EXISTING TASK\n            docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', task.teamName, 'dates', task.date, 'employees', task.empId, 'tasks', taskId);\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(docRef, taskData);\n            // Return the updated task with ID\n            return {\n                ...task,\n                id: taskId,\n                updatedAt: new Date().toISOString(),\n                updatedBy: userProfile.empId\n            };\n        } else {\n            // CREATE NEW TASK\n            taskData.createdAt = new Date().toISOString();\n            taskData.createdBy = userProfile.empId;\n            docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', task.teamName, 'dates', task.date, 'employees', task.empId, 'tasks'), taskData);\n            // Return full task object with ID for consistency\n            return {\n                ...task,\n                id: docRef.id,\n                createdAt: new Date().toISOString(),\n                createdBy: userProfile.empId\n            };\n        }\n    } catch (error) {\n        console.error('Error adding/updating task:', error);\n        throw error;\n    }\n};\n// Get tasks based on user permissions\nconst getTasks = async function(userProfile) {\n    let teamFilter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n    try {\n        if (!userProfile) {\n            throw new Error('User profile is required');\n        }\n        let allTasks = [];\n        // Determine which teams user can access\n        let accessibleTeams;\n        switch(userProfile.role){\n            case 'tech-lead':\n                accessibleTeams = [\n                    ...userProfile.managedTeams || [],\n                    'techLeads'\n                ];\n                break;\n            case 'team-leader':\n            case 'employee':\n                accessibleTeams = [\n                    userProfile.teamName\n                ];\n                break;\n            default:\n                return [];\n        }\n        // Apply team filter if provided\n        if (teamFilter && teamFilter !== 'all') {\n            accessibleTeams = accessibleTeams.filter((team)=>team === teamFilter);\n        }\n        // Fetch tasks from accessible teams\n        for (const teamName of accessibleTeams){\n            const datesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates'));\n            for (const dateDoc of datesSnapshot.docs){\n                const date = dateDoc.id;\n                const employeesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', date, 'employees'));\n                for (const empDoc of employeesSnapshot.docs){\n                    const empId = empDoc.id;\n                    // Check if user can access this employee's data\n                    if (!canUserAccessEmployee(userProfile, teamName, empId)) {\n                        continue;\n                    }\n                    const tasksSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', date, 'employees', empId, 'tasks'));\n                    const empTasks = tasksSnapshot.docs.map((taskDoc)=>({\n                            teamName,\n                            date,\n                            empId,\n                            ...taskDoc.data(),\n                            id: taskDoc.id\n                        }));\n                    allTasks = [\n                        ...allTasks,\n                        ...empTasks\n                    ];\n                }\n            }\n        }\n        return allTasks;\n    } catch (error) {\n        console.error('Error getting tasks:', error);\n        throw error;\n    }\n};\n// Update a task (with user permission check)\nconst updateTask = async (teamName, date, empId, taskId, taskData, userProfile)=>{\n    try {\n        // Check if user can update this task\n        if (!canUserAccessEmployee(userProfile, teamName, empId)) {\n            throw new Error('You do not have permission to update this task');\n        }\n        const taskRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', date, 'employees', empId, 'tasks', taskId);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(taskRef, {\n            ...taskData,\n            updatedAt: new Date().toISOString(),\n            updatedBy: userProfile.empId\n        });\n    } catch (error) {\n        console.error('Error updating task:', error);\n        throw error;\n    }\n};\n// Delete a task (with user permission check)\nconst deleteTask = async (teamName, date, empId, taskId, userProfile)=>{\n    try {\n        // Check if user can delete this task\n        if (!canUserAccessEmployee(userProfile, teamName, empId)) {\n            throw new Error('You do not have permission to delete this task');\n        }\n        const taskRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', date, 'employees', empId, 'tasks', taskId);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.deleteDoc)(taskRef);\n    } catch (error) {\n        console.error('Error deleting task:', error);\n        throw error;\n    }\n};\n// -------------------- PERMISSION HELPERS --------------------\n// Check if user can access specific team\nconst canUserAccessTeam = (userProfile, teamName)=>{\n    if (!userProfile) {\n        console.log('No user profile provided');\n        return false;\n    }\n    console.log(\"Checking access for user \".concat(userProfile.empId, \" (\").concat(userProfile.role, \") to team \").concat(teamName));\n    switch(userProfile.role){\n        case 'tech-lead':\n            var _userProfile_managedTeams;\n            // Tech leads can access:\n            // 1. Teams they manage (from managedTeams array)\n            // 2. The special 'techLeads' team for their personal tasks\n            const canAccessManagedTeam = (_userProfile_managedTeams = userProfile.managedTeams) === null || _userProfile_managedTeams === void 0 ? void 0 : _userProfile_managedTeams.includes(teamName);\n            const canAccessTechLeadsTeam = teamName === 'techLeads';\n            const techLeadAccess = canAccessManagedTeam || canAccessTechLeadsTeam;\n            console.log('Tech lead access check:', {\n                managedTeams: userProfile.managedTeams,\n                requestedTeam: teamName,\n                canAccessManagedTeam,\n                canAccessTechLeadsTeam,\n                finalAccess: techLeadAccess\n            });\n            return techLeadAccess;\n        case 'team-leader':\n        case 'employee':\n            const regularAccess = userProfile.teamName === teamName;\n            console.log('Regular user access:', {\n                userTeam: userProfile.teamName,\n                requestedTeam: teamName,\n                access: regularAccess\n            });\n            return regularAccess;\n        default:\n            console.log('Unknown role:', userProfile.role);\n            return false;\n    }\n};\n// Check if user can access specific employee's data\nconst canUserAccessEmployee = (userProfile, teamName, empId)=>{\n    if (!userProfile) return false;\n    switch(userProfile.role){\n        case 'tech-lead':\n            return userProfile.managedTeams.includes(teamName);\n        case 'team-leader':\n            return userProfile.teamName === teamName;\n        case 'employee':\n            return userProfile.teamName === teamName && userProfile.empId === empId;\n        default:\n            return false;\n    }\n};\n// Get accessible teams for current user\nconst getAccessibleTeams = (userProfile)=>{\n    if (!userProfile) return [];\n    switch(userProfile.role){\n        case 'tech-lead':\n            return userProfile.managedTeams;\n        case 'team-leader':\n        case 'employee':\n            return [\n                userProfile.teamName\n            ];\n        default:\n            return [];\n    }\n};\n// -------------------- FILTER BASED ON ROLES --------------------\nconst getFilterOptions = async (userProfile)=>{\n    try {\n        const options = {\n            teamLeaders: [],\n            employees: [],\n            teams: []\n        };\n        if (!userProfile) return options;\n        if (userProfile.role === 'tech-lead') {\n            // Tech leads can filter by teams they manage, team leaders, and employees\n            options.teams = userProfile.managedTeams || [];\n            // Get team leaders and employees from managed teams\n            const teamLeadersSet = new Set();\n            const employeesSet = new Set();\n            for (const teamName of userProfile.managedTeams){\n                try {\n                    // Get team leaders\n                    const teamLeadersQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('role', '==', 'team-leader'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('teamName', '==', teamName));\n                    const teamLeadersSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(teamLeadersQuery);\n                    teamLeadersSnapshot.forEach((doc)=>{\n                        const data = doc.data();\n                        teamLeadersSet.add(JSON.stringify({\n                            empId: data.empId,\n                            empName: data.empName,\n                            teamName: data.teamName\n                        }));\n                    });\n                    // Get employees\n                    const employeesQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('role', '==', 'employee'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('teamName', '==', teamName));\n                    const employeesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(employeesQuery);\n                    employeesSnapshot.forEach((doc)=>{\n                        const data = doc.data();\n                        employeesSet.add(JSON.stringify({\n                            empId: data.empId,\n                            empName: data.empName,\n                            teamName: data.teamName\n                        }));\n                    });\n                } catch (error) {\n                    console.error(\"Error loading data for team \".concat(teamName, \":\"), error);\n                }\n            }\n            options.teamLeaders = Array.from(teamLeadersSet).map((item)=>JSON.parse(item));\n            options.employees = Array.from(employeesSet).map((item)=>JSON.parse(item));\n        } else if (userProfile.role === 'team-leader') {\n            // Team leaders can filter by employees in their team + themselves\n            try {\n                const employees = [];\n                // Add themselves as an option to filter their own tasks\n                employees.push({\n                    empId: userProfile.empId,\n                    empName: \"\".concat(userProfile.empName, \" (Me)\"),\n                    teamName: userProfile.teamName,\n                    isCurrentUser: true\n                });\n                // Get employees in their team\n                const employeesQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('role', '==', 'employee'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('teamName', '==', userProfile.teamName));\n                const employeesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(employeesQuery);\n                employeesSnapshot.forEach((doc)=>{\n                    const data = doc.data();\n                    employees.push({\n                        empId: data.empId,\n                        empName: data.empName,\n                        teamName: data.teamName,\n                        isCurrentUser: false\n                    });\n                });\n                options.employees = employees;\n            } catch (error) {\n                console.error('Error loading employees:', error);\n            }\n        }\n        // Employees only get date filters (no additional options needed)\n        return options;\n    } catch (error) {\n        console.error('Error loading filter options:', error);\n        return {\n            teamLeaders: [],\n            employees: [],\n            teams: []\n        };\n    }\n};\n// -------------------- Get Weekly Task For Current User Only!!! --------------------\nconst getWeeklyTasks = async (userProfile, startDate, endDate)=>{\n    try {\n        if (!userProfile) {\n            throw new Error('User profile is required');\n        }\n        let allTasks = [];\n        // Determine which teams user can access (same as getTasks)\n        let accessibleTeams;\n        switch(userProfile.role){\n            case 'tech-lead':\n                accessibleTeams = [\n                    ...userProfile.managedTeams || [],\n                    'techLeads'\n                ];\n                break;\n            case 'team-leader':\n            case 'employee':\n                accessibleTeams = [\n                    userProfile.teamName\n                ];\n                break;\n            default:\n                return [];\n        }\n        // For weekly report, we assume it's for the current user only (employee view)\n        // If tech-lead or team-leader, they can choose, but for simplicity, filter to own tasks\n        const targetEmpId = userProfile.empId; // Own tasks only for report\n        // Fetch tasks from accessible teams within date range\n        for (const teamName of accessibleTeams){\n            // Query dates between start and end\n            const datesQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('__name__', '>=', startDate), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('__name__', '<=', endDate));\n            const datesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(datesQuery);\n            for (const dateDoc of datesSnapshot.docs){\n                const date = dateDoc.id;\n                const employeesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', date, 'employees'));\n                for (const empDoc of employeesSnapshot.docs){\n                    const empId = empDoc.id;\n                    // Only fetch own tasks for report\n                    if (empId !== targetEmpId) {\n                        continue;\n                    }\n                    const tasksSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', date, 'employees', empId, 'tasks'));\n                    const empTasks = tasksSnapshot.docs.map((taskDoc)=>({\n                            teamName,\n                            date,\n                            empId,\n                            ...taskDoc.data(),\n                            id: taskDoc.id\n                        })).filter((task)=>{\n                        // Filter by time if start/end have time, but since dates are YYYY-MM-DD, it's fine\n                        return task.date >= startDate && task.date <= endDate;\n                    });\n                    allTasks = [\n                        ...allTasks,\n                        ...empTasks\n                    ];\n                }\n            }\n        }\n        return allTasks.sort((a, b)=>new Date(a.date) - new Date(b.date));\n    } catch (error) {\n        console.error('Error getting weekly tasks:', error);\n        throw error;\n    }\n};\nconst applyTaskFilters = (tasks, filters, userProfile)=>{\n    if (!tasks || tasks.length === 0) return tasks;\n    let filteredTasks = [\n        ...tasks\n    ];\n    // Date range filter\n    if (filters.dateFrom) {\n        filteredTasks = filteredTasks.filter((task)=>task.date >= filters.dateFrom);\n    }\n    if (filters.dateTo) {\n        filteredTasks = filteredTasks.filter((task)=>task.date <= filters.dateTo);\n    }\n    // Team filter (tech leads only)\n    if (filters.team && userProfile.role === 'tech-lead') {\n        filteredTasks = filteredTasks.filter((task)=>task.teamName === filters.team);\n    }\n    // Team leader filter (tech leads only)\n    if (filters.teamLeader && userProfile.role === 'tech-lead') {\n        // Find tasks created by employees who report to this team leader\n        filteredTasks = filteredTasks.filter((task)=>{\n            // This requires checking if the task's empId reports to the selected team leader\n            // For now, we'll filter by team since team leaders manage specific teams\n            return task.empId === filters.teamLeader || task.teamName && getTeamLeaderForTeam(task.teamName) === filters.teamLeader;\n        });\n    }\n    // Employee filter (tech leads and team leaders)\n    if (filters.employee && (userProfile.role === 'tech-lead' || userProfile.role === 'team-leader')) {\n        filteredTasks = filteredTasks.filter((task)=>task.empId === filters.employee);\n    }\n    return filteredTasks;\n};\n// Helper function to get team leader for a team\nconst getTeamLeaderForTeam = async (teamName)=>{\n    try {\n        const teamDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName));\n        if (teamDoc.exists() && teamDoc.data().teamLeaderId) {\n            return teamDoc.data().teamLeaderId;\n        }\n        return null;\n    } catch (error) {\n        console.error('Error getting team leader for team:', teamName, error);\n        return null;\n    }\n};\n// Get filtered tasks with all applied filters\nconst getFilteredTasks = async function(userProfile) {\n    let filters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    try {\n        // First get all accessible tasks\n        const allTasks = await getTasks(userProfile);\n        // Then apply filters\n        const filteredTasks = applyTaskFilters(allTasks, filters, userProfile);\n        return filteredTasks;\n    } catch (error) {\n        console.error('Error getting filtered tasks:', error);\n        throw error;\n    }\n};\n// -------------------- DROPDOWNS WITH USER CONTEXT --------------------\n// Get dropdown data for a team (with user permission check)\nconst getTeamDropdownData = async (teamName, field, userProfile)=>{\n    try {\n        // Check if user can access this team\n        if (!canUserAccessTeam(userProfile, teamName)) {\n            throw new Error('You do not have permission to access this team data');\n        }\n        // Return predefined values for specific fields - same for all users\n        if (PREDEFINED_VALUES[field]) {\n            return PREDEFINED_VALUES[field];\n        }\n        // For custom dropdown data, fetch from Firestore\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dropdownData', field);\n        const docSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(docRef);\n        if (docSnap.exists()) {\n            return docSnap.data().values || [];\n        }\n        return [];\n    } catch (error) {\n        console.error('Error getting team dropdown data:', error);\n        // Always return predefined values as fallback\n        return PREDEFINED_VALUES[field] || [];\n    }\n};\n// Save dropdown data for a team (with user permission check)\nconst saveTeamDropdownData = async (teamName, field, values, userProfile)=>{\n    try {\n        // Check if user can modify this team data (only team leaders and tech leads)\n        if (!canUserAccessTeam(userProfile, teamName) || userProfile.role === 'employee') {\n            throw new Error('You do not have permission to modify team data');\n        }\n        // Don't save predefined values to database\n        if (PREDEFINED_VALUES[field]) {\n            console.warn(\"Cannot save predefined values for field: \".concat(field));\n            return;\n        }\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dropdownData', field);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(docRef, {\n            values\n        }, {\n            merge: true\n        });\n    } catch (error) {\n        console.error('Error saving team dropdown data:', error);\n        throw error;\n    }\n};\n// -------------------- TEAMS WITH USER CONTEXT --------------------\n// Get teams accessible to user\nconst getTeams = async (userProfile)=>{\n    try {\n        if (!userProfile) return [];\n        return getAccessibleTeams(userProfile);\n    } catch (error) {\n        console.error('Error getting teams:', error);\n        return [];\n    }\n};\n// -------------------- PROJECTS WITH USER CONTEXT --------------------\n// Get team-specific projects (with user permission check)\nconst getTeamProjects = async (teamName, userProfile)=>{\n    try {\n        if (!canUserAccessTeam(userProfile, teamName)) {\n            return [];\n        }\n        return await getTeamDropdownData(teamName, 'projects', userProfile);\n    } catch (error) {\n        console.error('Error getting team projects:', error);\n        return [];\n    }\n};\n// Add new project to team (with user permission check)\nconst addTeamProject = async (teamName, projectId, projectName, userProfile)=>{\n    try {\n        if (!projectId || !projectName) return;\n        if (!canUserAccessTeam(userProfile, teamName) || userProfile.role === 'employee') {\n            return; // Silently fail for employees\n        }\n        const projects = await getTeamProjects(teamName, userProfile);\n        const exists = projects.find((p)=>p.id === projectId);\n        if (!exists) {\n            const newProjects = [\n                ...projects,\n                {\n                    id: projectId,\n                    name: projectName\n                }\n            ];\n            await saveTeamDropdownData(teamName, 'projects', newProjects, userProfile);\n        }\n    } catch (error) {\n        console.error('Error adding team project:', error);\n    // Don't throw error to prevent task creation failure\n    }\n};\n// -------------------- EMPLOYEES WITH USER CONTEXT --------------------\n// Get team-specific employees (with user permission check)\nconst getTeamEmployees = async (teamName, userProfile)=>{\n    try {\n        if (!canUserAccessTeam(userProfile, teamName)) {\n            return [];\n        }\n        return await getTeamDropdownData(teamName, 'employees', userProfile);\n    } catch (error) {\n        console.error('Error getting team employees:', error);\n        return [];\n    }\n};\n// Add new employee to team (with user permission check)\nconst addTeamEmployee = async (teamName, empId, empName, userProfile)=>{\n    try {\n        if (!empId || !empName) return;\n        if (!canUserAccessTeam(userProfile, teamName) || userProfile.role === 'employee') {\n            return; // Silently fail for employees\n        }\n        const employees = await getTeamEmployees(teamName, userProfile);\n        const exists = employees.find((e)=>e.id === empId);\n        if (!exists) {\n            const newEmployees = [\n                ...employees,\n                {\n                    id: empId,\n                    name: empName\n                }\n            ];\n            await saveTeamDropdownData(teamName, 'employees', newEmployees, userProfile);\n        }\n    } catch (error) {\n        console.error('Error adding team employee:', error);\n    // Don't throw error to prevent task creation failure\n    }\n};\n// -------------------- CLIENTS WITH USER CONTEXT --------------------\n// Get team-specific clients (with user permission check)\nconst getTeamClients = async (teamName, userProfile)=>{\n    try {\n        if (!canUserAccessTeam(userProfile, teamName)) {\n            return [];\n        }\n        return await getTeamDropdownData(teamName, 'clients', userProfile);\n    } catch (error) {\n        console.error('Error getting team clients:', error);\n        return [];\n    }\n};\n// Add new client to team (with user permission check)\nconst addTeamClient = async (teamName, clientId, clientName, userProfile)=>{\n    try {\n        if (!clientId || !clientName) return;\n        if (!canUserAccessTeam(userProfile, teamName) || userProfile.role === 'employee') {\n            return; // Silently fail for employees\n        }\n        const clients = await getTeamClients(teamName, userProfile);\n        const exists = clients.find((c)=>c.id === clientId);\n        if (!exists) {\n            const newClients = [\n                ...clients,\n                {\n                    id: clientId,\n                    name: clientName\n                }\n            ];\n            await saveTeamDropdownData(teamName, 'clients', newClients, userProfile);\n        }\n    } catch (error) {\n        console.error('Error adding team client:', error);\n    // Don't throw error to prevent task creation failure\n    }\n};\n// -------------------- UTILITY FUNCTIONS --------------------\n// Get predefined values for a specific field\nconst getPredefinedValues = (field)=>{\n    return PREDEFINED_VALUES[field] || [];\n};\n// Check if field has predefined values\nconst isPredefinedField = (field)=>{\n    return !!PREDEFINED_VALUES[field];\n};\n// Check if team document exists\nconst teamExists = async (teamName)=>{\n    try {\n        const teamDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName));\n        return teamDoc.exists();\n    } catch (error) {\n        return false;\n    }\n};\n// Initialize default dropdown values for a team (only if team doesn't exist yet)\nconst initializeTeamDefaults = async (teamName)=>{\n    try {\n        const exists = await teamExists(teamName);\n        if (!exists) {\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName), {\n                createdAt: new Date().toISOString()\n            });\n        }\n    } catch (error) {\n        console.error('Error initializing team defaults:', error);\n        throw error;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cUksV0FBV3hIO1FBQ2hDLElBQUksQ0FBQ2IsUUFBUTtZQUNULE1BQU1WLDBEQUFNQSxDQUFDSix1REFBR0EsQ0FBQ0osK0NBQUVBLEVBQUUsU0FBUytCLFdBQVc7Z0JBQUVPLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztZQUFHO1FBQ25GO0lBQ0osRUFBRSxPQUFPcEIsT0FBTztRQUNaQyxRQUFRRCxLQUFLLENBQUMscUNBQXFDQTtRQUNuRCxNQUFNQTtJQUNWO0FBQ0osRUFBRSIsInNvdXJjZXMiOlsiQzpcXHNhdXJhYmhcXFByb2plY3RzXFxBZHZhbmNlZF9HZW5BSVxcVGFza0hpdmVcXGxpYlxcZmlyZWJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbGliL2ZpcmViYXNlLmpzIC0gVXBkYXRlZCB3aXRoIHVzZXIgY29udGV4dCBmaWx0ZXJpbmdcclxuaW1wb3J0IHsgZGIgfSBmcm9tICcuL2ZpcmViYXNlQ29uZmlnJztcclxuaW1wb3J0IHtcclxuICAgIGNvbGxlY3Rpb24sIGFkZERvYywgZ2V0RG9jcywgZG9jLCB1cGRhdGVEb2MsIGRlbGV0ZURvYywgZ2V0RG9jLCBzZXREb2MsIHF1ZXJ5LCB3aGVyZVxyXG59IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSBQUkVERUZJTkVEIFZBTFVFUyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5jb25zdCBQUkVERUZJTkVEX1ZBTFVFUyA9IHtcclxuICAgIHBlcmNlbnRhZ2VDb21wbGV0aW9uOiBbJzUnLCAnMTAnLCAnMjUnLCAnNDAnLCAnNTAnLCAnNjUnLCAnNzUnLCAnODUnLCAnOTAnLCAnMTAwJ10sXHJcbiAgICBzdGF0dXM6IFsnQ29tcGxldGVkJywgJ0luIFByb2dyZXNzJywgJ09uIEhvbGQnXSxcclxuICAgIHdvcmtUeXBlOiBbJ0Z1bGwtZGF5JywgJ0hhbGYtZGF5JywgJ1JlbGF4YXRpb24nXVxyXG59O1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0gVVNFUiBNQU5BR0VNRU5UIC0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vLyBHZXQgdXNlciBwcm9maWxlXHJcbmV4cG9ydCBjb25zdCBnZXRVc2VyUHJvZmlsZSA9IGFzeW5jICh1c2VySWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgdXNlckRvYyA9IGF3YWl0IGdldERvYyhkb2MoZGIsICd1c2VycycsIHVzZXJJZCkpO1xyXG4gICAgICAgIGlmICh1c2VyRG9jLmV4aXN0cygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VyRG9jLmRhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdXNlciBwcm9maWxlOicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIFVwZGF0ZSB1c2VyIHByb2ZpbGVcclxuZXhwb3J0IGNvbnN0IHVwZGF0ZVVzZXJQcm9maWxlID0gYXN5bmMgKHVzZXJJZCwgcHJvZmlsZURhdGEpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgc2V0RG9jKGRvYyhkYiwgJ3VzZXJzJywgdXNlcklkKSwgcHJvZmlsZURhdGEsIHsgbWVyZ2U6IHRydWUgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHVzZXIgcHJvZmlsZTonLCBlcnJvcik7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSBUQVNLUyBXSVRIIFVTRVIgQ09OVEVYVCAtLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLy8gbGliL2ZpcmViYXNlLmpzIC0gRklYRUQgYWRkVGFzayBmdW5jdGlvbiB0byBoYW5kbGUgdXBkYXRlcyBwcm9wZXJseVxyXG5leHBvcnQgY29uc3QgYWRkVGFzayA9IGFzeW5jICh0YXNrLCB1c2VyUHJvZmlsZSwgaXNFZGl0ID0gZmFsc2UsIHRhc2tJZCA9IG51bGwpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHVzZXJQcm9maWxlLnJvbGUgPT09ICd0ZWNoLWxlYWQnKSB7XHJcbiAgICAgICAgICAgIHRhc2sudGVhbU5hbWUgPSAndGVjaExlYWRzJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFZhbGlkYXRlIHVzZXIgY2FuIGFkZC91cGRhdGUgdGFzayB0byB0aGlzIHRlYW0vZW1wbG95ZWVcclxuICAgICAgICBpZiAoIWNhblVzZXJBY2Nlc3NFbXBsb3llZSh1c2VyUHJvZmlsZSwgdGFzay50ZWFtTmFtZSwgdGFzay5lbXBJZCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBtb2RpZnkgdGFza3MgZm9yIHRoaXMgZW1wbG95ZWUnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgZGVmYXVsdCB0ZWFtIG5hbWUuLi5cclxuICAgICAgICBhd2FpdCBpbml0aWFsaXplVGVhbURlZmF1bHRzKHRhc2sudGVhbU5hbWUpO1xyXG5cclxuICAgICAgICAvLyBFbnN1cmUgZGF0ZSBkb2N1bWVudCBleGlzdHNcclxuICAgICAgICBjb25zdCBkYXRlUmVmID0gZG9jKGRiLCAndGVhbXMnLCB0YXNrLnRlYW1OYW1lLCAnZGF0ZXMnLCB0YXNrLmRhdGUpO1xyXG4gICAgICAgIGF3YWl0IHNldERvYyhkYXRlUmVmLCB7IGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0sIHsgbWVyZ2U6IHRydWUgfSk7XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSBlbXBsb3llZSBkb2N1bWVudCBleGlzdHMgd2l0aCBuYW1lXHJcbiAgICAgICAgY29uc3QgZW1wUmVmID0gZG9jKGRiLCAndGVhbXMnLCB0YXNrLnRlYW1OYW1lLCAnZGF0ZXMnLCB0YXNrLmRhdGUsICdlbXBsb3llZXMnLCB0YXNrLmVtcElkKTtcclxuICAgICAgICBhd2FpdCBzZXREb2MoZW1wUmVmLCB7IG5hbWU6IHRhc2suZW1wTmFtZSB9LCB7IG1lcmdlOiB0cnVlIH0pO1xyXG5cclxuICAgICAgICAvLyBBdXRvLXNhdmUgbmV3IGVtcGxveWVlIHRvIHRlYW0gZW1wbG95ZWVzIGlmIG5vdCBleGlzdHNcclxuICAgICAgICBpZiAodGFzay5lbXBJZCAmJiB0YXNrLmVtcE5hbWUpIHtcclxuICAgICAgICAgICAgYXdhaXQgYWRkVGVhbUVtcGxveWVlKHRhc2sudGVhbU5hbWUsIHRhc2suZW1wSWQsIHRhc2suZW1wTmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBdXRvLXNhdmUgbmV3IGNsaWVudCB0byB0ZWFtIGNsaWVudHMgaWYgbm90IGV4aXN0c1xyXG4gICAgICAgIGlmICh0YXNrLmNsaWVudElkICYmIHRhc2suY2xpZW50TmFtZSkge1xyXG4gICAgICAgICAgICBhd2FpdCBhZGRUZWFtQ2xpZW50KHRhc2sudGVhbU5hbWUsIHRhc2suY2xpZW50SWQsIHRhc2suY2xpZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBdXRvLXNhdmUgbmV3IHByb2plY3QgdG8gdGVhbSBwcm9qZWN0cyBpZiBub3QgZXhpc3RzXHJcbiAgICAgICAgaWYgKHRhc2sucHJvamVjdElkICYmIHRhc2sucHJvamVjdE5hbWUpIHtcclxuICAgICAgICAgICAgYXdhaXQgYWRkVGVhbVByb2plY3QodGFzay50ZWFtTmFtZSwgdGFzay5wcm9qZWN0SWQsIHRhc2sucHJvamVjdE5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGRvY1JlZjtcclxuICAgICAgICBjb25zdCB0YXNrRGF0YSA9IHtcclxuICAgICAgICAgICAgLi4udGFzayxcclxuICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksIC8vIEFsd2F5cyB1cGRhdGUgdGltZXN0YW1wXHJcbiAgICAgICAgICAgIHVwZGF0ZWRCeTogdXNlclByb2ZpbGUuZW1wSWRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoaXNFZGl0ICYmIHRhc2tJZCkge1xyXG4gICAgICAgICAgICAvLyBVUERBVEUgRVhJU1RJTkcgVEFTS1xyXG4gICAgICAgICAgICBkb2NSZWYgPSBkb2MoZGIsICd0ZWFtcycsIHRhc2sudGVhbU5hbWUsICdkYXRlcycsIHRhc2suZGF0ZSwgJ2VtcGxveWVlcycsIHRhc2suZW1wSWQsICd0YXNrcycsIHRhc2tJZCk7XHJcbiAgICAgICAgICAgIGF3YWl0IHVwZGF0ZURvYyhkb2NSZWYsIHRhc2tEYXRhKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgdXBkYXRlZCB0YXNrIHdpdGggSURcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIC4uLnRhc2ssXHJcbiAgICAgICAgICAgICAgICBpZDogdGFza0lkLFxyXG4gICAgICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVkQnk6IHVzZXJQcm9maWxlLmVtcElkXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQ1JFQVRFIE5FVyBUQVNLXHJcbiAgICAgICAgICAgIHRhc2tEYXRhLmNyZWF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcclxuICAgICAgICAgICAgdGFza0RhdGEuY3JlYXRlZEJ5ID0gdXNlclByb2ZpbGUuZW1wSWQ7XHJcblxyXG4gICAgICAgICAgICBkb2NSZWYgPSBhd2FpdCBhZGREb2MoXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uKGRiLCAndGVhbXMnLCB0YXNrLnRlYW1OYW1lLCAnZGF0ZXMnLCB0YXNrLmRhdGUsICdlbXBsb3llZXMnLCB0YXNrLmVtcElkLCAndGFza3MnKSxcclxuICAgICAgICAgICAgICAgIHRhc2tEYXRhXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gZnVsbCB0YXNrIG9iamVjdCB3aXRoIElEIGZvciBjb25zaXN0ZW5jeVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLi4udGFzayxcclxuICAgICAgICAgICAgICAgIGlkOiBkb2NSZWYuaWQsXHJcbiAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgIGNyZWF0ZWRCeTogdXNlclByb2ZpbGUuZW1wSWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZy91cGRhdGluZyB0YXNrOicsIGVycm9yKTtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIEdldCB0YXNrcyBiYXNlZCBvbiB1c2VyIHBlcm1pc3Npb25zXHJcbmV4cG9ydCBjb25zdCBnZXRUYXNrcyA9IGFzeW5jICh1c2VyUHJvZmlsZSwgdGVhbUZpbHRlciA9IG51bGwpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCF1c2VyUHJvZmlsZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgcHJvZmlsZSBpcyByZXF1aXJlZCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGFsbFRhc2tzID0gW107XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSB3aGljaCB0ZWFtcyB1c2VyIGNhbiBhY2Nlc3NcclxuICAgICAgICBsZXQgYWNjZXNzaWJsZVRlYW1zO1xyXG4gICAgICAgIHN3aXRjaCAodXNlclByb2ZpbGUucm9sZSkge1xyXG4gICAgICAgICAgICBjYXNlICd0ZWNoLWxlYWQnOlxyXG4gICAgICAgICAgICAgICAgYWNjZXNzaWJsZVRlYW1zID0gWy4uLih1c2VyUHJvZmlsZS5tYW5hZ2VkVGVhbXMgfHwgW10pLCAndGVjaExlYWRzJ107XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAndGVhbS1sZWFkZXInOlxyXG4gICAgICAgICAgICBjYXNlICdlbXBsb3llZSc6XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NpYmxlVGVhbXMgPSBbdXNlclByb2ZpbGUudGVhbU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcHBseSB0ZWFtIGZpbHRlciBpZiBwcm92aWRlZFxyXG4gICAgICAgIGlmICh0ZWFtRmlsdGVyICYmIHRlYW1GaWx0ZXIgIT09ICdhbGwnKSB7XHJcbiAgICAgICAgICAgIGFjY2Vzc2libGVUZWFtcyA9IGFjY2Vzc2libGVUZWFtcy5maWx0ZXIodGVhbSA9PiB0ZWFtID09PSB0ZWFtRmlsdGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZldGNoIHRhc2tzIGZyb20gYWNjZXNzaWJsZSB0ZWFtc1xyXG4gICAgICAgIGZvciAoY29uc3QgdGVhbU5hbWUgb2YgYWNjZXNzaWJsZVRlYW1zKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGVzU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKGNvbGxlY3Rpb24oZGIsICd0ZWFtcycsIHRlYW1OYW1lLCAnZGF0ZXMnKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRhdGVEb2Mgb2YgZGF0ZXNTbmFwc2hvdC5kb2NzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRlID0gZGF0ZURvYy5pZDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVtcGxveWVlc1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uKGRiLCAndGVhbXMnLCB0ZWFtTmFtZSwgJ2RhdGVzJywgZGF0ZSwgJ2VtcGxveWVlcycpXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW1wRG9jIG9mIGVtcGxveWVlc1NuYXBzaG90LmRvY3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbXBJZCA9IGVtcERvYy5pZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdXNlciBjYW4gYWNjZXNzIHRoaXMgZW1wbG95ZWUncyBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5Vc2VyQWNjZXNzRW1wbG95ZWUodXNlclByb2ZpbGUsIHRlYW1OYW1lLCBlbXBJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXNrc1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbihkYiwgJ3RlYW1zJywgdGVhbU5hbWUsICdkYXRlcycsIGRhdGUsICdlbXBsb3llZXMnLCBlbXBJZCwgJ3Rhc2tzJylcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbXBUYXNrcyA9IHRhc2tzU25hcHNob3QuZG9jcy5tYXAodGFza0RvYyA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZWFtTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1wSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhc2tEb2MuZGF0YSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdGFza0RvYy5pZFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYWxsVGFza3MgPSBbLi4uYWxsVGFza3MsIC4uLmVtcFRhc2tzXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFsbFRhc2tzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHRhc2tzOicsIGVycm9yKTtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIFVwZGF0ZSBhIHRhc2sgKHdpdGggdXNlciBwZXJtaXNzaW9uIGNoZWNrKVxyXG5leHBvcnQgY29uc3QgdXBkYXRlVGFzayA9IGFzeW5jICh0ZWFtTmFtZSwgZGF0ZSwgZW1wSWQsIHRhc2tJZCwgdGFza0RhdGEsIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHVzZXIgY2FuIHVwZGF0ZSB0aGlzIHRhc2tcclxuICAgICAgICBpZiAoIWNhblVzZXJBY2Nlc3NFbXBsb3llZSh1c2VyUHJvZmlsZSwgdGVhbU5hbWUsIGVtcElkKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIHVwZGF0ZSB0aGlzIHRhc2snKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRhc2tSZWYgPSBkb2MoZGIsICd0ZWFtcycsIHRlYW1OYW1lLCAnZGF0ZXMnLCBkYXRlLCAnZW1wbG95ZWVzJywgZW1wSWQsICd0YXNrcycsIHRhc2tJZCk7XHJcbiAgICAgICAgYXdhaXQgdXBkYXRlRG9jKHRhc2tSZWYsIHtcclxuICAgICAgICAgICAgLi4udGFza0RhdGEsXHJcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgICB1cGRhdGVkQnk6IHVzZXJQcm9maWxlLmVtcElkXHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHRhc2s6JywgZXJyb3IpO1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gRGVsZXRlIGEgdGFzayAod2l0aCB1c2VyIHBlcm1pc3Npb24gY2hlY2spXHJcbmV4cG9ydCBjb25zdCBkZWxldGVUYXNrID0gYXN5bmMgKHRlYW1OYW1lLCBkYXRlLCBlbXBJZCwgdGFza0lkLCB1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBDaGVjayBpZiB1c2VyIGNhbiBkZWxldGUgdGhpcyB0YXNrXHJcbiAgICAgICAgaWYgKCFjYW5Vc2VyQWNjZXNzRW1wbG95ZWUodXNlclByb2ZpbGUsIHRlYW1OYW1lLCBlbXBJZCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBkZWxldGUgdGhpcyB0YXNrJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0YXNrUmVmID0gZG9jKGRiLCAndGVhbXMnLCB0ZWFtTmFtZSwgJ2RhdGVzJywgZGF0ZSwgJ2VtcGxveWVlcycsIGVtcElkLCAndGFza3MnLCB0YXNrSWQpO1xyXG4gICAgICAgIGF3YWl0IGRlbGV0ZURvYyh0YXNrUmVmKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgdGFzazonLCBlcnJvcik7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSBQRVJNSVNTSU9OIEhFTFBFUlMgLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8vIENoZWNrIGlmIHVzZXIgY2FuIGFjY2VzcyBzcGVjaWZpYyB0ZWFtXHJcbmV4cG9ydCBjb25zdCBjYW5Vc2VyQWNjZXNzVGVhbSA9ICh1c2VyUHJvZmlsZSwgdGVhbU5hbWUpID0+IHtcclxuICAgIGlmICghdXNlclByb2ZpbGUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnTm8gdXNlciBwcm9maWxlIHByb3ZpZGVkJyk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGBDaGVja2luZyBhY2Nlc3MgZm9yIHVzZXIgJHt1c2VyUHJvZmlsZS5lbXBJZH0gKCR7dXNlclByb2ZpbGUucm9sZX0pIHRvIHRlYW0gJHt0ZWFtTmFtZX1gKTtcclxuXHJcbiAgICBzd2l0Y2ggKHVzZXJQcm9maWxlLnJvbGUpIHtcclxuICAgICAgICBjYXNlICd0ZWNoLWxlYWQnOlxyXG4gICAgICAgICAgICAvLyBUZWNoIGxlYWRzIGNhbiBhY2Nlc3M6XHJcbiAgICAgICAgICAgIC8vIDEuIFRlYW1zIHRoZXkgbWFuYWdlIChmcm9tIG1hbmFnZWRUZWFtcyBhcnJheSlcclxuICAgICAgICAgICAgLy8gMi4gVGhlIHNwZWNpYWwgJ3RlY2hMZWFkcycgdGVhbSBmb3IgdGhlaXIgcGVyc29uYWwgdGFza3NcclxuICAgICAgICAgICAgY29uc3QgY2FuQWNjZXNzTWFuYWdlZFRlYW0gPSB1c2VyUHJvZmlsZS5tYW5hZ2VkVGVhbXM/LmluY2x1ZGVzKHRlYW1OYW1lKTtcclxuICAgICAgICAgICAgY29uc3QgY2FuQWNjZXNzVGVjaExlYWRzVGVhbSA9IHRlYW1OYW1lID09PSAndGVjaExlYWRzJztcclxuICAgICAgICAgICAgY29uc3QgdGVjaExlYWRBY2Nlc3MgPSBjYW5BY2Nlc3NNYW5hZ2VkVGVhbSB8fCBjYW5BY2Nlc3NUZWNoTGVhZHNUZWFtO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1RlY2ggbGVhZCBhY2Nlc3MgY2hlY2s6Jywge1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlZFRlYW1zOiB1c2VyUHJvZmlsZS5tYW5hZ2VkVGVhbXMsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZWRUZWFtOiB0ZWFtTmFtZSxcclxuICAgICAgICAgICAgICAgIGNhbkFjY2Vzc01hbmFnZWRUZWFtLFxyXG4gICAgICAgICAgICAgICAgY2FuQWNjZXNzVGVjaExlYWRzVGVhbSxcclxuICAgICAgICAgICAgICAgIGZpbmFsQWNjZXNzOiB0ZWNoTGVhZEFjY2Vzc1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0ZWNoTGVhZEFjY2VzcztcclxuXHJcbiAgICAgICAgY2FzZSAndGVhbS1sZWFkZXInOlxyXG4gICAgICAgIGNhc2UgJ2VtcGxveWVlJzpcclxuICAgICAgICAgICAgY29uc3QgcmVndWxhckFjY2VzcyA9IHVzZXJQcm9maWxlLnRlYW1OYW1lID09PSB0ZWFtTmFtZTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlZ3VsYXIgdXNlciBhY2Nlc3M6Jywge1xyXG4gICAgICAgICAgICAgICAgdXNlclRlYW06IHVzZXJQcm9maWxlLnRlYW1OYW1lLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdGVkVGVhbTogdGVhbU5hbWUsXHJcbiAgICAgICAgICAgICAgICBhY2Nlc3M6IHJlZ3VsYXJBY2Nlc3NcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZWd1bGFyQWNjZXNzO1xyXG5cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVW5rbm93biByb2xlOicsIHVzZXJQcm9maWxlLnJvbGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBDaGVjayBpZiB1c2VyIGNhbiBhY2Nlc3Mgc3BlY2lmaWMgZW1wbG95ZWUncyBkYXRhXHJcbmV4cG9ydCBjb25zdCBjYW5Vc2VyQWNjZXNzRW1wbG95ZWUgPSAodXNlclByb2ZpbGUsIHRlYW1OYW1lLCBlbXBJZCkgPT4ge1xyXG4gICAgaWYgKCF1c2VyUHJvZmlsZSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIHN3aXRjaCAodXNlclByb2ZpbGUucm9sZSkge1xyXG4gICAgICAgIGNhc2UgJ3RlY2gtbGVhZCc6XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VyUHJvZmlsZS5tYW5hZ2VkVGVhbXMuaW5jbHVkZXModGVhbU5hbWUpO1xyXG4gICAgICAgIGNhc2UgJ3RlYW0tbGVhZGVyJzpcclxuICAgICAgICAgICAgcmV0dXJuIHVzZXJQcm9maWxlLnRlYW1OYW1lID09PSB0ZWFtTmFtZTtcclxuICAgICAgICBjYXNlICdlbXBsb3llZSc6XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VyUHJvZmlsZS50ZWFtTmFtZSA9PT0gdGVhbU5hbWUgJiYgdXNlclByb2ZpbGUuZW1wSWQgPT09IGVtcElkO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIEdldCBhY2Nlc3NpYmxlIHRlYW1zIGZvciBjdXJyZW50IHVzZXJcclxuZXhwb3J0IGNvbnN0IGdldEFjY2Vzc2libGVUZWFtcyA9ICh1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgaWYgKCF1c2VyUHJvZmlsZSkgcmV0dXJuIFtdO1xyXG5cclxuICAgIHN3aXRjaCAodXNlclByb2ZpbGUucm9sZSkge1xyXG4gICAgICAgIGNhc2UgJ3RlY2gtbGVhZCc6XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VyUHJvZmlsZS5tYW5hZ2VkVGVhbXM7XHJcbiAgICAgICAgY2FzZSAndGVhbS1sZWFkZXInOlxyXG4gICAgICAgIGNhc2UgJ2VtcGxveWVlJzpcclxuICAgICAgICAgICAgcmV0dXJuIFt1c2VyUHJvZmlsZS50ZWFtTmFtZV07XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSBGSUxURVIgQkFTRUQgT04gUk9MRVMgLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG5leHBvcnQgY29uc3QgZ2V0RmlsdGVyT3B0aW9ucyA9IGFzeW5jICh1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICB0ZWFtTGVhZGVyczogW10sXHJcbiAgICAgICAgICAgIGVtcGxveWVlczogW10sXHJcbiAgICAgICAgICAgIHRlYW1zOiBbXVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICghdXNlclByb2ZpbGUpIHJldHVybiBvcHRpb25zO1xyXG5cclxuICAgICAgICBpZiAodXNlclByb2ZpbGUucm9sZSA9PT0gJ3RlY2gtbGVhZCcpIHtcclxuICAgICAgICAgICAgLy8gVGVjaCBsZWFkcyBjYW4gZmlsdGVyIGJ5IHRlYW1zIHRoZXkgbWFuYWdlLCB0ZWFtIGxlYWRlcnMsIGFuZCBlbXBsb3llZXNcclxuICAgICAgICAgICAgb3B0aW9ucy50ZWFtcyA9IHVzZXJQcm9maWxlLm1hbmFnZWRUZWFtcyB8fCBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0ZWFtIGxlYWRlcnMgYW5kIGVtcGxveWVlcyBmcm9tIG1hbmFnZWQgdGVhbXNcclxuICAgICAgICAgICAgY29uc3QgdGVhbUxlYWRlcnNTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVtcGxveWVlc1NldCA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGVhbU5hbWUgb2YgdXNlclByb2ZpbGUubWFuYWdlZFRlYW1zKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0ZWFtIGxlYWRlcnNcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZWFtTGVhZGVyc1F1ZXJ5ID0gcXVlcnkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24oZGIsICd1c2VycycpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVyZSgncm9sZScsICc9PScsICd0ZWFtLWxlYWRlcicpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVyZSgndGVhbU5hbWUnLCAnPT0nLCB0ZWFtTmFtZSlcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlYW1MZWFkZXJzU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHRlYW1MZWFkZXJzUXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlYW1MZWFkZXJzU25hcHNob3QuZm9yRWFjaChkb2MgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gZG9jLmRhdGEoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVhbUxlYWRlcnNTZXQuYWRkKEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtcElkOiBkYXRhLmVtcElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1wTmFtZTogZGF0YS5lbXBOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVhbU5hbWU6IGRhdGEudGVhbU5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgZW1wbG95ZWVzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW1wbG95ZWVzUXVlcnkgPSBxdWVyeShcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbihkYiwgJ3VzZXJzJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlKCdyb2xlJywgJz09JywgJ2VtcGxveWVlJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlKCd0ZWFtTmFtZScsICc9PScsIHRlYW1OYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW1wbG95ZWVzU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKGVtcGxveWVlc1F1ZXJ5KTtcclxuICAgICAgICAgICAgICAgICAgICBlbXBsb3llZXNTbmFwc2hvdC5mb3JFYWNoKGRvYyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBkb2MuZGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbXBsb3llZXNTZXQuYWRkKEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtcElkOiBkYXRhLmVtcElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1wTmFtZTogZGF0YS5lbXBOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVhbU5hbWU6IGRhdGEudGVhbU5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBsb2FkaW5nIGRhdGEgZm9yIHRlYW0gJHt0ZWFtTmFtZX06YCwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvcHRpb25zLnRlYW1MZWFkZXJzID0gQXJyYXkuZnJvbSh0ZWFtTGVhZGVyc1NldCkubWFwKGl0ZW0gPT4gSlNPTi5wYXJzZShpdGVtKSk7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZW1wbG95ZWVzID0gQXJyYXkuZnJvbShlbXBsb3llZXNTZXQpLm1hcChpdGVtID0+IEpTT04ucGFyc2UoaXRlbSkpO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKHVzZXJQcm9maWxlLnJvbGUgPT09ICd0ZWFtLWxlYWRlcicpIHtcclxuICAgICAgICAgICAgLy8gVGVhbSBsZWFkZXJzIGNhbiBmaWx0ZXIgYnkgZW1wbG95ZWVzIGluIHRoZWlyIHRlYW0gKyB0aGVtc2VsdmVzXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbXBsb3llZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlbXNlbHZlcyBhcyBhbiBvcHRpb24gdG8gZmlsdGVyIHRoZWlyIG93biB0YXNrc1xyXG4gICAgICAgICAgICAgICAgZW1wbG95ZWVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGVtcElkOiB1c2VyUHJvZmlsZS5lbXBJZCxcclxuICAgICAgICAgICAgICAgICAgICBlbXBOYW1lOiBgJHt1c2VyUHJvZmlsZS5lbXBOYW1lfSAoTWUpYCxcclxuICAgICAgICAgICAgICAgICAgICB0ZWFtTmFtZTogdXNlclByb2ZpbGUudGVhbU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNDdXJyZW50VXNlcjogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gR2V0IGVtcGxveWVlcyBpbiB0aGVpciB0ZWFtXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbXBsb3llZXNRdWVyeSA9IHF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24oZGIsICd1c2VycycpLFxyXG4gICAgICAgICAgICAgICAgICAgIHdoZXJlKCdyb2xlJywgJz09JywgJ2VtcGxveWVlJyksXHJcbiAgICAgICAgICAgICAgICAgICAgd2hlcmUoJ3RlYW1OYW1lJywgJz09JywgdXNlclByb2ZpbGUudGVhbU5hbWUpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW1wbG95ZWVzU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKGVtcGxveWVlc1F1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIGVtcGxveWVlc1NuYXBzaG90LmZvckVhY2goZG9jID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gZG9jLmRhdGEoKTtcclxuICAgICAgICAgICAgICAgICAgICBlbXBsb3llZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcElkOiBkYXRhLmVtcElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbXBOYW1lOiBkYXRhLmVtcE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlYW1OYW1lOiBkYXRhLnRlYW1OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0N1cnJlbnRVc2VyOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5lbXBsb3llZXMgPSBlbXBsb3llZXM7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGVtcGxveWVlczonLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRW1wbG95ZWVzIG9ubHkgZ2V0IGRhdGUgZmlsdGVycyAobm8gYWRkaXRpb25hbCBvcHRpb25zIG5lZWRlZClcclxuXHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgZmlsdGVyIG9wdGlvbnM6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiB7IHRlYW1MZWFkZXJzOiBbXSwgZW1wbG95ZWVzOiBbXSwgdGVhbXM6IFtdIH07XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0gR2V0IFdlZWtseSBUYXNrIEZvciBDdXJyZW50IFVzZXIgT25seSEhISAtLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuZXhwb3J0IGNvbnN0IGdldFdlZWtseVRhc2tzID0gYXN5bmMgKHVzZXJQcm9maWxlLCBzdGFydERhdGUsIGVuZERhdGUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCF1c2VyUHJvZmlsZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgcHJvZmlsZSBpcyByZXF1aXJlZCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGFsbFRhc2tzID0gW107XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSB3aGljaCB0ZWFtcyB1c2VyIGNhbiBhY2Nlc3MgKHNhbWUgYXMgZ2V0VGFza3MpXHJcbiAgICAgICAgbGV0IGFjY2Vzc2libGVUZWFtcztcclxuICAgICAgICBzd2l0Y2ggKHVzZXJQcm9maWxlLnJvbGUpIHtcclxuICAgICAgICAgICAgY2FzZSAndGVjaC1sZWFkJzpcclxuICAgICAgICAgICAgICAgIGFjY2Vzc2libGVUZWFtcyA9IFsuLi4odXNlclByb2ZpbGUubWFuYWdlZFRlYW1zIHx8IFtdKSwgJ3RlY2hMZWFkcyddO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RlYW0tbGVhZGVyJzpcclxuICAgICAgICAgICAgY2FzZSAnZW1wbG95ZWUnOlxyXG4gICAgICAgICAgICAgICAgYWNjZXNzaWJsZVRlYW1zID0gW3VzZXJQcm9maWxlLnRlYW1OYW1lXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRm9yIHdlZWtseSByZXBvcnQsIHdlIGFzc3VtZSBpdCdzIGZvciB0aGUgY3VycmVudCB1c2VyIG9ubHkgKGVtcGxveWVlIHZpZXcpXHJcbiAgICAgICAgLy8gSWYgdGVjaC1sZWFkIG9yIHRlYW0tbGVhZGVyLCB0aGV5IGNhbiBjaG9vc2UsIGJ1dCBmb3Igc2ltcGxpY2l0eSwgZmlsdGVyIHRvIG93biB0YXNrc1xyXG4gICAgICAgIGNvbnN0IHRhcmdldEVtcElkID0gdXNlclByb2ZpbGUuZW1wSWQ7IC8vIE93biB0YXNrcyBvbmx5IGZvciByZXBvcnRcclxuXHJcbiAgICAgICAgLy8gRmV0Y2ggdGFza3MgZnJvbSBhY2Nlc3NpYmxlIHRlYW1zIHdpdGhpbiBkYXRlIHJhbmdlXHJcbiAgICAgICAgZm9yIChjb25zdCB0ZWFtTmFtZSBvZiBhY2Nlc3NpYmxlVGVhbXMpIHtcclxuICAgICAgICAgICAgLy8gUXVlcnkgZGF0ZXMgYmV0d2VlbiBzdGFydCBhbmQgZW5kXHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGVzUXVlcnkgPSBxdWVyeShcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24oZGIsICd0ZWFtcycsIHRlYW1OYW1lLCAnZGF0ZXMnKSxcclxuICAgICAgICAgICAgICAgIHdoZXJlKCdfX25hbWVfXycsICc+PScsIHN0YXJ0RGF0ZSksXHJcbiAgICAgICAgICAgICAgICB3aGVyZSgnX19uYW1lX18nLCAnPD0nLCBlbmREYXRlKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjb25zdCBkYXRlc1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhkYXRlc1F1ZXJ5KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGF0ZURvYyBvZiBkYXRlc1NuYXBzaG90LmRvY3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBkYXRlRG9jLmlkO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW1wbG95ZWVzU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24oZGIsICd0ZWFtcycsIHRlYW1OYW1lLCAnZGF0ZXMnLCBkYXRlLCAnZW1wbG95ZWVzJylcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbXBEb2Mgb2YgZW1wbG95ZWVzU25hcHNob3QuZG9jcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVtcElkID0gZW1wRG9jLmlkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGZldGNoIG93biB0YXNrcyBmb3IgcmVwb3J0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVtcElkICE9PSB0YXJnZXRFbXBJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhc2tzU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uKGRiLCAndGVhbXMnLCB0ZWFtTmFtZSwgJ2RhdGVzJywgZGF0ZSwgJ2VtcGxveWVlcycsIGVtcElkLCAndGFza3MnKVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVtcFRhc2tzID0gdGFza3NTbmFwc2hvdC5kb2NzLm1hcCh0YXNrRG9jID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlYW1OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbXBJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4udGFza0RvYy5kYXRhKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0YXNrRG9jLmlkXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpLmZpbHRlcih0YXNrID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIGJ5IHRpbWUgaWYgc3RhcnQvZW5kIGhhdmUgdGltZSwgYnV0IHNpbmNlIGRhdGVzIGFyZSBZWVlZLU1NLURELCBpdCdzIGZpbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2suZGF0ZSA+PSBzdGFydERhdGUgJiYgdGFzay5kYXRlIDw9IGVuZERhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFsbFRhc2tzID0gWy4uLmFsbFRhc2tzLCAuLi5lbXBUYXNrc107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhbGxUYXNrcy5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShhLmRhdGUpIC0gbmV3IERhdGUoYi5kYXRlKSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgd2Vla2x5IHRhc2tzOicsIGVycm9yKTtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBhcHBseVRhc2tGaWx0ZXJzID0gKHRhc2tzLCBmaWx0ZXJzLCB1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgaWYgKCF0YXNrcyB8fCB0YXNrcy5sZW5ndGggPT09IDApIHJldHVybiB0YXNrcztcclxuXHJcbiAgICBsZXQgZmlsdGVyZWRUYXNrcyA9IFsuLi50YXNrc107XHJcblxyXG4gICAgLy8gRGF0ZSByYW5nZSBmaWx0ZXJcclxuICAgIGlmIChmaWx0ZXJzLmRhdGVGcm9tKSB7XHJcbiAgICAgICAgZmlsdGVyZWRUYXNrcyA9IGZpbHRlcmVkVGFza3MuZmlsdGVyKHRhc2sgPT4gdGFzay5kYXRlID49IGZpbHRlcnMuZGF0ZUZyb20pO1xyXG4gICAgfVxyXG4gICAgaWYgKGZpbHRlcnMuZGF0ZVRvKSB7XHJcbiAgICAgICAgZmlsdGVyZWRUYXNrcyA9IGZpbHRlcmVkVGFza3MuZmlsdGVyKHRhc2sgPT4gdGFzay5kYXRlIDw9IGZpbHRlcnMuZGF0ZVRvKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUZWFtIGZpbHRlciAodGVjaCBsZWFkcyBvbmx5KVxyXG4gICAgaWYgKGZpbHRlcnMudGVhbSAmJiB1c2VyUHJvZmlsZS5yb2xlID09PSAndGVjaC1sZWFkJykge1xyXG4gICAgICAgIGZpbHRlcmVkVGFza3MgPSBmaWx0ZXJlZFRhc2tzLmZpbHRlcih0YXNrID0+IHRhc2sudGVhbU5hbWUgPT09IGZpbHRlcnMudGVhbSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGVhbSBsZWFkZXIgZmlsdGVyICh0ZWNoIGxlYWRzIG9ubHkpXHJcbiAgICBpZiAoZmlsdGVycy50ZWFtTGVhZGVyICYmIHVzZXJQcm9maWxlLnJvbGUgPT09ICd0ZWNoLWxlYWQnKSB7XHJcbiAgICAgICAgLy8gRmluZCB0YXNrcyBjcmVhdGVkIGJ5IGVtcGxveWVlcyB3aG8gcmVwb3J0IHRvIHRoaXMgdGVhbSBsZWFkZXJcclxuICAgICAgICBmaWx0ZXJlZFRhc2tzID0gZmlsdGVyZWRUYXNrcy5maWx0ZXIodGFzayA9PiB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgcmVxdWlyZXMgY2hlY2tpbmcgaWYgdGhlIHRhc2sncyBlbXBJZCByZXBvcnRzIHRvIHRoZSBzZWxlY3RlZCB0ZWFtIGxlYWRlclxyXG4gICAgICAgICAgICAvLyBGb3Igbm93LCB3ZSdsbCBmaWx0ZXIgYnkgdGVhbSBzaW5jZSB0ZWFtIGxlYWRlcnMgbWFuYWdlIHNwZWNpZmljIHRlYW1zXHJcbiAgICAgICAgICAgIHJldHVybiB0YXNrLmVtcElkID09PSBmaWx0ZXJzLnRlYW1MZWFkZXIgfHxcclxuICAgICAgICAgICAgICAgICh0YXNrLnRlYW1OYW1lICYmIGdldFRlYW1MZWFkZXJGb3JUZWFtKHRhc2sudGVhbU5hbWUpID09PSBmaWx0ZXJzLnRlYW1MZWFkZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEVtcGxveWVlIGZpbHRlciAodGVjaCBsZWFkcyBhbmQgdGVhbSBsZWFkZXJzKVxyXG4gICAgaWYgKGZpbHRlcnMuZW1wbG95ZWUgJiYgKHVzZXJQcm9maWxlLnJvbGUgPT09ICd0ZWNoLWxlYWQnIHx8IHVzZXJQcm9maWxlLnJvbGUgPT09ICd0ZWFtLWxlYWRlcicpKSB7XHJcbiAgICAgICAgZmlsdGVyZWRUYXNrcyA9IGZpbHRlcmVkVGFza3MuZmlsdGVyKHRhc2sgPT4gdGFzay5lbXBJZCA9PT0gZmlsdGVycy5lbXBsb3llZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZpbHRlcmVkVGFza3M7XHJcbn07XHJcblxyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0ZWFtIGxlYWRlciBmb3IgYSB0ZWFtXHJcbmNvbnN0IGdldFRlYW1MZWFkZXJGb3JUZWFtID0gYXN5bmMgKHRlYW1OYW1lKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHRlYW1Eb2MgPSBhd2FpdCBnZXREb2MoZG9jKGRiLCAndGVhbXMnLCB0ZWFtTmFtZSkpO1xyXG4gICAgICAgIGlmICh0ZWFtRG9jLmV4aXN0cygpICYmIHRlYW1Eb2MuZGF0YSgpLnRlYW1MZWFkZXJJZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGVhbURvYy5kYXRhKCkudGVhbUxlYWRlcklkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB0ZWFtIGxlYWRlciBmb3IgdGVhbTonLCB0ZWFtTmFtZSwgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gR2V0IGZpbHRlcmVkIHRhc2tzIHdpdGggYWxsIGFwcGxpZWQgZmlsdGVyc1xyXG5leHBvcnQgY29uc3QgZ2V0RmlsdGVyZWRUYXNrcyA9IGFzeW5jICh1c2VyUHJvZmlsZSwgZmlsdGVycyA9IHt9KSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIEZpcnN0IGdldCBhbGwgYWNjZXNzaWJsZSB0YXNrc1xyXG4gICAgICAgIGNvbnN0IGFsbFRhc2tzID0gYXdhaXQgZ2V0VGFza3ModXNlclByb2ZpbGUpO1xyXG5cclxuICAgICAgICAvLyBUaGVuIGFwcGx5IGZpbHRlcnNcclxuICAgICAgICBjb25zdCBmaWx0ZXJlZFRhc2tzID0gYXBwbHlUYXNrRmlsdGVycyhhbGxUYXNrcywgZmlsdGVycywgdXNlclByb2ZpbGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gZmlsdGVyZWRUYXNrcztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBmaWx0ZXJlZCB0YXNrczonLCBlcnJvcik7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIERST1BET1dOUyBXSVRIIFVTRVIgQ09OVEVYVCAtLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLy8gR2V0IGRyb3Bkb3duIGRhdGEgZm9yIGEgdGVhbSAod2l0aCB1c2VyIHBlcm1pc3Npb24gY2hlY2spXHJcbmV4cG9ydCBjb25zdCBnZXRUZWFtRHJvcGRvd25EYXRhID0gYXN5bmMgKHRlYW1OYW1lLCBmaWVsZCwgdXNlclByb2ZpbGUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdXNlciBjYW4gYWNjZXNzIHRoaXMgdGVhbVxyXG4gICAgICAgIGlmICghY2FuVXNlckFjY2Vzc1RlYW0odXNlclByb2ZpbGUsIHRlYW1OYW1lKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyB0aGlzIHRlYW0gZGF0YScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIHByZWRlZmluZWQgdmFsdWVzIGZvciBzcGVjaWZpYyBmaWVsZHMgLSBzYW1lIGZvciBhbGwgdXNlcnNcclxuICAgICAgICBpZiAoUFJFREVGSU5FRF9WQUxVRVNbZmllbGRdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQUkVERUZJTkVEX1ZBTFVFU1tmaWVsZF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGb3IgY3VzdG9tIGRyb3Bkb3duIGRhdGEsIGZldGNoIGZyb20gRmlyZXN0b3JlXHJcbiAgICAgICAgY29uc3QgZG9jUmVmID0gZG9jKGRiLCAndGVhbXMnLCB0ZWFtTmFtZSwgJ2Ryb3Bkb3duRGF0YScsIGZpZWxkKTtcclxuICAgICAgICBjb25zdCBkb2NTbmFwID0gYXdhaXQgZ2V0RG9jKGRvY1JlZik7XHJcbiAgICAgICAgaWYgKGRvY1NuYXAuZXhpc3RzKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRvY1NuYXAuZGF0YSgpLnZhbHVlcyB8fCBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHRlYW0gZHJvcGRvd24gZGF0YTonLCBlcnJvcik7XHJcbiAgICAgICAgLy8gQWx3YXlzIHJldHVybiBwcmVkZWZpbmVkIHZhbHVlcyBhcyBmYWxsYmFja1xyXG4gICAgICAgIHJldHVybiBQUkVERUZJTkVEX1ZBTFVFU1tmaWVsZF0gfHwgW107XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBTYXZlIGRyb3Bkb3duIGRhdGEgZm9yIGEgdGVhbSAod2l0aCB1c2VyIHBlcm1pc3Npb24gY2hlY2spXHJcbmV4cG9ydCBjb25zdCBzYXZlVGVhbURyb3Bkb3duRGF0YSA9IGFzeW5jICh0ZWFtTmFtZSwgZmllbGQsIHZhbHVlcywgdXNlclByb2ZpbGUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdXNlciBjYW4gbW9kaWZ5IHRoaXMgdGVhbSBkYXRhIChvbmx5IHRlYW0gbGVhZGVycyBhbmQgdGVjaCBsZWFkcylcclxuICAgICAgICBpZiAoIWNhblVzZXJBY2Nlc3NUZWFtKHVzZXJQcm9maWxlLCB0ZWFtTmFtZSkgfHwgdXNlclByb2ZpbGUucm9sZSA9PT0gJ2VtcGxveWVlJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIG1vZGlmeSB0ZWFtIGRhdGEnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERvbid0IHNhdmUgcHJlZGVmaW5lZCB2YWx1ZXMgdG8gZGF0YWJhc2VcclxuICAgICAgICBpZiAoUFJFREVGSU5FRF9WQUxVRVNbZmllbGRdKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ2Fubm90IHNhdmUgcHJlZGVmaW5lZCB2YWx1ZXMgZm9yIGZpZWxkOiAke2ZpZWxkfWApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBkb2NSZWYgPSBkb2MoZGIsICd0ZWFtcycsIHRlYW1OYW1lLCAnZHJvcGRvd25EYXRhJywgZmllbGQpO1xyXG4gICAgICAgIGF3YWl0IHNldERvYyhkb2NSZWYsIHsgdmFsdWVzIH0sIHsgbWVyZ2U6IHRydWUgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyB0ZWFtIGRyb3Bkb3duIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0gVEVBTVMgV0lUSCBVU0VSIENPTlRFWFQgLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8vIEdldCB0ZWFtcyBhY2Nlc3NpYmxlIHRvIHVzZXJcclxuZXhwb3J0IGNvbnN0IGdldFRlYW1zID0gYXN5bmMgKHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICghdXNlclByb2ZpbGUpIHJldHVybiBbXTtcclxuICAgICAgICByZXR1cm4gZ2V0QWNjZXNzaWJsZVRlYW1zKHVzZXJQcm9maWxlKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB0ZWFtczonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0gUFJPSkVDVFMgV0lUSCBVU0VSIENPTlRFWFQgLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8vIEdldCB0ZWFtLXNwZWNpZmljIHByb2plY3RzICh3aXRoIHVzZXIgcGVybWlzc2lvbiBjaGVjaylcclxuZXhwb3J0IGNvbnN0IGdldFRlYW1Qcm9qZWN0cyA9IGFzeW5jICh0ZWFtTmFtZSwgdXNlclByb2ZpbGUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCFjYW5Vc2VyQWNjZXNzVGVhbSh1c2VyUHJvZmlsZSwgdGVhbU5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IGdldFRlYW1Ecm9wZG93bkRhdGEodGVhbU5hbWUsICdwcm9qZWN0cycsIHVzZXJQcm9maWxlKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB0ZWFtIHByb2plY3RzOicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBBZGQgbmV3IHByb2plY3QgdG8gdGVhbSAod2l0aCB1c2VyIHBlcm1pc3Npb24gY2hlY2spXHJcbmV4cG9ydCBjb25zdCBhZGRUZWFtUHJvamVjdCA9IGFzeW5jICh0ZWFtTmFtZSwgcHJvamVjdElkLCBwcm9qZWN0TmFtZSwgdXNlclByb2ZpbGUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCFwcm9qZWN0SWQgfHwgIXByb2plY3ROYW1lKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmICghY2FuVXNlckFjY2Vzc1RlYW0odXNlclByb2ZpbGUsIHRlYW1OYW1lKSB8fCB1c2VyUHJvZmlsZS5yb2xlID09PSAnZW1wbG95ZWUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gU2lsZW50bHkgZmFpbCBmb3IgZW1wbG95ZWVzXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwcm9qZWN0cyA9IGF3YWl0IGdldFRlYW1Qcm9qZWN0cyh0ZWFtTmFtZSwgdXNlclByb2ZpbGUpO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IHByb2plY3RzLmZpbmQocCA9PiBwLmlkID09PSBwcm9qZWN0SWQpO1xyXG4gICAgICAgIGlmICghZXhpc3RzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb2plY3RzID0gWy4uLnByb2plY3RzLCB7IGlkOiBwcm9qZWN0SWQsIG5hbWU6IHByb2plY3ROYW1lIH1dO1xyXG4gICAgICAgICAgICBhd2FpdCBzYXZlVGVhbURyb3Bkb3duRGF0YSh0ZWFtTmFtZSwgJ3Byb2plY3RzJywgbmV3UHJvamVjdHMsIHVzZXJQcm9maWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyB0ZWFtIHByb2plY3Q6JywgZXJyb3IpO1xyXG4gICAgICAgIC8vIERvbid0IHRocm93IGVycm9yIHRvIHByZXZlbnQgdGFzayBjcmVhdGlvbiBmYWlsdXJlXHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSBFTVBMT1lFRVMgV0lUSCBVU0VSIENPTlRFWFQgLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8vIEdldCB0ZWFtLXNwZWNpZmljIGVtcGxveWVlcyAod2l0aCB1c2VyIHBlcm1pc3Npb24gY2hlY2spXHJcbmV4cG9ydCBjb25zdCBnZXRUZWFtRW1wbG95ZWVzID0gYXN5bmMgKHRlYW1OYW1lLCB1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoIWNhblVzZXJBY2Nlc3NUZWFtKHVzZXJQcm9maWxlLCB0ZWFtTmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXdhaXQgZ2V0VGVhbURyb3Bkb3duRGF0YSh0ZWFtTmFtZSwgJ2VtcGxveWVlcycsIHVzZXJQcm9maWxlKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB0ZWFtIGVtcGxveWVlczonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gQWRkIG5ldyBlbXBsb3llZSB0byB0ZWFtICh3aXRoIHVzZXIgcGVybWlzc2lvbiBjaGVjaylcclxuZXhwb3J0IGNvbnN0IGFkZFRlYW1FbXBsb3llZSA9IGFzeW5jICh0ZWFtTmFtZSwgZW1wSWQsIGVtcE5hbWUsIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICghZW1wSWQgfHwgIWVtcE5hbWUpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKCFjYW5Vc2VyQWNjZXNzVGVhbSh1c2VyUHJvZmlsZSwgdGVhbU5hbWUpIHx8IHVzZXJQcm9maWxlLnJvbGUgPT09ICdlbXBsb3llZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyBTaWxlbnRseSBmYWlsIGZvciBlbXBsb3llZXNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGVtcGxveWVlcyA9IGF3YWl0IGdldFRlYW1FbXBsb3llZXModGVhbU5hbWUsIHVzZXJQcm9maWxlKTtcclxuICAgICAgICBjb25zdCBleGlzdHMgPSBlbXBsb3llZXMuZmluZChlID0+IGUuaWQgPT09IGVtcElkKTtcclxuICAgICAgICBpZiAoIWV4aXN0cykge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdFbXBsb3llZXMgPSBbLi4uZW1wbG95ZWVzLCB7IGlkOiBlbXBJZCwgbmFtZTogZW1wTmFtZSB9XTtcclxuICAgICAgICAgICAgYXdhaXQgc2F2ZVRlYW1Ecm9wZG93bkRhdGEodGVhbU5hbWUsICdlbXBsb3llZXMnLCBuZXdFbXBsb3llZXMsIHVzZXJQcm9maWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyB0ZWFtIGVtcGxveWVlOicsIGVycm9yKTtcclxuICAgICAgICAvLyBEb24ndCB0aHJvdyBlcnJvciB0byBwcmV2ZW50IHRhc2sgY3JlYXRpb24gZmFpbHVyZVxyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0gQ0xJRU5UUyBXSVRIIFVTRVIgQ09OVEVYVCAtLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLy8gR2V0IHRlYW0tc3BlY2lmaWMgY2xpZW50cyAod2l0aCB1c2VyIHBlcm1pc3Npb24gY2hlY2spXHJcbmV4cG9ydCBjb25zdCBnZXRUZWFtQ2xpZW50cyA9IGFzeW5jICh0ZWFtTmFtZSwgdXNlclByb2ZpbGUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCFjYW5Vc2VyQWNjZXNzVGVhbSh1c2VyUHJvZmlsZSwgdGVhbU5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IGdldFRlYW1Ecm9wZG93bkRhdGEodGVhbU5hbWUsICdjbGllbnRzJywgdXNlclByb2ZpbGUpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHRlYW0gY2xpZW50czonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gQWRkIG5ldyBjbGllbnQgdG8gdGVhbSAod2l0aCB1c2VyIHBlcm1pc3Npb24gY2hlY2spXHJcbmV4cG9ydCBjb25zdCBhZGRUZWFtQ2xpZW50ID0gYXN5bmMgKHRlYW1OYW1lLCBjbGllbnRJZCwgY2xpZW50TmFtZSwgdXNlclByb2ZpbGUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCFjbGllbnRJZCB8fCAhY2xpZW50TmFtZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAoIWNhblVzZXJBY2Nlc3NUZWFtKHVzZXJQcm9maWxlLCB0ZWFtTmFtZSkgfHwgdXNlclByb2ZpbGUucm9sZSA9PT0gJ2VtcGxveWVlJykge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIFNpbGVudGx5IGZhaWwgZm9yIGVtcGxveWVlc1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY2xpZW50cyA9IGF3YWl0IGdldFRlYW1DbGllbnRzKHRlYW1OYW1lLCB1c2VyUHJvZmlsZSk7XHJcbiAgICAgICAgY29uc3QgZXhpc3RzID0gY2xpZW50cy5maW5kKGMgPT4gYy5pZCA9PT0gY2xpZW50SWQpO1xyXG4gICAgICAgIGlmICghZXhpc3RzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NsaWVudHMgPSBbLi4uY2xpZW50cywgeyBpZDogY2xpZW50SWQsIG5hbWU6IGNsaWVudE5hbWUgfV07XHJcbiAgICAgICAgICAgIGF3YWl0IHNhdmVUZWFtRHJvcGRvd25EYXRhKHRlYW1OYW1lLCAnY2xpZW50cycsIG5ld0NsaWVudHMsIHVzZXJQcm9maWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyB0ZWFtIGNsaWVudDonLCBlcnJvcik7XHJcbiAgICAgICAgLy8gRG9uJ3QgdGhyb3cgZXJyb3IgdG8gcHJldmVudCB0YXNrIGNyZWF0aW9uIGZhaWx1cmVcclxuICAgIH1cclxufTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIFVUSUxJVFkgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vLyBHZXQgcHJlZGVmaW5lZCB2YWx1ZXMgZm9yIGEgc3BlY2lmaWMgZmllbGRcclxuZXhwb3J0IGNvbnN0IGdldFByZWRlZmluZWRWYWx1ZXMgPSAoZmllbGQpID0+IHtcclxuICAgIHJldHVybiBQUkVERUZJTkVEX1ZBTFVFU1tmaWVsZF0gfHwgW107XHJcbn07XHJcblxyXG4vLyBDaGVjayBpZiBmaWVsZCBoYXMgcHJlZGVmaW5lZCB2YWx1ZXNcclxuZXhwb3J0IGNvbnN0IGlzUHJlZGVmaW5lZEZpZWxkID0gKGZpZWxkKSA9PiB7XHJcbiAgICByZXR1cm4gISFQUkVERUZJTkVEX1ZBTFVFU1tmaWVsZF07XHJcbn07XHJcblxyXG4vLyBDaGVjayBpZiB0ZWFtIGRvY3VtZW50IGV4aXN0c1xyXG5leHBvcnQgY29uc3QgdGVhbUV4aXN0cyA9IGFzeW5jICh0ZWFtTmFtZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB0ZWFtRG9jID0gYXdhaXQgZ2V0RG9jKGRvYyhkYiwgJ3RlYW1zJywgdGVhbU5hbWUpKTtcclxuICAgICAgICByZXR1cm4gdGVhbURvYy5leGlzdHMoKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gSW5pdGlhbGl6ZSBkZWZhdWx0IGRyb3Bkb3duIHZhbHVlcyBmb3IgYSB0ZWFtIChvbmx5IGlmIHRlYW0gZG9lc24ndCBleGlzdCB5ZXQpXHJcbmV4cG9ydCBjb25zdCBpbml0aWFsaXplVGVhbURlZmF1bHRzID0gYXN5bmMgKHRlYW1OYW1lKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IGF3YWl0IHRlYW1FeGlzdHModGVhbU5hbWUpO1xyXG4gICAgICAgIGlmICghZXhpc3RzKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHNldERvYyhkb2MoZGIsICd0ZWFtcycsIHRlYW1OYW1lKSwgeyBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyB0ZWFtIGRlZmF1bHRzOicsIGVycm9yKTtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxufTsiXSwibmFtZXMiOlsiZGIiLCJjb2xsZWN0aW9uIiwiYWRkRG9jIiwiZ2V0RG9jcyIsImRvYyIsInVwZGF0ZURvYyIsImRlbGV0ZURvYyIsImdldERvYyIsInNldERvYyIsInF1ZXJ5Iiwid2hlcmUiLCJQUkVERUZJTkVEX1ZBTFVFUyIsInBlcmNlbnRhZ2VDb21wbGV0aW9uIiwic3RhdHVzIiwid29ya1R5cGUiLCJnZXRVc2VyUHJvZmlsZSIsInVzZXJJZCIsInVzZXJEb2MiLCJleGlzdHMiLCJkYXRhIiwiZXJyb3IiLCJjb25zb2xlIiwidXBkYXRlVXNlclByb2ZpbGUiLCJwcm9maWxlRGF0YSIsIm1lcmdlIiwiYWRkVGFzayIsInRhc2siLCJ1c2VyUHJvZmlsZSIsImlzRWRpdCIsInRhc2tJZCIsInJvbGUiLCJ0ZWFtTmFtZSIsImNhblVzZXJBY2Nlc3NFbXBsb3llZSIsImVtcElkIiwiRXJyb3IiLCJpbml0aWFsaXplVGVhbURlZmF1bHRzIiwiZGF0ZVJlZiIsImRhdGUiLCJjcmVhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJlbXBSZWYiLCJuYW1lIiwiZW1wTmFtZSIsImFkZFRlYW1FbXBsb3llZSIsImNsaWVudElkIiwiY2xpZW50TmFtZSIsImFkZFRlYW1DbGllbnQiLCJwcm9qZWN0SWQiLCJwcm9qZWN0TmFtZSIsImFkZFRlYW1Qcm9qZWN0IiwiZG9jUmVmIiwidGFza0RhdGEiLCJ1cGRhdGVkQXQiLCJ1cGRhdGVkQnkiLCJpZCIsImNyZWF0ZWRCeSIsImdldFRhc2tzIiwidGVhbUZpbHRlciIsImFsbFRhc2tzIiwiYWNjZXNzaWJsZVRlYW1zIiwibWFuYWdlZFRlYW1zIiwiZmlsdGVyIiwidGVhbSIsImRhdGVzU25hcHNob3QiLCJkYXRlRG9jIiwiZG9jcyIsImVtcGxveWVlc1NuYXBzaG90IiwiZW1wRG9jIiwidGFza3NTbmFwc2hvdCIsImVtcFRhc2tzIiwibWFwIiwidGFza0RvYyIsInVwZGF0ZVRhc2siLCJ0YXNrUmVmIiwiZGVsZXRlVGFzayIsImNhblVzZXJBY2Nlc3NUZWFtIiwibG9nIiwiY2FuQWNjZXNzTWFuYWdlZFRlYW0iLCJpbmNsdWRlcyIsImNhbkFjY2Vzc1RlY2hMZWFkc1RlYW0iLCJ0ZWNoTGVhZEFjY2VzcyIsInJlcXVlc3RlZFRlYW0iLCJmaW5hbEFjY2VzcyIsInJlZ3VsYXJBY2Nlc3MiLCJ1c2VyVGVhbSIsImFjY2VzcyIsImdldEFjY2Vzc2libGVUZWFtcyIsImdldEZpbHRlck9wdGlvbnMiLCJvcHRpb25zIiwidGVhbUxlYWRlcnMiLCJlbXBsb3llZXMiLCJ0ZWFtcyIsInRlYW1MZWFkZXJzU2V0IiwiU2V0IiwiZW1wbG95ZWVzU2V0IiwidGVhbUxlYWRlcnNRdWVyeSIsInRlYW1MZWFkZXJzU25hcHNob3QiLCJmb3JFYWNoIiwiYWRkIiwiSlNPTiIsInN0cmluZ2lmeSIsImVtcGxveWVlc1F1ZXJ5IiwiQXJyYXkiLCJmcm9tIiwiaXRlbSIsInBhcnNlIiwicHVzaCIsImlzQ3VycmVudFVzZXIiLCJnZXRXZWVrbHlUYXNrcyIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJ0YXJnZXRFbXBJZCIsImRhdGVzUXVlcnkiLCJzb3J0IiwiYSIsImIiLCJhcHBseVRhc2tGaWx0ZXJzIiwidGFza3MiLCJmaWx0ZXJzIiwibGVuZ3RoIiwiZmlsdGVyZWRUYXNrcyIsImRhdGVGcm9tIiwiZGF0ZVRvIiwidGVhbUxlYWRlciIsImdldFRlYW1MZWFkZXJGb3JUZWFtIiwiZW1wbG95ZWUiLCJ0ZWFtRG9jIiwidGVhbUxlYWRlcklkIiwiZ2V0RmlsdGVyZWRUYXNrcyIsImdldFRlYW1Ecm9wZG93bkRhdGEiLCJmaWVsZCIsImRvY1NuYXAiLCJ2YWx1ZXMiLCJzYXZlVGVhbURyb3Bkb3duRGF0YSIsIndhcm4iLCJnZXRUZWFtcyIsImdldFRlYW1Qcm9qZWN0cyIsInByb2plY3RzIiwiZmluZCIsInAiLCJuZXdQcm9qZWN0cyIsImdldFRlYW1FbXBsb3llZXMiLCJlIiwibmV3RW1wbG95ZWVzIiwiZ2V0VGVhbUNsaWVudHMiLCJjbGllbnRzIiwiYyIsIm5ld0NsaWVudHMiLCJnZXRQcmVkZWZpbmVkVmFsdWVzIiwiaXNQcmVkZWZpbmVkRmllbGQiLCJ0ZWFtRXhpc3RzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./lib/firebase.js\n"));

/***/ })

});