"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./lib/firebase.js":
/*!*************************!*\
  !*** ./lib/firebase.js ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addTask: () => (/* binding */ addTask),\n/* harmony export */   addTeamClient: () => (/* binding */ addTeamClient),\n/* harmony export */   addTeamEmployee: () => (/* binding */ addTeamEmployee),\n/* harmony export */   addTeamProject: () => (/* binding */ addTeamProject),\n/* harmony export */   applyTaskFilters: () => (/* binding */ applyTaskFilters),\n/* harmony export */   canUserAccessEmployee: () => (/* binding */ canUserAccessEmployee),\n/* harmony export */   canUserAccessTeam: () => (/* binding */ canUserAccessTeam),\n/* harmony export */   deleteTask: () => (/* binding */ deleteTask),\n/* harmony export */   getAccessibleTeams: () => (/* binding */ getAccessibleTeams),\n/* harmony export */   getFilterOptions: () => (/* binding */ getFilterOptions),\n/* harmony export */   getFilteredTasks: () => (/* binding */ getFilteredTasks),\n/* harmony export */   getPredefinedValues: () => (/* binding */ getPredefinedValues),\n/* harmony export */   getTasks: () => (/* binding */ getTasks),\n/* harmony export */   getTeamClients: () => (/* binding */ getTeamClients),\n/* harmony export */   getTeamDropdownData: () => (/* binding */ getTeamDropdownData),\n/* harmony export */   getTeamEmployees: () => (/* binding */ getTeamEmployees),\n/* harmony export */   getTeamProjects: () => (/* binding */ getTeamProjects),\n/* harmony export */   getTeams: () => (/* binding */ getTeams),\n/* harmony export */   getUserProfile: () => (/* binding */ getUserProfile),\n/* harmony export */   initializeTeamDefaults: () => (/* binding */ initializeTeamDefaults),\n/* harmony export */   isPredefinedField: () => (/* binding */ isPredefinedField),\n/* harmony export */   saveTeamDropdownData: () => (/* binding */ saveTeamDropdownData),\n/* harmony export */   teamExists: () => (/* binding */ teamExists),\n/* harmony export */   updateTask: () => (/* binding */ updateTask),\n/* harmony export */   updateUserProfile: () => (/* binding */ updateUserProfile)\n/* harmony export */ });\n/* harmony import */ var _firebaseConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./firebaseConfig */ \"(pages-dir-browser)/./lib/firebaseConfig.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(pages-dir-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n// lib/firebase.js - Cleaned up with optimized filtering and no unnecessary logs\n\n\n// -------------------- PREDEFINED VALUES --------------------\nconst PREDEFINED_VALUES = {\n    percentageCompletion: [\n        '5',\n        '10',\n        '25',\n        '40',\n        '50',\n        '65',\n        '75',\n        '85',\n        '90',\n        '100'\n    ],\n    status: [\n        'Completed',\n        'In Progress',\n        'On Hold'\n    ],\n    workType: [\n        'Full-day',\n        'Half-day',\n        'Relaxation'\n    ]\n};\n// -------------------- USER MANAGEMENT --------------------\n// Get user profile\nconst getUserProfile = async (userId)=>{\n    try {\n        const userDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users', userId));\n        if (userDoc.exists()) {\n            return userDoc.data();\n        }\n        return null;\n    } catch (error) {\n        console.error('Error getting user profile:', error);\n        return null;\n    }\n};\n// Update user profile\nconst updateUserProfile = async (userId, profileData)=>{\n    try {\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users', userId), profileData, {\n            merge: true\n        });\n    } catch (error) {\n        console.error('Error updating user profile:', error);\n        throw error;\n    }\n};\n// -------------------- TASKS WITH USER CONTEXT --------------------\nconst addTask = async (task, userProfile)=>{\n    try {\n        if (userProfile.role === 'tech-lead') {\n            task.teamName = 'techLeads';\n        }\n        // Validate user can add task to this team/employee\n        if (!canUserAccessEmployee(userProfile, task.teamName, task.empId)) {\n            throw new Error('You do not have permission to add tasks for this employee');\n        }\n        await initializeTeamDefaults(task.teamName);\n        // Ensure date document exists\n        const dateRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', task.teamName, 'dates', task.date);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(dateRef, {\n            createdAt: new Date().toISOString()\n        }, {\n            merge: true\n        });\n        // Ensure employee document exists with name\n        const empRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', task.teamName, 'dates', task.date, 'employees', task.empId);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(empRef, {\n            name: task.empName\n        }, {\n            merge: true\n        });\n        // Auto-save new employee to team employees if not exists\n        if (task.empId && task.empName) {\n            await addTeamEmployee(task.teamName, task.empId, task.empName);\n        }\n        // Auto-save new client to team clients if not exists\n        if (task.clientId && task.clientName) {\n            await addTeamClient(task.teamName, task.clientId, task.clientName);\n        }\n        // Auto-save new project to team projects if not exists\n        if (task.projectId && task.projectName) {\n            await addTeamProject(task.teamName, task.projectId, task.projectName);\n        }\n        const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', task.teamName, 'dates', task.date, 'employees', task.empId, 'tasks'), {\n            ...task,\n            createdAt: new Date().toISOString(),\n            createdBy: userProfile.empId\n        });\n        // Return full task object with ID for consistency\n        return {\n            ...task,\n            id: docRef.id,\n            createdAt: new Date().toISOString(),\n            createdBy: userProfile.empId\n        };\n    } catch (error) {\n        console.error('Error adding task:', error);\n        throw error;\n    }\n};\n// Get tasks based on user permissions - Optimized without logs\nconst getTasks = async function(userProfile) {\n    let teamFilter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n    try {\n        if (!userProfile) {\n            throw new Error('User profile is required');\n        }\n        let allTasks = [];\n        // Determine which teams user can access\n        let accessibleTeams;\n        switch(userProfile.role){\n            case 'tech-lead':\n                accessibleTeams = [\n                    ...userProfile.managedTeams || [],\n                    'techLeads'\n                ];\n                break;\n            case 'team-leader':\n            case 'employee':\n                accessibleTeams = [\n                    userProfile.teamName\n                ];\n                break;\n            default:\n                return [];\n        }\n        // Apply team filter if provided\n        if (teamFilter && teamFilter !== 'all') {\n            accessibleTeams = accessibleTeams.filter((team)=>team === teamFilter);\n        }\n        // Fetch tasks from accessible teams\n        for (const teamName of accessibleTeams){\n            const datesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates'));\n            for (const dateDoc of datesSnapshot.docs){\n                const date = dateDoc.id;\n                const employeesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', date, 'employees'));\n                for (const empDoc of employeesSnapshot.docs){\n                    const empId = empDoc.id;\n                    // Check if user can access this employee's data\n                    if (!canUserAccessEmployee(userProfile, teamName, empId)) {\n                        continue;\n                    }\n                    const tasksSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', date, 'employees', empId, 'tasks'));\n                    const empTasks = tasksSnapshot.docs.map((taskDoc)=>({\n                            teamName,\n                            date,\n                            empId,\n                            ...taskDoc.data(),\n                            id: taskDoc.id\n                        }));\n                    allTasks = [\n                        ...allTasks,\n                        ...empTasks\n                    ];\n                }\n            }\n        }\n        return allTasks;\n    } catch (error) {\n        console.error('Error getting tasks:', error);\n        throw error;\n    }\n};\n// Update a task (with user permission check)\nconst updateTask = async (teamName, date, empId, taskId, taskData, userProfile)=>{\n    try {\n        // Check if user can update this task\n        if (!canUserAccessEmployee(userProfile, teamName, empId)) {\n            throw new Error('You do not have permission to update this task');\n        }\n        const taskRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', date, 'employees', empId, 'tasks', taskId);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(taskRef, {\n            ...taskData,\n            updatedAt: new Date().toISOString(),\n            updatedBy: userProfile.empId\n        });\n    } catch (error) {\n        console.error('Error updating task:', error);\n        throw error;\n    }\n};\n// Delete a task (with user permission check)\nconst deleteTask = async (teamName, date, empId, taskId, userProfile)=>{\n    try {\n        // Check if user can delete this task\n        if (!canUserAccessEmployee(userProfile, teamName, empId)) {\n            throw new Error('You do not have permission to delete this task');\n        }\n        const taskRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dates', date, 'employees', empId, 'tasks', taskId);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.deleteDoc)(taskRef);\n    } catch (error) {\n        console.error('Error deleting task:', error);\n        throw error;\n    }\n};\n// -------------------- PERMISSION HELPERS - Cleaned without logs --------------------\n// Check if user can access specific team\nconst canUserAccessTeam = (userProfile, teamName)=>{\n    if (!userProfile) {\n        return false;\n    }\n    switch(userProfile.role){\n        case 'tech-lead':\n            var _userProfile_managedTeams;\n            // Tech leads can access teams they manage or their personal team\n            const canAccessManagedTeam = (_userProfile_managedTeams = userProfile.managedTeams) === null || _userProfile_managedTeams === void 0 ? void 0 : _userProfile_managedTeams.includes(teamName);\n            const canAccessTechLeadsTeam = teamName === 'techLeads';\n            return canAccessManagedTeam || canAccessTechLeadsTeam;\n        case 'team-leader':\n        case 'employee':\n            return userProfile.teamName === teamName;\n        default:\n            return false;\n    }\n};\n// Check if user can access specific employee's data\nconst canUserAccessEmployee = (userProfile, teamName, empId)=>{\n    if (!userProfile) return false;\n    switch(userProfile.role){\n        case 'tech-lead':\n            return userProfile.managedTeams.includes(teamName);\n        case 'team-leader':\n            return userProfile.teamName === teamName;\n        case 'employee':\n            return userProfile.teamName === teamName && userProfile.empId === empId;\n        default:\n            return false;\n    }\n};\n// Get accessible teams for current user\nconst getAccessibleTeams = (userProfile)=>{\n    if (!userProfile) return [];\n    switch(userProfile.role){\n        case 'tech-lead':\n            return userProfile.managedTeams || [];\n        case 'team-leader':\n        case 'employee':\n            return [\n                userProfile.teamName\n            ];\n        default:\n            return [];\n    }\n};\n// -------------------- FILTER BASED ON ROLES --------------------\nconst getFilterOptions = async (userProfile)=>{\n    try {\n        const options = {\n            teamLeaders: [],\n            employees: [],\n            teams: []\n        };\n        if (!userProfile) return options;\n        if (userProfile.role === 'tech-lead') {\n            options.teams = userProfile.managedTeams || [];\n            // Get team leaders and employees from managed teams\n            const teamLeadersSet = new Set();\n            const employeesSet = new Set();\n            for (const teamName of userProfile.managedTeams){\n                // Get team leaders\n                const teamLeadersQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('role', '==', 'team-leader'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('teamName', '==', teamName));\n                const teamLeadersSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(teamLeadersQuery);\n                teamLeadersSnapshot.forEach((doc)=>{\n                    const data = doc.data();\n                    teamLeadersSet.add(JSON.stringify({\n                        empId: data.empId,\n                        empName: data.empName,\n                        teamName: data.teamName\n                    }));\n                });\n                // Get employees\n                const employeesQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('role', '==', 'employee'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('teamName', '==', teamName));\n                const employeesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(employeesQuery);\n                employeesSnapshot.forEach((doc)=>{\n                    const data = doc.data();\n                    employeesSet.add(JSON.stringify({\n                        empId: data.empId,\n                        empName: data.empName,\n                        teamName: data.teamName\n                    }));\n                });\n            }\n            options.teamLeaders = Array.from(teamLeadersSet).map((str)=>JSON.parse(str));\n            options.employees = Array.from(employeesSet).map((str)=>JSON.parse(str));\n        } else if (userProfile.role === 'team-leader') {\n            options.teamLeaders = [\n                {\n                    empId: userProfile.empId,\n                    empName: userProfile.empName,\n                    teamName: userProfile.teamName\n                }\n            ];\n            // Get employees for this team\n            const employeesQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'users'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('role', '==', 'employee'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)('teamName', '==', userProfile.teamName));\n            const employeesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(employeesQuery);\n            options.employees = employeesSnapshot.docs.map((doc)=>({\n                    empId: doc.data().empId,\n                    empName: doc.data().empName,\n                    teamName: doc.data().teamName\n                }));\n        } else if (userProfile.role === 'employee') {\n            options.employees = [\n                {\n                    empId: userProfile.empId,\n                    empName: userProfile.empName,\n                    teamName: userProfile.teamName\n                }\n            ];\n        }\n        return options;\n    } catch (error) {\n        console.error('Error getting filter options:', error);\n        return {\n            teamLeaders: [],\n            employees: [],\n            teams: []\n        };\n    }\n};\n// Optimized task filtering using createdAt for date matching\nconst applyTaskFilters = (tasks, filters, userProfile)=>{\n    if (!tasks || tasks.length === 0) return tasks;\n    let filteredTasks = [\n        ...tasks\n    ];\n    // Date range filter using createdAt\n    if (filters.dateFrom) {\n        filteredTasks = filteredTasks.filter((task)=>{\n            if (!task.createdAt) return false;\n            const creationDate = task.createdAt.split('T')[0];\n            return creationDate >= filters.dateFrom;\n        });\n    }\n    if (filters.dateTo) {\n        filteredTasks = filteredTasks.filter((task)=>{\n            if (!task.createdAt) return false;\n            const creationDate = task.createdAt.split('T')[0];\n            return creationDate <= filters.dateTo;\n        });\n    }\n    // Team filter (tech leads only)\n    if (filters.team && userProfile.role === 'tech-lead') {\n        filteredTasks = filteredTasks.filter((task)=>task.teamName === filters.team);\n    }\n    // Team leader filter (tech leads only)\n    if (filters.teamLeader && userProfile.role === 'tech-lead') {\n        filteredTasks = filteredTasks.filter((task)=>task.empId === filters.teamLeader);\n    }\n    // Employee filter (tech leads and team leaders)\n    if (filters.employee && (userProfile.role === 'tech-lead' || userProfile.role === 'team-leader')) {\n        filteredTasks = filteredTasks.filter((task)=>task.empId === filters.employee);\n    }\n    return filteredTasks;\n};\n// Get filtered tasks with all applied filters\nconst getFilteredTasks = async function(userProfile) {\n    let filters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    try {\n        // First get all accessible tasks\n        const allTasks = await getTasks(userProfile);\n        // Then apply filters\n        const filteredTasks = applyTaskFilters(allTasks, filters, userProfile);\n        return filteredTasks;\n    } catch (error) {\n        console.error('Error getting filtered tasks:', error);\n        throw error;\n    }\n};\n// -------------------- DROPDOWNS WITH USER CONTEXT --------------------\n// Get dropdown data for a team (with user permission check)\nconst getTeamDropdownData = async (teamName, field, userProfile)=>{\n    try {\n        // Check if user can access this team\n        if (!canUserAccessTeam(userProfile, teamName)) {\n            throw new Error('You do not have permission to access this team data');\n        }\n        // Return predefined values for specific fields - same for all users\n        if (PREDEFINED_VALUES[field]) {\n            return PREDEFINED_VALUES[field];\n        }\n        // For custom dropdown data, fetch from Firestore\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dropdownData', field);\n        const docSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(docRef);\n        if (docSnap.exists()) {\n            return docSnap.data().values || [];\n        }\n        return [];\n    } catch (error) {\n        console.error('Error getting team dropdown data:', error);\n        // Always return predefined values as fallback\n        return PREDEFINED_VALUES[field] || [];\n    }\n};\n// Save dropdown data for a team (with user permission check)\nconst saveTeamDropdownData = async (teamName, field, values, userProfile)=>{\n    try {\n        // Check if user can modify this team data (only team leaders and tech leads)\n        if (!canUserAccessTeam(userProfile, teamName) || userProfile.role === 'employee') {\n            throw new Error('You do not have permission to modify team data');\n        }\n        // Don't save predefined values to database\n        if (PREDEFINED_VALUES[field]) {\n            console.warn(\"Cannot save predefined values for field: \".concat(field));\n            return;\n        }\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName, 'dropdownData', field);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(docRef, {\n            values\n        }, {\n            merge: true\n        });\n    } catch (error) {\n        console.error('Error saving team dropdown data:', error);\n        throw error;\n    }\n};\n// -------------------- TEAMS WITH USER CONTEXT --------------------\n// Get teams accessible to user\nconst getTeams = async (userProfile)=>{\n    try {\n        if (!userProfile) return [];\n        return getAccessibleTeams(userProfile);\n    } catch (error) {\n        console.error('Error getting teams:', error);\n        return [];\n    }\n};\n// -------------------- PROJECTS WITH USER CONTEXT --------------------\n// Get team-specific projects (with user permission check)\nconst getTeamProjects = async (teamName, userProfile)=>{\n    try {\n        if (!canUserAccessTeam(userProfile, teamName)) {\n            return [];\n        }\n        return await getTeamDropdownData(teamName, 'projects', userProfile);\n    } catch (error) {\n        console.error('Error getting team projects:', error);\n        return [];\n    }\n};\n// Add new project to team (with user permission check)\nconst addTeamProject = async (teamName, projectId, projectName, userProfile)=>{\n    try {\n        if (!projectId || !projectName) return;\n        if (!canUserAccessTeam(userProfile, teamName) || userProfile.role === 'employee') {\n            return; // Silently fail for employees\n        }\n        const projects = await getTeamProjects(teamName, userProfile);\n        const exists = projects.find((p)=>p.id === projectId);\n        if (!exists) {\n            const newProjects = [\n                ...projects,\n                {\n                    id: projectId,\n                    name: projectName\n                }\n            ];\n            await saveTeamDropdownData(teamName, 'projects', newProjects, userProfile);\n        }\n    } catch (error) {\n        console.error('Error adding team project:', error);\n    // Don't throw error to prevent task creation failure\n    }\n};\n// -------------------- EMPLOYEES WITH USER CONTEXT --------------------\n// Get team-specific employees (with user permission check)\nconst getTeamEmployees = async (teamName, userProfile)=>{\n    try {\n        if (!canUserAccessTeam(userProfile, teamName)) {\n            return [];\n        }\n        return await getTeamDropdownData(teamName, 'employees', userProfile);\n    } catch (error) {\n        console.error('Error getting team employees:', error);\n        return [];\n    }\n};\n// Add new employee to team (with user permission check)\nconst addTeamEmployee = async (teamName, empId, empName, userProfile)=>{\n    try {\n        if (!empId || !empName) return;\n        if (!canUserAccessTeam(userProfile, teamName) || userProfile.role === 'employee') {\n            return; // Silently fail for employees\n        }\n        const employees = await getTeamEmployees(teamName, userProfile);\n        const exists = employees.find((e)=>e.id === empId);\n        if (!exists) {\n            const newEmployees = [\n                ...employees,\n                {\n                    id: empId,\n                    name: empName\n                }\n            ];\n            await saveTeamDropdownData(teamName, 'employees', newEmployees, userProfile);\n        }\n    } catch (error) {\n        console.error('Error adding team employee:', error);\n    // Don't throw error to prevent task creation failure\n    }\n};\n// -------------------- CLIENTS WITH USER CONTEXT --------------------\n// Get team-specific clients (with user permission check)\nconst getTeamClients = async (teamName, userProfile)=>{\n    try {\n        if (!canUserAccessTeam(userProfile, teamName)) {\n            return [];\n        }\n        return await getTeamDropdownData(teamName, 'clients', userProfile);\n    } catch (error) {\n        console.error('Error getting team clients:', error);\n        return [];\n    }\n};\n// Add new client to team (with user permission check)\nconst addTeamClient = async (teamName, clientId, clientName, userProfile)=>{\n    try {\n        if (!clientId || !clientName) return;\n        if (!canUserAccessTeam(userProfile, teamName) || userProfile.role === 'employee') {\n            return; // Silently fail for employees\n        }\n        const clients = await getTeamClients(teamName, userProfile);\n        const exists = clients.find((c)=>c.id === clientId);\n        if (!exists) {\n            const newClients = [\n                ...clients,\n                {\n                    id: clientId,\n                    name: clientName\n                }\n            ];\n            await saveTeamDropdownData(teamName, 'clients', newClients, userProfile);\n        }\n    } catch (error) {\n        console.error('Error adding team client:', error);\n    // Don't throw error to prevent task creation failure\n    }\n};\n// -------------------- UTILITY FUNCTIONS --------------------\n// Get predefined values for a specific field\nconst getPredefinedValues = (field)=>{\n    return PREDEFINED_VALUES[field] || [];\n};\n// Check if field has predefined values\nconst isPredefinedField = (field)=>{\n    return !!PREDEFINED_VALUES[field];\n};\n// Check if team document exists\nconst teamExists = async (teamName)=>{\n    try {\n        const teamDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName));\n        return teamDoc.exists();\n    } catch (error) {\n        return false;\n    }\n};\n// Initialize default dropdown values for a team (only if team doesn't exist yet)\nconst initializeTeamDefaults = async (teamName)=>{\n    try {\n        const exists = await teamExists(teamName);\n        if (!exists) {\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebaseConfig__WEBPACK_IMPORTED_MODULE_0__.db, 'teams', teamName), {\n                createdAt: new Date().toISOString()\n            });\n        }\n    } catch (error) {\n        console.error('Error initializing team defaults:', error);\n        throw error;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2xpYi9maXJlYmFzZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxnRkFBZ0Y7QUFDMUM7QUFHVjtBQUU1Qiw4REFBOEQ7QUFDOUQsTUFBTVcsb0JBQW9CO0lBQ3RCQyxzQkFBc0I7UUFBQztRQUFLO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtLQUFNO0lBQ2xGQyxRQUFRO1FBQUM7UUFBYTtRQUFlO0tBQVU7SUFDL0NDLFVBQVU7UUFBQztRQUFZO1FBQVk7S0FBYTtBQUNwRDtBQUVBLDREQUE0RDtBQUU1RCxtQkFBbUI7QUFDWixNQUFNQyxpQkFBaUIsT0FBT0M7SUFDakMsSUFBSTtRQUNBLE1BQU1DLFVBQVUsTUFBTVYsMERBQU1BLENBQUNILHVEQUFHQSxDQUFDSiwrQ0FBRUEsRUFBRSxTQUFTZ0I7UUFDOUMsSUFBSUMsUUFBUUMsTUFBTSxJQUFJO1lBQ2xCLE9BQU9ELFFBQVFFLElBQUk7UUFDdkI7UUFDQSxPQUFPO0lBQ1gsRUFBRSxPQUFPQyxPQUFPO1FBQ1pDLFFBQVFELEtBQUssQ0FBQywrQkFBK0JBO1FBQzdDLE9BQU87SUFDWDtBQUNKLEVBQUU7QUFFRixzQkFBc0I7QUFDZixNQUFNRSxvQkFBb0IsT0FBT04sUUFBUU87SUFDNUMsSUFBSTtRQUNBLE1BQU1mLDBEQUFNQSxDQUFDSix1REFBR0EsQ0FBQ0osK0NBQUVBLEVBQUUsU0FBU2dCLFNBQVNPLGFBQWE7WUFBRUMsT0FBTztRQUFLO0lBQ3RFLEVBQUUsT0FBT0osT0FBTztRQUNaQyxRQUFRRCxLQUFLLENBQUMsZ0NBQWdDQTtRQUM5QyxNQUFNQTtJQUNWO0FBQ0osRUFBRTtBQUVGLG9FQUFvRTtBQUU3RCxNQUFNSyxVQUFVLE9BQU9DLE1BQU1DO0lBQ2hDLElBQUk7UUFDQSxJQUFJQSxZQUFZQyxJQUFJLEtBQUssYUFBYTtZQUNsQ0YsS0FBS0csUUFBUSxHQUFHO1FBQ3BCO1FBRUEsbURBQW1EO1FBQ25ELElBQUksQ0FBQ0Msc0JBQXNCSCxhQUFhRCxLQUFLRyxRQUFRLEVBQUVILEtBQUtLLEtBQUssR0FBRztZQUNoRSxNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFFQSxNQUFNQyx1QkFBdUJQLEtBQUtHLFFBQVE7UUFFMUMsOEJBQThCO1FBQzlCLE1BQU1LLFVBQVU5Qix1REFBR0EsQ0FBQ0osK0NBQUVBLEVBQUUsU0FBUzBCLEtBQUtHLFFBQVEsRUFBRSxTQUFTSCxLQUFLUyxJQUFJO1FBQ2xFLE1BQU0zQiwwREFBTUEsQ0FBQzBCLFNBQVM7WUFBRUUsV0FBVyxJQUFJQyxPQUFPQyxXQUFXO1FBQUcsR0FBRztZQUFFZCxPQUFPO1FBQUs7UUFFN0UsNENBQTRDO1FBQzVDLE1BQU1lLFNBQVNuQyx1REFBR0EsQ0FBQ0osK0NBQUVBLEVBQUUsU0FBUzBCLEtBQUtHLFFBQVEsRUFBRSxTQUFTSCxLQUFLUyxJQUFJLEVBQUUsYUFBYVQsS0FBS0ssS0FBSztRQUMxRixNQUFNdkIsMERBQU1BLENBQUMrQixRQUFRO1lBQUVDLE1BQU1kLEtBQUtlLE9BQU87UUFBQyxHQUFHO1lBQUVqQixPQUFPO1FBQUs7UUFFM0QseURBQXlEO1FBQ3pELElBQUlFLEtBQUtLLEtBQUssSUFBSUwsS0FBS2UsT0FBTyxFQUFFO1lBQzVCLE1BQU1DLGdCQUFnQmhCLEtBQUtHLFFBQVEsRUFBRUgsS0FBS0ssS0FBSyxFQUFFTCxLQUFLZSxPQUFPO1FBQ2pFO1FBRUEscURBQXFEO1FBQ3JELElBQUlmLEtBQUtpQixRQUFRLElBQUlqQixLQUFLa0IsVUFBVSxFQUFFO1lBQ2xDLE1BQU1DLGNBQWNuQixLQUFLRyxRQUFRLEVBQUVILEtBQUtpQixRQUFRLEVBQUVqQixLQUFLa0IsVUFBVTtRQUNyRTtRQUVBLHVEQUF1RDtRQUN2RCxJQUFJbEIsS0FBS29CLFNBQVMsSUFBSXBCLEtBQUtxQixXQUFXLEVBQUU7WUFDcEMsTUFBTUMsZUFBZXRCLEtBQUtHLFFBQVEsRUFBRUgsS0FBS29CLFNBQVMsRUFBRXBCLEtBQUtxQixXQUFXO1FBQ3hFO1FBRUEsTUFBTUUsU0FBUyxNQUFNL0MsMERBQU1BLENBQ3ZCRCw4REFBVUEsQ0FBQ0QsK0NBQUVBLEVBQUUsU0FBUzBCLEtBQUtHLFFBQVEsRUFBRSxTQUFTSCxLQUFLUyxJQUFJLEVBQUUsYUFBYVQsS0FBS0ssS0FBSyxFQUFFLFVBQ3BGO1lBQUUsR0FBR0wsSUFBSTtZQUFFVSxXQUFXLElBQUlDLE9BQU9DLFdBQVc7WUFBSVksV0FBV3ZCLFlBQVlJLEtBQUs7UUFBQztRQUdqRixrREFBa0Q7UUFDbEQsT0FBTztZQUNILEdBQUdMLElBQUk7WUFDUHlCLElBQUlGLE9BQU9FLEVBQUU7WUFDYmYsV0FBVyxJQUFJQyxPQUFPQyxXQUFXO1lBQ2pDWSxXQUFXdkIsWUFBWUksS0FBSztRQUNoQztJQUNKLEVBQUUsT0FBT1gsT0FBTztRQUNaQyxRQUFRRCxLQUFLLENBQUMsc0JBQXNCQTtRQUNwQyxNQUFNQTtJQUNWO0FBQ0osRUFBRTtBQUVGLCtEQUErRDtBQUN4RCxNQUFNZ0MsV0FBVyxlQUFPekI7UUFBYTBCLDhFQUFhO0lBQ3JELElBQUk7UUFDQSxJQUFJLENBQUMxQixhQUFhO1lBQ2QsTUFBTSxJQUFJSyxNQUFNO1FBQ3BCO1FBRUEsSUFBSXNCLFdBQVcsRUFBRTtRQUVqQix3Q0FBd0M7UUFDeEMsSUFBSUM7UUFDSixPQUFRNUIsWUFBWUMsSUFBSTtZQUNwQixLQUFLO2dCQUNEMkIsa0JBQWtCO3VCQUFLNUIsWUFBWTZCLFlBQVksSUFBSSxFQUFFO29CQUFHO2lCQUFZO2dCQUNwRTtZQUNKLEtBQUs7WUFDTCxLQUFLO2dCQUNERCxrQkFBa0I7b0JBQUM1QixZQUFZRSxRQUFRO2lCQUFDO2dCQUN4QztZQUNKO2dCQUNJLE9BQU8sRUFBRTtRQUNqQjtRQUVBLGdDQUFnQztRQUNoQyxJQUFJd0IsY0FBY0EsZUFBZSxPQUFPO1lBQ3BDRSxrQkFBa0JBLGdCQUFnQkUsTUFBTSxDQUFDQyxDQUFBQSxPQUFRQSxTQUFTTDtRQUM5RDtRQUVBLG9DQUFvQztRQUNwQyxLQUFLLE1BQU14QixZQUFZMEIsZ0JBQWlCO1lBQ3BDLE1BQU1JLGdCQUFnQixNQUFNeEQsMkRBQU9BLENBQUNGLDhEQUFVQSxDQUFDRCwrQ0FBRUEsRUFBRSxTQUFTNkIsVUFBVTtZQUV0RSxLQUFLLE1BQU0rQixXQUFXRCxjQUFjRSxJQUFJLENBQUU7Z0JBQ3RDLE1BQU0xQixPQUFPeUIsUUFBUVQsRUFBRTtnQkFDdkIsTUFBTVcsb0JBQW9CLE1BQU0zRCwyREFBT0EsQ0FDbkNGLDhEQUFVQSxDQUFDRCwrQ0FBRUEsRUFBRSxTQUFTNkIsVUFBVSxTQUFTTSxNQUFNO2dCQUdyRCxLQUFLLE1BQU00QixVQUFVRCxrQkFBa0JELElBQUksQ0FBRTtvQkFDekMsTUFBTTlCLFFBQVFnQyxPQUFPWixFQUFFO29CQUV2QixnREFBZ0Q7b0JBQ2hELElBQUksQ0FBQ3JCLHNCQUFzQkgsYUFBYUUsVUFBVUUsUUFBUTt3QkFDdEQ7b0JBQ0o7b0JBRUEsTUFBTWlDLGdCQUFnQixNQUFNN0QsMkRBQU9BLENBQy9CRiw4REFBVUEsQ0FBQ0QsK0NBQUVBLEVBQUUsU0FBUzZCLFVBQVUsU0FBU00sTUFBTSxhQUFhSixPQUFPO29CQUd6RSxNQUFNa0MsV0FBV0QsY0FBY0gsSUFBSSxDQUFDSyxHQUFHLENBQUNDLENBQUFBLFVBQVk7NEJBQ2hEdEM7NEJBQ0FNOzRCQUNBSjs0QkFDQSxHQUFHb0MsUUFBUWhELElBQUksRUFBRTs0QkFDakJnQyxJQUFJZ0IsUUFBUWhCLEVBQUU7d0JBQ2xCO29CQUVBRyxXQUFXOzJCQUFJQTsyQkFBYVc7cUJBQVM7Z0JBQ3pDO1lBQ0o7UUFDSjtRQUVBLE9BQU9YO0lBQ1gsRUFBRSxPQUFPbEMsT0FBTztRQUNaQyxRQUFRRCxLQUFLLENBQUMsd0JBQXdCQTtRQUN0QyxNQUFNQTtJQUNWO0FBQ0osRUFBRTtBQUVGLDZDQUE2QztBQUN0QyxNQUFNZ0QsYUFBYSxPQUFPdkMsVUFBVU0sTUFBTUosT0FBT3NDLFFBQVFDLFVBQVUzQztJQUN0RSxJQUFJO1FBQ0EscUNBQXFDO1FBQ3JDLElBQUksQ0FBQ0csc0JBQXNCSCxhQUFhRSxVQUFVRSxRQUFRO1lBQ3RELE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUVBLE1BQU11QyxVQUFVbkUsdURBQUdBLENBQUNKLCtDQUFFQSxFQUFFLFNBQVM2QixVQUFVLFNBQVNNLE1BQU0sYUFBYUosT0FBTyxTQUFTc0M7UUFDdkYsTUFBTWhFLDZEQUFTQSxDQUFDa0UsU0FBUztZQUNyQixHQUFHRCxRQUFRO1lBQ1hFLFdBQVcsSUFBSW5DLE9BQU9DLFdBQVc7WUFDakNtQyxXQUFXOUMsWUFBWUksS0FBSztRQUNoQztJQUNKLEVBQUUsT0FBT1gsT0FBTztRQUNaQyxRQUFRRCxLQUFLLENBQUMsd0JBQXdCQTtRQUN0QyxNQUFNQTtJQUNWO0FBQ0osRUFBRTtBQUVGLDZDQUE2QztBQUN0QyxNQUFNc0QsYUFBYSxPQUFPN0MsVUFBVU0sTUFBTUosT0FBT3NDLFFBQVExQztJQUM1RCxJQUFJO1FBQ0EscUNBQXFDO1FBQ3JDLElBQUksQ0FBQ0csc0JBQXNCSCxhQUFhRSxVQUFVRSxRQUFRO1lBQ3RELE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUVBLE1BQU11QyxVQUFVbkUsdURBQUdBLENBQUNKLCtDQUFFQSxFQUFFLFNBQVM2QixVQUFVLFNBQVNNLE1BQU0sYUFBYUosT0FBTyxTQUFTc0M7UUFDdkYsTUFBTS9ELDZEQUFTQSxDQUFDaUU7SUFDcEIsRUFBRSxPQUFPbkQsT0FBTztRQUNaQyxRQUFRRCxLQUFLLENBQUMsd0JBQXdCQTtRQUN0QyxNQUFNQTtJQUNWO0FBQ0osRUFBRTtBQUVGLHNGQUFzRjtBQUV0Rix5Q0FBeUM7QUFDbEMsTUFBTXVELG9CQUFvQixDQUFDaEQsYUFBYUU7SUFDM0MsSUFBSSxDQUFDRixhQUFhO1FBQ2QsT0FBTztJQUNYO0lBRUEsT0FBUUEsWUFBWUMsSUFBSTtRQUNwQixLQUFLO2dCQUU0QkQ7WUFEN0IsaUVBQWlFO1lBQ2pFLE1BQU1pRCx3QkFBdUJqRCw0QkFBQUEsWUFBWTZCLFlBQVksY0FBeEI3QixnREFBQUEsMEJBQTBCa0QsUUFBUSxDQUFDaEQ7WUFDaEUsTUFBTWlELHlCQUF5QmpELGFBQWE7WUFDNUMsT0FBTytDLHdCQUF3QkU7UUFFbkMsS0FBSztRQUNMLEtBQUs7WUFDRCxPQUFPbkQsWUFBWUUsUUFBUSxLQUFLQTtRQUVwQztZQUNJLE9BQU87SUFDZjtBQUNKLEVBQUU7QUFFRixvREFBb0Q7QUFDN0MsTUFBTUMsd0JBQXdCLENBQUNILGFBQWFFLFVBQVVFO0lBQ3pELElBQUksQ0FBQ0osYUFBYSxPQUFPO0lBRXpCLE9BQVFBLFlBQVlDLElBQUk7UUFDcEIsS0FBSztZQUNELE9BQU9ELFlBQVk2QixZQUFZLENBQUNxQixRQUFRLENBQUNoRDtRQUM3QyxLQUFLO1lBQ0QsT0FBT0YsWUFBWUUsUUFBUSxLQUFLQTtRQUNwQyxLQUFLO1lBQ0QsT0FBT0YsWUFBWUUsUUFBUSxLQUFLQSxZQUFZRixZQUFZSSxLQUFLLEtBQUtBO1FBQ3RFO1lBQ0ksT0FBTztJQUNmO0FBQ0osRUFBRTtBQUVGLHdDQUF3QztBQUNqQyxNQUFNZ0QscUJBQXFCLENBQUNwRDtJQUMvQixJQUFJLENBQUNBLGFBQWEsT0FBTyxFQUFFO0lBRTNCLE9BQVFBLFlBQVlDLElBQUk7UUFDcEIsS0FBSztZQUNELE9BQU9ELFlBQVk2QixZQUFZLElBQUksRUFBRTtRQUN6QyxLQUFLO1FBQ0wsS0FBSztZQUNELE9BQU87Z0JBQUM3QixZQUFZRSxRQUFRO2FBQUM7UUFDakM7WUFDSSxPQUFPLEVBQUU7SUFDakI7QUFDSixFQUFFO0FBRUYsa0VBQWtFO0FBRTNELE1BQU1tRCxtQkFBbUIsT0FBT3JEO0lBQ25DLElBQUk7UUFDQSxNQUFNc0QsVUFBVTtZQUNaQyxhQUFhLEVBQUU7WUFDZkMsV0FBVyxFQUFFO1lBQ2JDLE9BQU8sRUFBRTtRQUNiO1FBRUEsSUFBSSxDQUFDekQsYUFBYSxPQUFPc0Q7UUFFekIsSUFBSXRELFlBQVlDLElBQUksS0FBSyxhQUFhO1lBQ2xDcUQsUUFBUUcsS0FBSyxHQUFHekQsWUFBWTZCLFlBQVksSUFBSSxFQUFFO1lBRTlDLG9EQUFvRDtZQUNwRCxNQUFNNkIsaUJBQWlCLElBQUlDO1lBQzNCLE1BQU1DLGVBQWUsSUFBSUQ7WUFFekIsS0FBSyxNQUFNekQsWUFBWUYsWUFBWTZCLFlBQVksQ0FBRTtnQkFDN0MsbUJBQW1CO2dCQUNuQixNQUFNZ0MsbUJBQW1CL0UseURBQUtBLENBQzFCUiw4REFBVUEsQ0FBQ0QsK0NBQUVBLEVBQUUsVUFDZlUseURBQUtBLENBQUMsUUFBUSxNQUFNLGdCQUNwQkEseURBQUtBLENBQUMsWUFBWSxNQUFNbUI7Z0JBRTVCLE1BQU00RCxzQkFBc0IsTUFBTXRGLDJEQUFPQSxDQUFDcUY7Z0JBQzFDQyxvQkFBb0JDLE9BQU8sQ0FBQ3RGLENBQUFBO29CQUN4QixNQUFNZSxPQUFPZixJQUFJZSxJQUFJO29CQUNyQmtFLGVBQWVNLEdBQUcsQ0FBQ0MsS0FBS0MsU0FBUyxDQUFDO3dCQUM5QjlELE9BQU9aLEtBQUtZLEtBQUs7d0JBQ2pCVSxTQUFTdEIsS0FBS3NCLE9BQU87d0JBQ3JCWixVQUFVVixLQUFLVSxRQUFRO29CQUMzQjtnQkFDSjtnQkFFQSxnQkFBZ0I7Z0JBQ2hCLE1BQU1pRSxpQkFBaUJyRix5REFBS0EsQ0FDeEJSLDhEQUFVQSxDQUFDRCwrQ0FBRUEsRUFBRSxVQUNmVSx5REFBS0EsQ0FBQyxRQUFRLE1BQU0sYUFDcEJBLHlEQUFLQSxDQUFDLFlBQVksTUFBTW1CO2dCQUU1QixNQUFNaUMsb0JBQW9CLE1BQU0zRCwyREFBT0EsQ0FBQzJGO2dCQUN4Q2hDLGtCQUFrQjRCLE9BQU8sQ0FBQ3RGLENBQUFBO29CQUN0QixNQUFNZSxPQUFPZixJQUFJZSxJQUFJO29CQUNyQm9FLGFBQWFJLEdBQUcsQ0FBQ0MsS0FBS0MsU0FBUyxDQUFDO3dCQUM1QjlELE9BQU9aLEtBQUtZLEtBQUs7d0JBQ2pCVSxTQUFTdEIsS0FBS3NCLE9BQU87d0JBQ3JCWixVQUFVVixLQUFLVSxRQUFRO29CQUMzQjtnQkFDSjtZQUNKO1lBRUFvRCxRQUFRQyxXQUFXLEdBQUdhLE1BQU1DLElBQUksQ0FBQ1gsZ0JBQWdCbkIsR0FBRyxDQUFDK0IsQ0FBQUEsTUFBT0wsS0FBS00sS0FBSyxDQUFDRDtZQUN2RWhCLFFBQVFFLFNBQVMsR0FBR1ksTUFBTUMsSUFBSSxDQUFDVCxjQUFjckIsR0FBRyxDQUFDK0IsQ0FBQUEsTUFBT0wsS0FBS00sS0FBSyxDQUFDRDtRQUN2RSxPQUFPLElBQUl0RSxZQUFZQyxJQUFJLEtBQUssZUFBZTtZQUMzQ3FELFFBQVFDLFdBQVcsR0FBRztnQkFBQztvQkFDbkJuRCxPQUFPSixZQUFZSSxLQUFLO29CQUN4QlUsU0FBU2QsWUFBWWMsT0FBTztvQkFDNUJaLFVBQVVGLFlBQVlFLFFBQVE7Z0JBQ2xDO2FBQUU7WUFFRiw4QkFBOEI7WUFDOUIsTUFBTWlFLGlCQUFpQnJGLHlEQUFLQSxDQUN4QlIsOERBQVVBLENBQUNELCtDQUFFQSxFQUFFLFVBQ2ZVLHlEQUFLQSxDQUFDLFFBQVEsTUFBTSxhQUNwQkEseURBQUtBLENBQUMsWUFBWSxNQUFNaUIsWUFBWUUsUUFBUTtZQUVoRCxNQUFNaUMsb0JBQW9CLE1BQU0zRCwyREFBT0EsQ0FBQzJGO1lBQ3hDYixRQUFRRSxTQUFTLEdBQUdyQixrQkFBa0JELElBQUksQ0FBQ0ssR0FBRyxDQUFDOUQsQ0FBQUEsTUFBUTtvQkFDbkQyQixPQUFPM0IsSUFBSWUsSUFBSSxHQUFHWSxLQUFLO29CQUN2QlUsU0FBU3JDLElBQUllLElBQUksR0FBR3NCLE9BQU87b0JBQzNCWixVQUFVekIsSUFBSWUsSUFBSSxHQUFHVSxRQUFRO2dCQUNqQztRQUNKLE9BQU8sSUFBSUYsWUFBWUMsSUFBSSxLQUFLLFlBQVk7WUFDeENxRCxRQUFRRSxTQUFTLEdBQUc7Z0JBQUM7b0JBQ2pCcEQsT0FBT0osWUFBWUksS0FBSztvQkFDeEJVLFNBQVNkLFlBQVljLE9BQU87b0JBQzVCWixVQUFVRixZQUFZRSxRQUFRO2dCQUNsQzthQUFFO1FBQ047UUFFQSxPQUFPb0Q7SUFDWCxFQUFFLE9BQU83RCxPQUFPO1FBQ1pDLFFBQVFELEtBQUssQ0FBQyxpQ0FBaUNBO1FBQy9DLE9BQU87WUFDSDhELGFBQWEsRUFBRTtZQUNmQyxXQUFXLEVBQUU7WUFDYkMsT0FBTyxFQUFFO1FBQ2I7SUFDSjtBQUNKLEVBQUU7QUFFRiw2REFBNkQ7QUFDdEQsTUFBTWUsbUJBQW1CLENBQUNDLE9BQU9DLFNBQVMxRTtJQUM3QyxJQUFJLENBQUN5RSxTQUFTQSxNQUFNRSxNQUFNLEtBQUssR0FBRyxPQUFPRjtJQUV6QyxJQUFJRyxnQkFBZ0I7V0FBSUg7S0FBTTtJQUU5QixvQ0FBb0M7SUFDcEMsSUFBSUMsUUFBUUcsUUFBUSxFQUFFO1FBQ2xCRCxnQkFBZ0JBLGNBQWM5QyxNQUFNLENBQUMvQixDQUFBQTtZQUNqQyxJQUFJLENBQUNBLEtBQUtVLFNBQVMsRUFBRSxPQUFPO1lBQzVCLE1BQU1xRSxlQUFlL0UsS0FBS1UsU0FBUyxDQUFDc0UsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2pELE9BQU9ELGdCQUFnQkosUUFBUUcsUUFBUTtRQUMzQztJQUNKO0lBQ0EsSUFBSUgsUUFBUU0sTUFBTSxFQUFFO1FBQ2hCSixnQkFBZ0JBLGNBQWM5QyxNQUFNLENBQUMvQixDQUFBQTtZQUNqQyxJQUFJLENBQUNBLEtBQUtVLFNBQVMsRUFBRSxPQUFPO1lBQzVCLE1BQU1xRSxlQUFlL0UsS0FBS1UsU0FBUyxDQUFDc0UsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2pELE9BQU9ELGdCQUFnQkosUUFBUU0sTUFBTTtRQUN6QztJQUNKO0lBRUEsZ0NBQWdDO0lBQ2hDLElBQUlOLFFBQVEzQyxJQUFJLElBQUkvQixZQUFZQyxJQUFJLEtBQUssYUFBYTtRQUNsRDJFLGdCQUFnQkEsY0FBYzlDLE1BQU0sQ0FBQy9CLENBQUFBLE9BQVFBLEtBQUtHLFFBQVEsS0FBS3dFLFFBQVEzQyxJQUFJO0lBQy9FO0lBRUEsdUNBQXVDO0lBQ3ZDLElBQUkyQyxRQUFRTyxVQUFVLElBQUlqRixZQUFZQyxJQUFJLEtBQUssYUFBYTtRQUN4RDJFLGdCQUFnQkEsY0FBYzlDLE1BQU0sQ0FBQy9CLENBQUFBLE9BQVFBLEtBQUtLLEtBQUssS0FBS3NFLFFBQVFPLFVBQVU7SUFDbEY7SUFFQSxnREFBZ0Q7SUFDaEQsSUFBSVAsUUFBUVEsUUFBUSxJQUFLbEYsQ0FBQUEsWUFBWUMsSUFBSSxLQUFLLGVBQWVELFlBQVlDLElBQUksS0FBSyxhQUFZLEdBQUk7UUFDOUYyRSxnQkFBZ0JBLGNBQWM5QyxNQUFNLENBQUMvQixDQUFBQSxPQUFRQSxLQUFLSyxLQUFLLEtBQUtzRSxRQUFRUSxRQUFRO0lBQ2hGO0lBRUEsT0FBT047QUFDWCxFQUFFO0FBRUYsOENBQThDO0FBQ3ZDLE1BQU1PLG1CQUFtQixlQUFPbkY7UUFBYTBFLDJFQUFVLENBQUM7SUFDM0QsSUFBSTtRQUNBLGlDQUFpQztRQUNqQyxNQUFNL0MsV0FBVyxNQUFNRixTQUFTekI7UUFFaEMscUJBQXFCO1FBQ3JCLE1BQU00RSxnQkFBZ0JKLGlCQUFpQjdDLFVBQVUrQyxTQUFTMUU7UUFFMUQsT0FBTzRFO0lBQ1gsRUFBRSxPQUFPbkYsT0FBTztRQUNaQyxRQUFRRCxLQUFLLENBQUMsaUNBQWlDQTtRQUMvQyxNQUFNQTtJQUNWO0FBQ0osRUFBRTtBQUVGLHdFQUF3RTtBQUV4RSw0REFBNEQ7QUFDckQsTUFBTTJGLHNCQUFzQixPQUFPbEYsVUFBVW1GLE9BQU9yRjtJQUN2RCxJQUFJO1FBQ0EscUNBQXFDO1FBQ3JDLElBQUksQ0FBQ2dELGtCQUFrQmhELGFBQWFFLFdBQVc7WUFDM0MsTUFBTSxJQUFJRyxNQUFNO1FBQ3BCO1FBRUEsb0VBQW9FO1FBQ3BFLElBQUlyQixpQkFBaUIsQ0FBQ3FHLE1BQU0sRUFBRTtZQUMxQixPQUFPckcsaUJBQWlCLENBQUNxRyxNQUFNO1FBQ25DO1FBRUEsaURBQWlEO1FBQ2pELE1BQU0vRCxTQUFTN0MsdURBQUdBLENBQUNKLCtDQUFFQSxFQUFFLFNBQVM2QixVQUFVLGdCQUFnQm1GO1FBQzFELE1BQU1DLFVBQVUsTUFBTTFHLDBEQUFNQSxDQUFDMEM7UUFDN0IsSUFBSWdFLFFBQVEvRixNQUFNLElBQUk7WUFDbEIsT0FBTytGLFFBQVE5RixJQUFJLEdBQUcrRixNQUFNLElBQUksRUFBRTtRQUN0QztRQUNBLE9BQU8sRUFBRTtJQUNiLEVBQUUsT0FBTzlGLE9BQU87UUFDWkMsUUFBUUQsS0FBSyxDQUFDLHFDQUFxQ0E7UUFDbkQsOENBQThDO1FBQzlDLE9BQU9ULGlCQUFpQixDQUFDcUcsTUFBTSxJQUFJLEVBQUU7SUFDekM7QUFDSixFQUFFO0FBRUYsNkRBQTZEO0FBQ3RELE1BQU1HLHVCQUF1QixPQUFPdEYsVUFBVW1GLE9BQU9FLFFBQVF2RjtJQUNoRSxJQUFJO1FBQ0EsNkVBQTZFO1FBQzdFLElBQUksQ0FBQ2dELGtCQUFrQmhELGFBQWFFLGFBQWFGLFlBQVlDLElBQUksS0FBSyxZQUFZO1lBQzlFLE1BQU0sSUFBSUksTUFBTTtRQUNwQjtRQUVBLDJDQUEyQztRQUMzQyxJQUFJckIsaUJBQWlCLENBQUNxRyxNQUFNLEVBQUU7WUFDMUIzRixRQUFRK0YsSUFBSSxDQUFDLDRDQUFrRCxPQUFOSjtZQUN6RDtRQUNKO1FBRUEsTUFBTS9ELFNBQVM3Qyx1REFBR0EsQ0FBQ0osK0NBQUVBLEVBQUUsU0FBUzZCLFVBQVUsZ0JBQWdCbUY7UUFDMUQsTUFBTXhHLDBEQUFNQSxDQUFDeUMsUUFBUTtZQUFFaUU7UUFBTyxHQUFHO1lBQUUxRixPQUFPO1FBQUs7SUFDbkQsRUFBRSxPQUFPSixPQUFPO1FBQ1pDLFFBQVFELEtBQUssQ0FBQyxvQ0FBb0NBO1FBQ2xELE1BQU1BO0lBQ1Y7QUFDSixFQUFFO0FBRUYsb0VBQW9FO0FBRXBFLCtCQUErQjtBQUN4QixNQUFNaUcsV0FBVyxPQUFPMUY7SUFDM0IsSUFBSTtRQUNBLElBQUksQ0FBQ0EsYUFBYSxPQUFPLEVBQUU7UUFDM0IsT0FBT29ELG1CQUFtQnBEO0lBQzlCLEVBQUUsT0FBT1AsT0FBTztRQUNaQyxRQUFRRCxLQUFLLENBQUMsd0JBQXdCQTtRQUN0QyxPQUFPLEVBQUU7SUFDYjtBQUNKLEVBQUU7QUFFRix1RUFBdUU7QUFFdkUsMERBQTBEO0FBQ25ELE1BQU1rRyxrQkFBa0IsT0FBT3pGLFVBQVVGO0lBQzVDLElBQUk7UUFDQSxJQUFJLENBQUNnRCxrQkFBa0JoRCxhQUFhRSxXQUFXO1lBQzNDLE9BQU8sRUFBRTtRQUNiO1FBQ0EsT0FBTyxNQUFNa0Ysb0JBQW9CbEYsVUFBVSxZQUFZRjtJQUMzRCxFQUFFLE9BQU9QLE9BQU87UUFDWkMsUUFBUUQsS0FBSyxDQUFDLGdDQUFnQ0E7UUFDOUMsT0FBTyxFQUFFO0lBQ2I7QUFDSixFQUFFO0FBRUYsdURBQXVEO0FBQ2hELE1BQU00QixpQkFBaUIsT0FBT25CLFVBQVVpQixXQUFXQyxhQUFhcEI7SUFDbkUsSUFBSTtRQUNBLElBQUksQ0FBQ21CLGFBQWEsQ0FBQ0MsYUFBYTtRQUVoQyxJQUFJLENBQUM0QixrQkFBa0JoRCxhQUFhRSxhQUFhRixZQUFZQyxJQUFJLEtBQUssWUFBWTtZQUM5RSxRQUFRLDhCQUE4QjtRQUMxQztRQUVBLE1BQU0yRixXQUFXLE1BQU1ELGdCQUFnQnpGLFVBQVVGO1FBQ2pELE1BQU1ULFNBQVNxRyxTQUFTQyxJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUV0RSxFQUFFLEtBQUtMO1FBQzNDLElBQUksQ0FBQzVCLFFBQVE7WUFDVCxNQUFNd0csY0FBYzttQkFBSUg7Z0JBQVU7b0JBQUVwRSxJQUFJTDtvQkFBV04sTUFBTU87Z0JBQVk7YUFBRTtZQUN2RSxNQUFNb0UscUJBQXFCdEYsVUFBVSxZQUFZNkYsYUFBYS9GO1FBQ2xFO0lBQ0osRUFBRSxPQUFPUCxPQUFPO1FBQ1pDLFFBQVFELEtBQUssQ0FBQyw4QkFBOEJBO0lBQzVDLHFEQUFxRDtJQUN6RDtBQUNKLEVBQUU7QUFFRix3RUFBd0U7QUFFeEUsMkRBQTJEO0FBQ3BELE1BQU11RyxtQkFBbUIsT0FBTzlGLFVBQVVGO0lBQzdDLElBQUk7UUFDQSxJQUFJLENBQUNnRCxrQkFBa0JoRCxhQUFhRSxXQUFXO1lBQzNDLE9BQU8sRUFBRTtRQUNiO1FBQ0EsT0FBTyxNQUFNa0Ysb0JBQW9CbEYsVUFBVSxhQUFhRjtJQUM1RCxFQUFFLE9BQU9QLE9BQU87UUFDWkMsUUFBUUQsS0FBSyxDQUFDLGlDQUFpQ0E7UUFDL0MsT0FBTyxFQUFFO0lBQ2I7QUFDSixFQUFFO0FBRUYsd0RBQXdEO0FBQ2pELE1BQU1zQixrQkFBa0IsT0FBT2IsVUFBVUUsT0FBT1UsU0FBU2Q7SUFDNUQsSUFBSTtRQUNBLElBQUksQ0FBQ0ksU0FBUyxDQUFDVSxTQUFTO1FBRXhCLElBQUksQ0FBQ2tDLGtCQUFrQmhELGFBQWFFLGFBQWFGLFlBQVlDLElBQUksS0FBSyxZQUFZO1lBQzlFLFFBQVEsOEJBQThCO1FBQzFDO1FBRUEsTUFBTXVELFlBQVksTUFBTXdDLGlCQUFpQjlGLFVBQVVGO1FBQ25ELE1BQU1ULFNBQVNpRSxVQUFVcUMsSUFBSSxDQUFDSSxDQUFBQSxJQUFLQSxFQUFFekUsRUFBRSxLQUFLcEI7UUFDNUMsSUFBSSxDQUFDYixRQUFRO1lBQ1QsTUFBTTJHLGVBQWU7bUJBQUkxQztnQkFBVztvQkFBRWhDLElBQUlwQjtvQkFBT1MsTUFBTUM7Z0JBQVE7YUFBRTtZQUNqRSxNQUFNMEUscUJBQXFCdEYsVUFBVSxhQUFhZ0csY0FBY2xHO1FBQ3BFO0lBQ0osRUFBRSxPQUFPUCxPQUFPO1FBQ1pDLFFBQVFELEtBQUssQ0FBQywrQkFBK0JBO0lBQzdDLHFEQUFxRDtJQUN6RDtBQUNKLEVBQUU7QUFFRixzRUFBc0U7QUFFdEUseURBQXlEO0FBQ2xELE1BQU0wRyxpQkFBaUIsT0FBT2pHLFVBQVVGO0lBQzNDLElBQUk7UUFDQSxJQUFJLENBQUNnRCxrQkFBa0JoRCxhQUFhRSxXQUFXO1lBQzNDLE9BQU8sRUFBRTtRQUNiO1FBQ0EsT0FBTyxNQUFNa0Ysb0JBQW9CbEYsVUFBVSxXQUFXRjtJQUMxRCxFQUFFLE9BQU9QLE9BQU87UUFDWkMsUUFBUUQsS0FBSyxDQUFDLCtCQUErQkE7UUFDN0MsT0FBTyxFQUFFO0lBQ2I7QUFDSixFQUFFO0FBRUYsc0RBQXNEO0FBQy9DLE1BQU15QixnQkFBZ0IsT0FBT2hCLFVBQVVjLFVBQVVDLFlBQVlqQjtJQUNoRSxJQUFJO1FBQ0EsSUFBSSxDQUFDZ0IsWUFBWSxDQUFDQyxZQUFZO1FBRTlCLElBQUksQ0FBQytCLGtCQUFrQmhELGFBQWFFLGFBQWFGLFlBQVlDLElBQUksS0FBSyxZQUFZO1lBQzlFLFFBQVEsOEJBQThCO1FBQzFDO1FBRUEsTUFBTW1HLFVBQVUsTUFBTUQsZUFBZWpHLFVBQVVGO1FBQy9DLE1BQU1ULFNBQVM2RyxRQUFRUCxJQUFJLENBQUNRLENBQUFBLElBQUtBLEVBQUU3RSxFQUFFLEtBQUtSO1FBQzFDLElBQUksQ0FBQ3pCLFFBQVE7WUFDVCxNQUFNK0csYUFBYTttQkFBSUY7Z0JBQVM7b0JBQUU1RSxJQUFJUjtvQkFBVUgsTUFBTUk7Z0JBQVc7YUFBRTtZQUNuRSxNQUFNdUUscUJBQXFCdEYsVUFBVSxXQUFXb0csWUFBWXRHO1FBQ2hFO0lBQ0osRUFBRSxPQUFPUCxPQUFPO1FBQ1pDLFFBQVFELEtBQUssQ0FBQyw2QkFBNkJBO0lBQzNDLHFEQUFxRDtJQUN6RDtBQUNKLEVBQUU7QUFFRiw4REFBOEQ7QUFFOUQsNkNBQTZDO0FBQ3RDLE1BQU04RyxzQkFBc0IsQ0FBQ2xCO0lBQ2hDLE9BQU9yRyxpQkFBaUIsQ0FBQ3FHLE1BQU0sSUFBSSxFQUFFO0FBQ3pDLEVBQUU7QUFFRix1Q0FBdUM7QUFDaEMsTUFBTW1CLG9CQUFvQixDQUFDbkI7SUFDOUIsT0FBTyxDQUFDLENBQUNyRyxpQkFBaUIsQ0FBQ3FHLE1BQU07QUFDckMsRUFBRTtBQUVGLGdDQUFnQztBQUN6QixNQUFNb0IsYUFBYSxPQUFPdkc7SUFDN0IsSUFBSTtRQUNBLE1BQU13RyxVQUFVLE1BQU05SCwwREFBTUEsQ0FBQ0gsdURBQUdBLENBQUNKLCtDQUFFQSxFQUFFLFNBQVM2QjtRQUM5QyxPQUFPd0csUUFBUW5ILE1BQU07SUFDekIsRUFBRSxPQUFPRSxPQUFPO1FBQ1osT0FBTztJQUNYO0FBQ0osRUFBRTtBQUVGLGlGQUFpRjtBQUMxRSxNQUFNYSx5QkFBeUIsT0FBT0o7SUFDekMsSUFBSTtRQUNBLE1BQU1YLFNBQVMsTUFBTWtILFdBQVd2RztRQUNoQyxJQUFJLENBQUNYLFFBQVE7WUFDVCxNQUFNViwwREFBTUEsQ0FBQ0osdURBQUdBLENBQUNKLCtDQUFFQSxFQUFFLFNBQVM2QixXQUFXO2dCQUFFTyxXQUFXLElBQUlDLE9BQU9DLFdBQVc7WUFBRztRQUNuRjtJQUNKLEVBQUUsT0FBT2xCLE9BQU87UUFDWkMsUUFBUUQsS0FBSyxDQUFDLHFDQUFxQ0E7UUFDbkQsTUFBTUE7SUFDVjtBQUNKLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxzYXVyYWJoXFxQcm9qZWN0c1xcQWR2YW5jZWRfR2VuQUlcXFRhc2tIaXZlXFxsaWJcXGZpcmViYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxpYi9maXJlYmFzZS5qcyAtIENsZWFuZWQgdXAgd2l0aCBvcHRpbWl6ZWQgZmlsdGVyaW5nIGFuZCBubyB1bm5lY2Vzc2FyeSBsb2dzXHJcbmltcG9ydCB7IGRiIH0gZnJvbSAnLi9maXJlYmFzZUNvbmZpZyc7XHJcbmltcG9ydCB7XHJcbiAgICBjb2xsZWN0aW9uLCBhZGREb2MsIGdldERvY3MsIGRvYywgdXBkYXRlRG9jLCBkZWxldGVEb2MsIGdldERvYywgc2V0RG9jLCBxdWVyeSwgd2hlcmVcclxufSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0gUFJFREVGSU5FRCBWQUxVRVMgLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuY29uc3QgUFJFREVGSU5FRF9WQUxVRVMgPSB7XHJcbiAgICBwZXJjZW50YWdlQ29tcGxldGlvbjogWyc1JywgJzEwJywgJzI1JywgJzQwJywgJzUwJywgJzY1JywgJzc1JywgJzg1JywgJzkwJywgJzEwMCddLFxyXG4gICAgc3RhdHVzOiBbJ0NvbXBsZXRlZCcsICdJbiBQcm9ncmVzcycsICdPbiBIb2xkJ10sXHJcbiAgICB3b3JrVHlwZTogWydGdWxsLWRheScsICdIYWxmLWRheScsICdSZWxheGF0aW9uJ11cclxufTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIFVTRVIgTUFOQUdFTUVOVCAtLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLy8gR2V0IHVzZXIgcHJvZmlsZVxyXG5leHBvcnQgY29uc3QgZ2V0VXNlclByb2ZpbGUgPSBhc3luYyAodXNlcklkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHVzZXJEb2MgPSBhd2FpdCBnZXREb2MoZG9jKGRiLCAndXNlcnMnLCB1c2VySWQpKTtcclxuICAgICAgICBpZiAodXNlckRvYy5leGlzdHMoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlckRvYy5kYXRhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHVzZXIgcHJvZmlsZTonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBVcGRhdGUgdXNlciBwcm9maWxlXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVVc2VyUHJvZmlsZSA9IGFzeW5jICh1c2VySWQsIHByb2ZpbGVEYXRhKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IHNldERvYyhkb2MoZGIsICd1c2VycycsIHVzZXJJZCksIHByb2ZpbGVEYXRhLCB7IG1lcmdlOiB0cnVlIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyB1c2VyIHByb2ZpbGU6JywgZXJyb3IpO1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0gVEFTS1MgV0lUSCBVU0VSIENPTlRFWFQgLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbmV4cG9ydCBjb25zdCBhZGRUYXNrID0gYXN5bmMgKHRhc2ssIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICh1c2VyUHJvZmlsZS5yb2xlID09PSAndGVjaC1sZWFkJykge1xyXG4gICAgICAgICAgICB0YXNrLnRlYW1OYW1lID0gJ3RlY2hMZWFkcyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBWYWxpZGF0ZSB1c2VyIGNhbiBhZGQgdGFzayB0byB0aGlzIHRlYW0vZW1wbG95ZWVcclxuICAgICAgICBpZiAoIWNhblVzZXJBY2Nlc3NFbXBsb3llZSh1c2VyUHJvZmlsZSwgdGFzay50ZWFtTmFtZSwgdGFzay5lbXBJZCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBhZGQgdGFza3MgZm9yIHRoaXMgZW1wbG95ZWUnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGF3YWl0IGluaXRpYWxpemVUZWFtRGVmYXVsdHModGFzay50ZWFtTmFtZSk7XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSBkYXRlIGRvY3VtZW50IGV4aXN0c1xyXG4gICAgICAgIGNvbnN0IGRhdGVSZWYgPSBkb2MoZGIsICd0ZWFtcycsIHRhc2sudGVhbU5hbWUsICdkYXRlcycsIHRhc2suZGF0ZSk7XHJcbiAgICAgICAgYXdhaXQgc2V0RG9jKGRhdGVSZWYsIHsgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSwgeyBtZXJnZTogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgLy8gRW5zdXJlIGVtcGxveWVlIGRvY3VtZW50IGV4aXN0cyB3aXRoIG5hbWVcclxuICAgICAgICBjb25zdCBlbXBSZWYgPSBkb2MoZGIsICd0ZWFtcycsIHRhc2sudGVhbU5hbWUsICdkYXRlcycsIHRhc2suZGF0ZSwgJ2VtcGxveWVlcycsIHRhc2suZW1wSWQpO1xyXG4gICAgICAgIGF3YWl0IHNldERvYyhlbXBSZWYsIHsgbmFtZTogdGFzay5lbXBOYW1lIH0sIHsgbWVyZ2U6IHRydWUgfSk7XHJcblxyXG4gICAgICAgIC8vIEF1dG8tc2F2ZSBuZXcgZW1wbG95ZWUgdG8gdGVhbSBlbXBsb3llZXMgaWYgbm90IGV4aXN0c1xyXG4gICAgICAgIGlmICh0YXNrLmVtcElkICYmIHRhc2suZW1wTmFtZSkge1xyXG4gICAgICAgICAgICBhd2FpdCBhZGRUZWFtRW1wbG95ZWUodGFzay50ZWFtTmFtZSwgdGFzay5lbXBJZCwgdGFzay5lbXBOYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEF1dG8tc2F2ZSBuZXcgY2xpZW50IHRvIHRlYW0gY2xpZW50cyBpZiBub3QgZXhpc3RzXHJcbiAgICAgICAgaWYgKHRhc2suY2xpZW50SWQgJiYgdGFzay5jbGllbnROYW1lKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGFkZFRlYW1DbGllbnQodGFzay50ZWFtTmFtZSwgdGFzay5jbGllbnRJZCwgdGFzay5jbGllbnROYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEF1dG8tc2F2ZSBuZXcgcHJvamVjdCB0byB0ZWFtIHByb2plY3RzIGlmIG5vdCBleGlzdHNcclxuICAgICAgICBpZiAodGFzay5wcm9qZWN0SWQgJiYgdGFzay5wcm9qZWN0TmFtZSkge1xyXG4gICAgICAgICAgICBhd2FpdCBhZGRUZWFtUHJvamVjdCh0YXNrLnRlYW1OYW1lLCB0YXNrLnByb2plY3RJZCwgdGFzay5wcm9qZWN0TmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBkb2NSZWYgPSBhd2FpdCBhZGREb2MoXHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb24oZGIsICd0ZWFtcycsIHRhc2sudGVhbU5hbWUsICdkYXRlcycsIHRhc2suZGF0ZSwgJ2VtcGxveWVlcycsIHRhc2suZW1wSWQsICd0YXNrcycpLFxyXG4gICAgICAgICAgICB7IC4uLnRhc2ssIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLCBjcmVhdGVkQnk6IHVzZXJQcm9maWxlLmVtcElkIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gZnVsbCB0YXNrIG9iamVjdCB3aXRoIElEIGZvciBjb25zaXN0ZW5jeVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC4uLnRhc2ssXHJcbiAgICAgICAgICAgIGlkOiBkb2NSZWYuaWQsXHJcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgICBjcmVhdGVkQnk6IHVzZXJQcm9maWxlLmVtcElkXHJcbiAgICAgICAgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHRhc2s6JywgZXJyb3IpO1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gR2V0IHRhc2tzIGJhc2VkIG9uIHVzZXIgcGVybWlzc2lvbnMgLSBPcHRpbWl6ZWQgd2l0aG91dCBsb2dzXHJcbmV4cG9ydCBjb25zdCBnZXRUYXNrcyA9IGFzeW5jICh1c2VyUHJvZmlsZSwgdGVhbUZpbHRlciA9IG51bGwpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCF1c2VyUHJvZmlsZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgcHJvZmlsZSBpcyByZXF1aXJlZCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGFsbFRhc2tzID0gW107XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSB3aGljaCB0ZWFtcyB1c2VyIGNhbiBhY2Nlc3NcclxuICAgICAgICBsZXQgYWNjZXNzaWJsZVRlYW1zO1xyXG4gICAgICAgIHN3aXRjaCAodXNlclByb2ZpbGUucm9sZSkge1xyXG4gICAgICAgICAgICBjYXNlICd0ZWNoLWxlYWQnOlxyXG4gICAgICAgICAgICAgICAgYWNjZXNzaWJsZVRlYW1zID0gWy4uLih1c2VyUHJvZmlsZS5tYW5hZ2VkVGVhbXMgfHwgW10pLCAndGVjaExlYWRzJ107XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAndGVhbS1sZWFkZXInOlxyXG4gICAgICAgICAgICBjYXNlICdlbXBsb3llZSc6XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NpYmxlVGVhbXMgPSBbdXNlclByb2ZpbGUudGVhbU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcHBseSB0ZWFtIGZpbHRlciBpZiBwcm92aWRlZFxyXG4gICAgICAgIGlmICh0ZWFtRmlsdGVyICYmIHRlYW1GaWx0ZXIgIT09ICdhbGwnKSB7XHJcbiAgICAgICAgICAgIGFjY2Vzc2libGVUZWFtcyA9IGFjY2Vzc2libGVUZWFtcy5maWx0ZXIodGVhbSA9PiB0ZWFtID09PSB0ZWFtRmlsdGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZldGNoIHRhc2tzIGZyb20gYWNjZXNzaWJsZSB0ZWFtc1xyXG4gICAgICAgIGZvciAoY29uc3QgdGVhbU5hbWUgb2YgYWNjZXNzaWJsZVRlYW1zKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGVzU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKGNvbGxlY3Rpb24oZGIsICd0ZWFtcycsIHRlYW1OYW1lLCAnZGF0ZXMnKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRhdGVEb2Mgb2YgZGF0ZXNTbmFwc2hvdC5kb2NzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRlID0gZGF0ZURvYy5pZDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVtcGxveWVlc1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uKGRiLCAndGVhbXMnLCB0ZWFtTmFtZSwgJ2RhdGVzJywgZGF0ZSwgJ2VtcGxveWVlcycpXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW1wRG9jIG9mIGVtcGxveWVlc1NuYXBzaG90LmRvY3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbXBJZCA9IGVtcERvYy5pZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdXNlciBjYW4gYWNjZXNzIHRoaXMgZW1wbG95ZWUncyBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5Vc2VyQWNjZXNzRW1wbG95ZWUodXNlclByb2ZpbGUsIHRlYW1OYW1lLCBlbXBJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXNrc1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbihkYiwgJ3RlYW1zJywgdGVhbU5hbWUsICdkYXRlcycsIGRhdGUsICdlbXBsb3llZXMnLCBlbXBJZCwgJ3Rhc2tzJylcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbXBUYXNrcyA9IHRhc2tzU25hcHNob3QuZG9jcy5tYXAodGFza0RvYyA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZWFtTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1wSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhc2tEb2MuZGF0YSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdGFza0RvYy5pZFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYWxsVGFza3MgPSBbLi4uYWxsVGFza3MsIC4uLmVtcFRhc2tzXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFsbFRhc2tzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHRhc2tzOicsIGVycm9yKTtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIFVwZGF0ZSBhIHRhc2sgKHdpdGggdXNlciBwZXJtaXNzaW9uIGNoZWNrKVxyXG5leHBvcnQgY29uc3QgdXBkYXRlVGFzayA9IGFzeW5jICh0ZWFtTmFtZSwgZGF0ZSwgZW1wSWQsIHRhc2tJZCwgdGFza0RhdGEsIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHVzZXIgY2FuIHVwZGF0ZSB0aGlzIHRhc2tcclxuICAgICAgICBpZiAoIWNhblVzZXJBY2Nlc3NFbXBsb3llZSh1c2VyUHJvZmlsZSwgdGVhbU5hbWUsIGVtcElkKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIHVwZGF0ZSB0aGlzIHRhc2snKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRhc2tSZWYgPSBkb2MoZGIsICd0ZWFtcycsIHRlYW1OYW1lLCAnZGF0ZXMnLCBkYXRlLCAnZW1wbG95ZWVzJywgZW1wSWQsICd0YXNrcycsIHRhc2tJZCk7XHJcbiAgICAgICAgYXdhaXQgdXBkYXRlRG9jKHRhc2tSZWYsIHtcclxuICAgICAgICAgICAgLi4udGFza0RhdGEsXHJcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgICB1cGRhdGVkQnk6IHVzZXJQcm9maWxlLmVtcElkXHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHRhc2s6JywgZXJyb3IpO1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gRGVsZXRlIGEgdGFzayAod2l0aCB1c2VyIHBlcm1pc3Npb24gY2hlY2spXHJcbmV4cG9ydCBjb25zdCBkZWxldGVUYXNrID0gYXN5bmMgKHRlYW1OYW1lLCBkYXRlLCBlbXBJZCwgdGFza0lkLCB1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBDaGVjayBpZiB1c2VyIGNhbiBkZWxldGUgdGhpcyB0YXNrXHJcbiAgICAgICAgaWYgKCFjYW5Vc2VyQWNjZXNzRW1wbG95ZWUodXNlclByb2ZpbGUsIHRlYW1OYW1lLCBlbXBJZCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBkZWxldGUgdGhpcyB0YXNrJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0YXNrUmVmID0gZG9jKGRiLCAndGVhbXMnLCB0ZWFtTmFtZSwgJ2RhdGVzJywgZGF0ZSwgJ2VtcGxveWVlcycsIGVtcElkLCAndGFza3MnLCB0YXNrSWQpO1xyXG4gICAgICAgIGF3YWl0IGRlbGV0ZURvYyh0YXNrUmVmKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgdGFzazonLCBlcnJvcik7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSBQRVJNSVNTSU9OIEhFTFBFUlMgLSBDbGVhbmVkIHdpdGhvdXQgbG9ncyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLy8gQ2hlY2sgaWYgdXNlciBjYW4gYWNjZXNzIHNwZWNpZmljIHRlYW1cclxuZXhwb3J0IGNvbnN0IGNhblVzZXJBY2Nlc3NUZWFtID0gKHVzZXJQcm9maWxlLCB0ZWFtTmFtZSkgPT4ge1xyXG4gICAgaWYgKCF1c2VyUHJvZmlsZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBzd2l0Y2ggKHVzZXJQcm9maWxlLnJvbGUpIHtcclxuICAgICAgICBjYXNlICd0ZWNoLWxlYWQnOlxyXG4gICAgICAgICAgICAvLyBUZWNoIGxlYWRzIGNhbiBhY2Nlc3MgdGVhbXMgdGhleSBtYW5hZ2Ugb3IgdGhlaXIgcGVyc29uYWwgdGVhbVxyXG4gICAgICAgICAgICBjb25zdCBjYW5BY2Nlc3NNYW5hZ2VkVGVhbSA9IHVzZXJQcm9maWxlLm1hbmFnZWRUZWFtcz8uaW5jbHVkZXModGVhbU5hbWUpO1xyXG4gICAgICAgICAgICBjb25zdCBjYW5BY2Nlc3NUZWNoTGVhZHNUZWFtID0gdGVhbU5hbWUgPT09ICd0ZWNoTGVhZHMnO1xyXG4gICAgICAgICAgICByZXR1cm4gY2FuQWNjZXNzTWFuYWdlZFRlYW0gfHwgY2FuQWNjZXNzVGVjaExlYWRzVGVhbTtcclxuXHJcbiAgICAgICAgY2FzZSAndGVhbS1sZWFkZXInOlxyXG4gICAgICAgIGNhc2UgJ2VtcGxveWVlJzpcclxuICAgICAgICAgICAgcmV0dXJuIHVzZXJQcm9maWxlLnRlYW1OYW1lID09PSB0ZWFtTmFtZTtcclxuXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gQ2hlY2sgaWYgdXNlciBjYW4gYWNjZXNzIHNwZWNpZmljIGVtcGxveWVlJ3MgZGF0YVxyXG5leHBvcnQgY29uc3QgY2FuVXNlckFjY2Vzc0VtcGxveWVlID0gKHVzZXJQcm9maWxlLCB0ZWFtTmFtZSwgZW1wSWQpID0+IHtcclxuICAgIGlmICghdXNlclByb2ZpbGUpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICBzd2l0Y2ggKHVzZXJQcm9maWxlLnJvbGUpIHtcclxuICAgICAgICBjYXNlICd0ZWNoLWxlYWQnOlxyXG4gICAgICAgICAgICByZXR1cm4gdXNlclByb2ZpbGUubWFuYWdlZFRlYW1zLmluY2x1ZGVzKHRlYW1OYW1lKTtcclxuICAgICAgICBjYXNlICd0ZWFtLWxlYWRlcic6XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VyUHJvZmlsZS50ZWFtTmFtZSA9PT0gdGVhbU5hbWU7XHJcbiAgICAgICAgY2FzZSAnZW1wbG95ZWUnOlxyXG4gICAgICAgICAgICByZXR1cm4gdXNlclByb2ZpbGUudGVhbU5hbWUgPT09IHRlYW1OYW1lICYmIHVzZXJQcm9maWxlLmVtcElkID09PSBlbXBJZDtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBHZXQgYWNjZXNzaWJsZSB0ZWFtcyBmb3IgY3VycmVudCB1c2VyXHJcbmV4cG9ydCBjb25zdCBnZXRBY2Nlc3NpYmxlVGVhbXMgPSAodXNlclByb2ZpbGUpID0+IHtcclxuICAgIGlmICghdXNlclByb2ZpbGUpIHJldHVybiBbXTtcclxuXHJcbiAgICBzd2l0Y2ggKHVzZXJQcm9maWxlLnJvbGUpIHtcclxuICAgICAgICBjYXNlICd0ZWNoLWxlYWQnOlxyXG4gICAgICAgICAgICByZXR1cm4gdXNlclByb2ZpbGUubWFuYWdlZFRlYW1zIHx8IFtdO1xyXG4gICAgICAgIGNhc2UgJ3RlYW0tbGVhZGVyJzpcclxuICAgICAgICBjYXNlICdlbXBsb3llZSc6XHJcbiAgICAgICAgICAgIHJldHVybiBbdXNlclByb2ZpbGUudGVhbU5hbWVdO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIEZJTFRFUiBCQVNFRCBPTiBST0xFUyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuZXhwb3J0IGNvbnN0IGdldEZpbHRlck9wdGlvbnMgPSBhc3luYyAodXNlclByb2ZpbGUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgdGVhbUxlYWRlcnM6IFtdLFxyXG4gICAgICAgICAgICBlbXBsb3llZXM6IFtdLFxyXG4gICAgICAgICAgICB0ZWFtczogW11cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoIXVzZXJQcm9maWxlKSByZXR1cm4gb3B0aW9ucztcclxuXHJcbiAgICAgICAgaWYgKHVzZXJQcm9maWxlLnJvbGUgPT09ICd0ZWNoLWxlYWQnKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMudGVhbXMgPSB1c2VyUHJvZmlsZS5tYW5hZ2VkVGVhbXMgfHwgW107XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGVhbSBsZWFkZXJzIGFuZCBlbXBsb3llZXMgZnJvbSBtYW5hZ2VkIHRlYW1zXHJcbiAgICAgICAgICAgIGNvbnN0IHRlYW1MZWFkZXJzU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICBjb25zdCBlbXBsb3llZXNTZXQgPSBuZXcgU2V0KCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRlYW1OYW1lIG9mIHVzZXJQcm9maWxlLm1hbmFnZWRUZWFtcykge1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRlYW0gbGVhZGVyc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGVhbUxlYWRlcnNRdWVyeSA9IHF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24oZGIsICd1c2VycycpLFxyXG4gICAgICAgICAgICAgICAgICAgIHdoZXJlKCdyb2xlJywgJz09JywgJ3RlYW0tbGVhZGVyJyksXHJcbiAgICAgICAgICAgICAgICAgICAgd2hlcmUoJ3RlYW1OYW1lJywgJz09JywgdGVhbU5hbWUpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGVhbUxlYWRlcnNTbmFwc2hvdCA9IGF3YWl0IGdldERvY3ModGVhbUxlYWRlcnNRdWVyeSk7XHJcbiAgICAgICAgICAgICAgICB0ZWFtTGVhZGVyc1NuYXBzaG90LmZvckVhY2goZG9jID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gZG9jLmRhdGEoKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZWFtTGVhZGVyc1NldC5hZGQoSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbXBJZDogZGF0YS5lbXBJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1wTmFtZTogZGF0YS5lbXBOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZWFtTmFtZTogZGF0YS50ZWFtTmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdldCBlbXBsb3llZXNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVtcGxveWVlc1F1ZXJ5ID0gcXVlcnkoXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbihkYiwgJ3VzZXJzJyksXHJcbiAgICAgICAgICAgICAgICAgICAgd2hlcmUoJ3JvbGUnLCAnPT0nLCAnZW1wbG95ZWUnKSxcclxuICAgICAgICAgICAgICAgICAgICB3aGVyZSgndGVhbU5hbWUnLCAnPT0nLCB0ZWFtTmFtZSlcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbXBsb3llZXNTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MoZW1wbG95ZWVzUXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgZW1wbG95ZWVzU25hcHNob3QuZm9yRWFjaChkb2MgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBkb2MuZGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVtcGxveWVlc1NldC5hZGQoSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbXBJZDogZGF0YS5lbXBJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1wTmFtZTogZGF0YS5lbXBOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZWFtTmFtZTogZGF0YS50ZWFtTmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvcHRpb25zLnRlYW1MZWFkZXJzID0gQXJyYXkuZnJvbSh0ZWFtTGVhZGVyc1NldCkubWFwKHN0ciA9PiBKU09OLnBhcnNlKHN0cikpO1xyXG4gICAgICAgICAgICBvcHRpb25zLmVtcGxveWVlcyA9IEFycmF5LmZyb20oZW1wbG95ZWVzU2V0KS5tYXAoc3RyID0+IEpTT04ucGFyc2Uoc3RyKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh1c2VyUHJvZmlsZS5yb2xlID09PSAndGVhbS1sZWFkZXInKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMudGVhbUxlYWRlcnMgPSBbe1xyXG4gICAgICAgICAgICAgICAgZW1wSWQ6IHVzZXJQcm9maWxlLmVtcElkLFxyXG4gICAgICAgICAgICAgICAgZW1wTmFtZTogdXNlclByb2ZpbGUuZW1wTmFtZSxcclxuICAgICAgICAgICAgICAgIHRlYW1OYW1lOiB1c2VyUHJvZmlsZS50ZWFtTmFtZVxyXG4gICAgICAgICAgICB9XTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCBlbXBsb3llZXMgZm9yIHRoaXMgdGVhbVxyXG4gICAgICAgICAgICBjb25zdCBlbXBsb3llZXNRdWVyeSA9IHF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbihkYiwgJ3VzZXJzJyksXHJcbiAgICAgICAgICAgICAgICB3aGVyZSgncm9sZScsICc9PScsICdlbXBsb3llZScpLFxyXG4gICAgICAgICAgICAgICAgd2hlcmUoJ3RlYW1OYW1lJywgJz09JywgdXNlclByb2ZpbGUudGVhbU5hbWUpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVtcGxveWVlc1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhlbXBsb3llZXNRdWVyeSk7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZW1wbG95ZWVzID0gZW1wbG95ZWVzU25hcHNob3QuZG9jcy5tYXAoZG9jID0+ICh7XHJcbiAgICAgICAgICAgICAgICBlbXBJZDogZG9jLmRhdGEoKS5lbXBJZCxcclxuICAgICAgICAgICAgICAgIGVtcE5hbWU6IGRvYy5kYXRhKCkuZW1wTmFtZSxcclxuICAgICAgICAgICAgICAgIHRlYW1OYW1lOiBkb2MuZGF0YSgpLnRlYW1OYW1lXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHVzZXJQcm9maWxlLnJvbGUgPT09ICdlbXBsb3llZScpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5lbXBsb3llZXMgPSBbe1xyXG4gICAgICAgICAgICAgICAgZW1wSWQ6IHVzZXJQcm9maWxlLmVtcElkLFxyXG4gICAgICAgICAgICAgICAgZW1wTmFtZTogdXNlclByb2ZpbGUuZW1wTmFtZSxcclxuICAgICAgICAgICAgICAgIHRlYW1OYW1lOiB1c2VyUHJvZmlsZS50ZWFtTmFtZVxyXG4gICAgICAgICAgICB9XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGZpbHRlciBvcHRpb25zOicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0ZWFtTGVhZGVyczogW10sXHJcbiAgICAgICAgICAgIGVtcGxveWVlczogW10sXHJcbiAgICAgICAgICAgIHRlYW1zOiBbXVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBPcHRpbWl6ZWQgdGFzayBmaWx0ZXJpbmcgdXNpbmcgY3JlYXRlZEF0IGZvciBkYXRlIG1hdGNoaW5nXHJcbmV4cG9ydCBjb25zdCBhcHBseVRhc2tGaWx0ZXJzID0gKHRhc2tzLCBmaWx0ZXJzLCB1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgaWYgKCF0YXNrcyB8fCB0YXNrcy5sZW5ndGggPT09IDApIHJldHVybiB0YXNrcztcclxuXHJcbiAgICBsZXQgZmlsdGVyZWRUYXNrcyA9IFsuLi50YXNrc107XHJcblxyXG4gICAgLy8gRGF0ZSByYW5nZSBmaWx0ZXIgdXNpbmcgY3JlYXRlZEF0XHJcbiAgICBpZiAoZmlsdGVycy5kYXRlRnJvbSkge1xyXG4gICAgICAgIGZpbHRlcmVkVGFza3MgPSBmaWx0ZXJlZFRhc2tzLmZpbHRlcih0YXNrID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0YXNrLmNyZWF0ZWRBdCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBjcmVhdGlvbkRhdGUgPSB0YXNrLmNyZWF0ZWRBdC5zcGxpdCgnVCcpWzBdO1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRpb25EYXRlID49IGZpbHRlcnMuZGF0ZUZyb207XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoZmlsdGVycy5kYXRlVG8pIHtcclxuICAgICAgICBmaWx0ZXJlZFRhc2tzID0gZmlsdGVyZWRUYXNrcy5maWx0ZXIodGFzayA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGFzay5jcmVhdGVkQXQpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgY3JlYXRpb25EYXRlID0gdGFzay5jcmVhdGVkQXQuc3BsaXQoJ1QnKVswXTtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0aW9uRGF0ZSA8PSBmaWx0ZXJzLmRhdGVUbztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUZWFtIGZpbHRlciAodGVjaCBsZWFkcyBvbmx5KVxyXG4gICAgaWYgKGZpbHRlcnMudGVhbSAmJiB1c2VyUHJvZmlsZS5yb2xlID09PSAndGVjaC1sZWFkJykge1xyXG4gICAgICAgIGZpbHRlcmVkVGFza3MgPSBmaWx0ZXJlZFRhc2tzLmZpbHRlcih0YXNrID0+IHRhc2sudGVhbU5hbWUgPT09IGZpbHRlcnMudGVhbSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGVhbSBsZWFkZXIgZmlsdGVyICh0ZWNoIGxlYWRzIG9ubHkpXHJcbiAgICBpZiAoZmlsdGVycy50ZWFtTGVhZGVyICYmIHVzZXJQcm9maWxlLnJvbGUgPT09ICd0ZWNoLWxlYWQnKSB7XHJcbiAgICAgICAgZmlsdGVyZWRUYXNrcyA9IGZpbHRlcmVkVGFza3MuZmlsdGVyKHRhc2sgPT4gdGFzay5lbXBJZCA9PT0gZmlsdGVycy50ZWFtTGVhZGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFbXBsb3llZSBmaWx0ZXIgKHRlY2ggbGVhZHMgYW5kIHRlYW0gbGVhZGVycylcclxuICAgIGlmIChmaWx0ZXJzLmVtcGxveWVlICYmICh1c2VyUHJvZmlsZS5yb2xlID09PSAndGVjaC1sZWFkJyB8fCB1c2VyUHJvZmlsZS5yb2xlID09PSAndGVhbS1sZWFkZXInKSkge1xyXG4gICAgICAgIGZpbHRlcmVkVGFza3MgPSBmaWx0ZXJlZFRhc2tzLmZpbHRlcih0YXNrID0+IHRhc2suZW1wSWQgPT09IGZpbHRlcnMuZW1wbG95ZWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmaWx0ZXJlZFRhc2tzO1xyXG59O1xyXG5cclxuLy8gR2V0IGZpbHRlcmVkIHRhc2tzIHdpdGggYWxsIGFwcGxpZWQgZmlsdGVyc1xyXG5leHBvcnQgY29uc3QgZ2V0RmlsdGVyZWRUYXNrcyA9IGFzeW5jICh1c2VyUHJvZmlsZSwgZmlsdGVycyA9IHt9KSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIEZpcnN0IGdldCBhbGwgYWNjZXNzaWJsZSB0YXNrc1xyXG4gICAgICAgIGNvbnN0IGFsbFRhc2tzID0gYXdhaXQgZ2V0VGFza3ModXNlclByb2ZpbGUpO1xyXG5cclxuICAgICAgICAvLyBUaGVuIGFwcGx5IGZpbHRlcnNcclxuICAgICAgICBjb25zdCBmaWx0ZXJlZFRhc2tzID0gYXBwbHlUYXNrRmlsdGVycyhhbGxUYXNrcywgZmlsdGVycywgdXNlclByb2ZpbGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gZmlsdGVyZWRUYXNrcztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBmaWx0ZXJlZCB0YXNrczonLCBlcnJvcik7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSBEUk9QRE9XTlMgV0lUSCBVU0VSIENPTlRFWFQgLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8vIEdldCBkcm9wZG93biBkYXRhIGZvciBhIHRlYW0gKHdpdGggdXNlciBwZXJtaXNzaW9uIGNoZWNrKVxyXG5leHBvcnQgY29uc3QgZ2V0VGVhbURyb3Bkb3duRGF0YSA9IGFzeW5jICh0ZWFtTmFtZSwgZmllbGQsIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHVzZXIgY2FuIGFjY2VzcyB0aGlzIHRlYW1cclxuICAgICAgICBpZiAoIWNhblVzZXJBY2Nlc3NUZWFtKHVzZXJQcm9maWxlLCB0ZWFtTmFtZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBhY2Nlc3MgdGhpcyB0ZWFtIGRhdGEnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBwcmVkZWZpbmVkIHZhbHVlcyBmb3Igc3BlY2lmaWMgZmllbGRzIC0gc2FtZSBmb3IgYWxsIHVzZXJzXHJcbiAgICAgICAgaWYgKFBSRURFRklORURfVkFMVUVTW2ZpZWxkXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUFJFREVGSU5FRF9WQUxVRVNbZmllbGRdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRm9yIGN1c3RvbSBkcm9wZG93biBkYXRhLCBmZXRjaCBmcm9tIEZpcmVzdG9yZVxyXG4gICAgICAgIGNvbnN0IGRvY1JlZiA9IGRvYyhkYiwgJ3RlYW1zJywgdGVhbU5hbWUsICdkcm9wZG93bkRhdGEnLCBmaWVsZCk7XHJcbiAgICAgICAgY29uc3QgZG9jU25hcCA9IGF3YWl0IGdldERvYyhkb2NSZWYpO1xyXG4gICAgICAgIGlmIChkb2NTbmFwLmV4aXN0cygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb2NTbmFwLmRhdGEoKS52YWx1ZXMgfHwgW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB0ZWFtIGRyb3Bkb3duIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgICAgIC8vIEFsd2F5cyByZXR1cm4gcHJlZGVmaW5lZCB2YWx1ZXMgYXMgZmFsbGJhY2tcclxuICAgICAgICByZXR1cm4gUFJFREVGSU5FRF9WQUxVRVNbZmllbGRdIHx8IFtdO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gU2F2ZSBkcm9wZG93biBkYXRhIGZvciBhIHRlYW0gKHdpdGggdXNlciBwZXJtaXNzaW9uIGNoZWNrKVxyXG5leHBvcnQgY29uc3Qgc2F2ZVRlYW1Ecm9wZG93bkRhdGEgPSBhc3luYyAodGVhbU5hbWUsIGZpZWxkLCB2YWx1ZXMsIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHVzZXIgY2FuIG1vZGlmeSB0aGlzIHRlYW0gZGF0YSAob25seSB0ZWFtIGxlYWRlcnMgYW5kIHRlY2ggbGVhZHMpXHJcbiAgICAgICAgaWYgKCFjYW5Vc2VyQWNjZXNzVGVhbSh1c2VyUHJvZmlsZSwgdGVhbU5hbWUpIHx8IHVzZXJQcm9maWxlLnJvbGUgPT09ICdlbXBsb3llZScpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBtb2RpZnkgdGVhbSBkYXRhJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEb24ndCBzYXZlIHByZWRlZmluZWQgdmFsdWVzIHRvIGRhdGFiYXNlXHJcbiAgICAgICAgaWYgKFBSRURFRklORURfVkFMVUVTW2ZpZWxkXSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYENhbm5vdCBzYXZlIHByZWRlZmluZWQgdmFsdWVzIGZvciBmaWVsZDogJHtmaWVsZH1gKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZG9jUmVmID0gZG9jKGRiLCAndGVhbXMnLCB0ZWFtTmFtZSwgJ2Ryb3Bkb3duRGF0YScsIGZpZWxkKTtcclxuICAgICAgICBhd2FpdCBzZXREb2MoZG9jUmVmLCB7IHZhbHVlcyB9LCB7IG1lcmdlOiB0cnVlIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgdGVhbSBkcm9wZG93biBkYXRhOicsIGVycm9yKTtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIFRFQU1TIFdJVEggVVNFUiBDT05URVhUIC0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vLyBHZXQgdGVhbXMgYWNjZXNzaWJsZSB0byB1c2VyXHJcbmV4cG9ydCBjb25zdCBnZXRUZWFtcyA9IGFzeW5jICh1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoIXVzZXJQcm9maWxlKSByZXR1cm4gW107XHJcbiAgICAgICAgcmV0dXJuIGdldEFjY2Vzc2libGVUZWFtcyh1c2VyUHJvZmlsZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdGVhbXM6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIFBST0pFQ1RTIFdJVEggVVNFUiBDT05URVhUIC0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vLyBHZXQgdGVhbS1zcGVjaWZpYyBwcm9qZWN0cyAod2l0aCB1c2VyIHBlcm1pc3Npb24gY2hlY2spXHJcbmV4cG9ydCBjb25zdCBnZXRUZWFtUHJvamVjdHMgPSBhc3luYyAodGVhbU5hbWUsIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICghY2FuVXNlckFjY2Vzc1RlYW0odXNlclByb2ZpbGUsIHRlYW1OYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhd2FpdCBnZXRUZWFtRHJvcGRvd25EYXRhKHRlYW1OYW1lLCAncHJvamVjdHMnLCB1c2VyUHJvZmlsZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdGVhbSBwcm9qZWN0czonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gQWRkIG5ldyBwcm9qZWN0IHRvIHRlYW0gKHdpdGggdXNlciBwZXJtaXNzaW9uIGNoZWNrKVxyXG5leHBvcnQgY29uc3QgYWRkVGVhbVByb2plY3QgPSBhc3luYyAodGVhbU5hbWUsIHByb2plY3RJZCwgcHJvamVjdE5hbWUsIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICghcHJvamVjdElkIHx8ICFwcm9qZWN0TmFtZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAoIWNhblVzZXJBY2Nlc3NUZWFtKHVzZXJQcm9maWxlLCB0ZWFtTmFtZSkgfHwgdXNlclByb2ZpbGUucm9sZSA9PT0gJ2VtcGxveWVlJykge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIFNpbGVudGx5IGZhaWwgZm9yIGVtcGxveWVlc1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdHMgPSBhd2FpdCBnZXRUZWFtUHJvamVjdHModGVhbU5hbWUsIHVzZXJQcm9maWxlKTtcclxuICAgICAgICBjb25zdCBleGlzdHMgPSBwcm9qZWN0cy5maW5kKHAgPT4gcC5pZCA9PT0gcHJvamVjdElkKTtcclxuICAgICAgICBpZiAoIWV4aXN0cykge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdQcm9qZWN0cyA9IFsuLi5wcm9qZWN0cywgeyBpZDogcHJvamVjdElkLCBuYW1lOiBwcm9qZWN0TmFtZSB9XTtcclxuICAgICAgICAgICAgYXdhaXQgc2F2ZVRlYW1Ecm9wZG93bkRhdGEodGVhbU5hbWUsICdwcm9qZWN0cycsIG5ld1Byb2plY3RzLCB1c2VyUHJvZmlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgdGVhbSBwcm9qZWN0OicsIGVycm9yKTtcclxuICAgICAgICAvLyBEb24ndCB0aHJvdyBlcnJvciB0byBwcmV2ZW50IHRhc2sgY3JlYXRpb24gZmFpbHVyZVxyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0gRU1QTE9ZRUVTIFdJVEggVVNFUiBDT05URVhUIC0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vLyBHZXQgdGVhbS1zcGVjaWZpYyBlbXBsb3llZXMgKHdpdGggdXNlciBwZXJtaXNzaW9uIGNoZWNrKVxyXG5leHBvcnQgY29uc3QgZ2V0VGVhbUVtcGxveWVlcyA9IGFzeW5jICh0ZWFtTmFtZSwgdXNlclByb2ZpbGUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCFjYW5Vc2VyQWNjZXNzVGVhbSh1c2VyUHJvZmlsZSwgdGVhbU5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IGdldFRlYW1Ecm9wZG93bkRhdGEodGVhbU5hbWUsICdlbXBsb3llZXMnLCB1c2VyUHJvZmlsZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdGVhbSBlbXBsb3llZXM6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIEFkZCBuZXcgZW1wbG95ZWUgdG8gdGVhbSAod2l0aCB1c2VyIHBlcm1pc3Npb24gY2hlY2spXHJcbmV4cG9ydCBjb25zdCBhZGRUZWFtRW1wbG95ZWUgPSBhc3luYyAodGVhbU5hbWUsIGVtcElkLCBlbXBOYW1lLCB1c2VyUHJvZmlsZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoIWVtcElkIHx8ICFlbXBOYW1lKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmICghY2FuVXNlckFjY2Vzc1RlYW0odXNlclByb2ZpbGUsIHRlYW1OYW1lKSB8fCB1c2VyUHJvZmlsZS5yb2xlID09PSAnZW1wbG95ZWUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gU2lsZW50bHkgZmFpbCBmb3IgZW1wbG95ZWVzXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBlbXBsb3llZXMgPSBhd2FpdCBnZXRUZWFtRW1wbG95ZWVzKHRlYW1OYW1lLCB1c2VyUHJvZmlsZSk7XHJcbiAgICAgICAgY29uc3QgZXhpc3RzID0gZW1wbG95ZWVzLmZpbmQoZSA9PiBlLmlkID09PSBlbXBJZCk7XHJcbiAgICAgICAgaWYgKCFleGlzdHMpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3RW1wbG95ZWVzID0gWy4uLmVtcGxveWVlcywgeyBpZDogZW1wSWQsIG5hbWU6IGVtcE5hbWUgfV07XHJcbiAgICAgICAgICAgIGF3YWl0IHNhdmVUZWFtRHJvcGRvd25EYXRhKHRlYW1OYW1lLCAnZW1wbG95ZWVzJywgbmV3RW1wbG95ZWVzLCB1c2VyUHJvZmlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgdGVhbSBlbXBsb3llZTonLCBlcnJvcik7XHJcbiAgICAgICAgLy8gRG9uJ3QgdGhyb3cgZXJyb3IgdG8gcHJldmVudCB0YXNrIGNyZWF0aW9uIGZhaWx1cmVcclxuICAgIH1cclxufTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIENMSUVOVFMgV0lUSCBVU0VSIENPTlRFWFQgLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8vIEdldCB0ZWFtLXNwZWNpZmljIGNsaWVudHMgKHdpdGggdXNlciBwZXJtaXNzaW9uIGNoZWNrKVxyXG5leHBvcnQgY29uc3QgZ2V0VGVhbUNsaWVudHMgPSBhc3luYyAodGVhbU5hbWUsIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICghY2FuVXNlckFjY2Vzc1RlYW0odXNlclByb2ZpbGUsIHRlYW1OYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhd2FpdCBnZXRUZWFtRHJvcGRvd25EYXRhKHRlYW1OYW1lLCAnY2xpZW50cycsIHVzZXJQcm9maWxlKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB0ZWFtIGNsaWVudHM6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIEFkZCBuZXcgY2xpZW50IHRvIHRlYW0gKHdpdGggdXNlciBwZXJtaXNzaW9uIGNoZWNrKVxyXG5leHBvcnQgY29uc3QgYWRkVGVhbUNsaWVudCA9IGFzeW5jICh0ZWFtTmFtZSwgY2xpZW50SWQsIGNsaWVudE5hbWUsIHVzZXJQcm9maWxlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICghY2xpZW50SWQgfHwgIWNsaWVudE5hbWUpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKCFjYW5Vc2VyQWNjZXNzVGVhbSh1c2VyUHJvZmlsZSwgdGVhbU5hbWUpIHx8IHVzZXJQcm9maWxlLnJvbGUgPT09ICdlbXBsb3llZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyBTaWxlbnRseSBmYWlsIGZvciBlbXBsb3llZXNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGNsaWVudHMgPSBhd2FpdCBnZXRUZWFtQ2xpZW50cyh0ZWFtTmFtZSwgdXNlclByb2ZpbGUpO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IGNsaWVudHMuZmluZChjID0+IGMuaWQgPT09IGNsaWVudElkKTtcclxuICAgICAgICBpZiAoIWV4aXN0cykge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdDbGllbnRzID0gWy4uLmNsaWVudHMsIHsgaWQ6IGNsaWVudElkLCBuYW1lOiBjbGllbnROYW1lIH1dO1xyXG4gICAgICAgICAgICBhd2FpdCBzYXZlVGVhbURyb3Bkb3duRGF0YSh0ZWFtTmFtZSwgJ2NsaWVudHMnLCBuZXdDbGllbnRzLCB1c2VyUHJvZmlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgdGVhbSBjbGllbnQ6JywgZXJyb3IpO1xyXG4gICAgICAgIC8vIERvbid0IHRocm93IGVycm9yIHRvIHByZXZlbnQgdGFzayBjcmVhdGlvbiBmYWlsdXJlXHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSBVVElMSVRZIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLy8gR2V0IHByZWRlZmluZWQgdmFsdWVzIGZvciBhIHNwZWNpZmljIGZpZWxkXHJcbmV4cG9ydCBjb25zdCBnZXRQcmVkZWZpbmVkVmFsdWVzID0gKGZpZWxkKSA9PiB7XHJcbiAgICByZXR1cm4gUFJFREVGSU5FRF9WQUxVRVNbZmllbGRdIHx8IFtdO1xyXG59O1xyXG5cclxuLy8gQ2hlY2sgaWYgZmllbGQgaGFzIHByZWRlZmluZWQgdmFsdWVzXHJcbmV4cG9ydCBjb25zdCBpc1ByZWRlZmluZWRGaWVsZCA9IChmaWVsZCkgPT4ge1xyXG4gICAgcmV0dXJuICEhUFJFREVGSU5FRF9WQUxVRVNbZmllbGRdO1xyXG59O1xyXG5cclxuLy8gQ2hlY2sgaWYgdGVhbSBkb2N1bWVudCBleGlzdHNcclxuZXhwb3J0IGNvbnN0IHRlYW1FeGlzdHMgPSBhc3luYyAodGVhbU5hbWUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgdGVhbURvYyA9IGF3YWl0IGdldERvYyhkb2MoZGIsICd0ZWFtcycsIHRlYW1OYW1lKSk7XHJcbiAgICAgICAgcmV0dXJuIHRlYW1Eb2MuZXhpc3RzKCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIEluaXRpYWxpemUgZGVmYXVsdCBkcm9wZG93biB2YWx1ZXMgZm9yIGEgdGVhbSAob25seSBpZiB0ZWFtIGRvZXNuJ3QgZXhpc3QgeWV0KVxyXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZVRlYW1EZWZhdWx0cyA9IGFzeW5jICh0ZWFtTmFtZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBleGlzdHMgPSBhd2FpdCB0ZWFtRXhpc3RzKHRlYW1OYW1lKTtcclxuICAgICAgICBpZiAoIWV4aXN0cykge1xyXG4gICAgICAgICAgICBhd2FpdCBzZXREb2MoZG9jKGRiLCAndGVhbXMnLCB0ZWFtTmFtZSksIHsgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgdGVhbSBkZWZhdWx0czonLCBlcnJvcik7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbn07Il0sIm5hbWVzIjpbImRiIiwiY29sbGVjdGlvbiIsImFkZERvYyIsImdldERvY3MiLCJkb2MiLCJ1cGRhdGVEb2MiLCJkZWxldGVEb2MiLCJnZXREb2MiLCJzZXREb2MiLCJxdWVyeSIsIndoZXJlIiwiUFJFREVGSU5FRF9WQUxVRVMiLCJwZXJjZW50YWdlQ29tcGxldGlvbiIsInN0YXR1cyIsIndvcmtUeXBlIiwiZ2V0VXNlclByb2ZpbGUiLCJ1c2VySWQiLCJ1c2VyRG9jIiwiZXhpc3RzIiwiZGF0YSIsImVycm9yIiwiY29uc29sZSIsInVwZGF0ZVVzZXJQcm9maWxlIiwicHJvZmlsZURhdGEiLCJtZXJnZSIsImFkZFRhc2siLCJ0YXNrIiwidXNlclByb2ZpbGUiLCJyb2xlIiwidGVhbU5hbWUiLCJjYW5Vc2VyQWNjZXNzRW1wbG95ZWUiLCJlbXBJZCIsIkVycm9yIiwiaW5pdGlhbGl6ZVRlYW1EZWZhdWx0cyIsImRhdGVSZWYiLCJkYXRlIiwiY3JlYXRlZEF0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiZW1wUmVmIiwibmFtZSIsImVtcE5hbWUiLCJhZGRUZWFtRW1wbG95ZWUiLCJjbGllbnRJZCIsImNsaWVudE5hbWUiLCJhZGRUZWFtQ2xpZW50IiwicHJvamVjdElkIiwicHJvamVjdE5hbWUiLCJhZGRUZWFtUHJvamVjdCIsImRvY1JlZiIsImNyZWF0ZWRCeSIsImlkIiwiZ2V0VGFza3MiLCJ0ZWFtRmlsdGVyIiwiYWxsVGFza3MiLCJhY2Nlc3NpYmxlVGVhbXMiLCJtYW5hZ2VkVGVhbXMiLCJmaWx0ZXIiLCJ0ZWFtIiwiZGF0ZXNTbmFwc2hvdCIsImRhdGVEb2MiLCJkb2NzIiwiZW1wbG95ZWVzU25hcHNob3QiLCJlbXBEb2MiLCJ0YXNrc1NuYXBzaG90IiwiZW1wVGFza3MiLCJtYXAiLCJ0YXNrRG9jIiwidXBkYXRlVGFzayIsInRhc2tJZCIsInRhc2tEYXRhIiwidGFza1JlZiIsInVwZGF0ZWRBdCIsInVwZGF0ZWRCeSIsImRlbGV0ZVRhc2siLCJjYW5Vc2VyQWNjZXNzVGVhbSIsImNhbkFjY2Vzc01hbmFnZWRUZWFtIiwiaW5jbHVkZXMiLCJjYW5BY2Nlc3NUZWNoTGVhZHNUZWFtIiwiZ2V0QWNjZXNzaWJsZVRlYW1zIiwiZ2V0RmlsdGVyT3B0aW9ucyIsIm9wdGlvbnMiLCJ0ZWFtTGVhZGVycyIsImVtcGxveWVlcyIsInRlYW1zIiwidGVhbUxlYWRlcnNTZXQiLCJTZXQiLCJlbXBsb3llZXNTZXQiLCJ0ZWFtTGVhZGVyc1F1ZXJ5IiwidGVhbUxlYWRlcnNTbmFwc2hvdCIsImZvckVhY2giLCJhZGQiLCJKU09OIiwic3RyaW5naWZ5IiwiZW1wbG95ZWVzUXVlcnkiLCJBcnJheSIsImZyb20iLCJzdHIiLCJwYXJzZSIsImFwcGx5VGFza0ZpbHRlcnMiLCJ0YXNrcyIsImZpbHRlcnMiLCJsZW5ndGgiLCJmaWx0ZXJlZFRhc2tzIiwiZGF0ZUZyb20iLCJjcmVhdGlvbkRhdGUiLCJzcGxpdCIsImRhdGVUbyIsInRlYW1MZWFkZXIiLCJlbXBsb3llZSIsImdldEZpbHRlcmVkVGFza3MiLCJnZXRUZWFtRHJvcGRvd25EYXRhIiwiZmllbGQiLCJkb2NTbmFwIiwidmFsdWVzIiwic2F2ZVRlYW1Ecm9wZG93bkRhdGEiLCJ3YXJuIiwiZ2V0VGVhbXMiLCJnZXRUZWFtUHJvamVjdHMiLCJwcm9qZWN0cyIsImZpbmQiLCJwIiwibmV3UHJvamVjdHMiLCJnZXRUZWFtRW1wbG95ZWVzIiwiZSIsIm5ld0VtcGxveWVlcyIsImdldFRlYW1DbGllbnRzIiwiY2xpZW50cyIsImMiLCJuZXdDbGllbnRzIiwiZ2V0UHJlZGVmaW5lZFZhbHVlcyIsImlzUHJlZGVmaW5lZEZpZWxkIiwidGVhbUV4aXN0cyIsInRlYW1Eb2MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./lib/firebase.js\n"));

/***/ })

});